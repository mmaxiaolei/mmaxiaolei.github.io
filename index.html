<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="xbiTmID1n2aAD90n7mafi0Hfvg1CBmIh75_D0ZaXdYo" />










  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="优生笑，菜鸟哭">
<meta property="og:type" content="website">
<meta property="og:title" content="Zacard's Notes">
<meta property="og:url" content="https://zacard.net/index.html">
<meta property="og:site_name" content="Zacard's Notes">
<meta property="og:description" content="优生笑，菜鸟哭">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zacard's Notes">
<meta name="twitter:description" content="优生笑，菜鸟哭">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'zacard'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zacard.net/"/>





  <title> Zacard's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?6ebbbd5859730fcc789698a808aff680";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Zacard's Notes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/02/netty-hashedwheeltimer/" itemprop="url">
                  netty源码解读之时间轮算法实现-HashedWheelTimer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-02T09:51:38+08:00">
                2016-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/12/02/netty-hashedwheeltimer/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/02/netty-hashedwheeltimer/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>由于netty动辄管理100w+的连接，每一个连接都会有很多超时任务。比如发送超时、心跳检测间隔等，如果每一个定时任务都启动一个<code>Timer</code>,不仅低效，而且会消耗大量的资源。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>根据George Varghese 和 Tony Lauck 1996 年的论文：<a href="http://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z" target="_blank" rel="external">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a>。提出了一种定时轮的方式来管理和维护大量的<code>Timer</code>调度.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>时间轮其实就是一种环形的数据结构，可以想象成时钟，分成很多格子，一个格子代码一段时间（这个时间越短，<code>Timer</code>的精度越高）。并用一个链表报错在该格子上的到期任务，同时一个指针随着时间一格一格转动，并执行相应格子中的到期任务。任务通过<code>取摸</code>决定放入那个格子。如下图所示：</p>
<p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/netty-hasedwheeltimer1.png" alt=""></p>
<p>以上图为例，假设一个格子是1秒，则整个wheel能表示的时间段为8s，假如当前指针指向2，此时需要调度一个3s后执行的任务，显然应该加入到(2+3=5)的方格中，指针再走3次就可以执行了；如果任务要在10s后执行，应该等指针走完一个round零2格再执行，因此应放入4，同时将round（1）保存到任务中。检查到期任务时应当只执行round为0的，格子上其他任务的round应减1。</p>
<p>是不是很像java中的<code>Hashmap</code>。其实就是<code>HashMap</code>的哈希拉链算法，只不过多了指针转动与一些定时处理的逻辑。所以其相关的操作和<code>HashMap</code>也一致：</p>
<ul>
<li>添加任务：O(1)</li>
<li>删除/取消任务：O(1)</li>
<li>过期/执行任务：最差情况为O(n)-&gt;也就是当<code>HashMap</code>里面的元素全部hash冲突，退化为一条链表的情况。平均O(1)-&gt;显然，格子越多，每个格子上的链表就越短，这里需要权衡时间与空间。</li>
</ul>
<h3 id="多层时间轮"><a href="#多层时间轮" class="headerlink" title="多层时间轮"></a>多层时间轮</h3><p>如果任务的时间跨度很大，数量很大，单层的时间轮会造成任务的<code>round</code>很大，单个格子的链表很长。这时候可以将时间轮分层，类似于时钟的时分秒3层。如下图所示：</p>
<p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/netty-hashedwheeltimer2.png" alt=""></p>
<p>但是个人认为，多层的时间轮造成的算法复杂度的进一步提升。单层时间轮只需增加每一轮的格子就能解决链表过长的问题。因此，更倾向使用单层的时间轮，netty4中时间轮的实现也是单层的。</p>
<h2 id="netty时间轮的实现-HashedWheelTimer"><a href="#netty时间轮的实现-HashedWheelTimer" class="headerlink" title="netty时间轮的实现-HashedWheelTimer"></a>netty时间轮的实现-HashedWheelTimer</h2><h3 id="简单使用示例"><a href="#简单使用示例" class="headerlink" title="简单使用示例"></a>简单使用示例</h3><p>1.引入netty依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;io.netty&lt;/groupId&gt;
    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
    &lt;version&gt;4.1.4.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>2.示例代码</p>
<p>示例1：</p>
<pre><code>@Test
public void test1() throws Exception {
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    HashedWheelTimer hashedWheelTimer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS);

    System.out.println(&quot;start:&quot; + LocalDateTime.now().format(formatter));

    hashedWheelTimer.newTimeout(timeout -&gt; {
        System.out.println(&quot;task :&quot; + LocalDateTime.now().format(formatter));
    }, 3, TimeUnit.SECONDS);
    Thread.sleep(5000);
}
</code></pre><p>输出为：</p>
<blockquote>
<p>start:2016-11-30 05:56:35</p>
<p>task :2016-11-30 05:56:38</p>
</blockquote>
<p>示例2：</p>
<pre><code>@Test
public void test2() throws Exception {
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    HashedWheelTimer hashedWheelTimer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS);

    System.out.println(&quot;start:&quot; + LocalDateTime.now().format(formatter));

    hashedWheelTimer.newTimeout(timeout -&gt; {
        Thread.sleep(3000);
        System.out.println(&quot;task1:&quot; + LocalDateTime.now().format(formatter));
    }, 3, TimeUnit.SECONDS);

    hashedWheelTimer.newTimeout(timeout -&gt; System.out.println(&quot;task2:&quot; + LocalDateTime.now().format(
            formatter)), 4, TimeUnit.SECONDS);

    Thread.sleep(10000);
}
</code></pre><p>输出：</p>
<blockquote>
<p>start:2016-12-01 08:32:37</p>
<p>task1:2016-12-01 08:32:43</p>
<p>task2:2016-12-01 08:32:43</p>
</blockquote>
<p>可以看到，当前一个任务执行时间过长的时候，会影响后续任务的到期执行时间的。也就是说其中的任务是串行执行的。所以，要求里面的任务都要短平快。</p>
<h3 id="HashedWheelTimer源码之构造函数"><a href="#HashedWheelTimer源码之构造函数" class="headerlink" title="HashedWheelTimer源码之构造函数"></a>HashedWheelTimer源码之构造函数</h3><pre><code>public HashedWheelTimer(
        ThreadFactory threadFactory, // 用来创建worker线程
        long tickDuration, // tick的时长，也就是指针多久转一格
        TimeUnit unit, // tickDuration的时间单位
        int ticksPerWheel, // 一圈有几格
        boolean leakDetection // 是否开启内存泄露检测
        ) {

    // 一些参数校验
    if (threadFactory == null) {
        throw new NullPointerException(&quot;threadFactory&quot;);
    }
    if (unit == null) {
        throw new NullPointerException(&quot;unit&quot;);
    }
    if (tickDuration &lt;= 0) {
        throw new IllegalArgumentException(&quot;tickDuration must be greater than 0: &quot; + tickDuration);
    }
    if (ticksPerWheel &lt;= 0) {
        throw new IllegalArgumentException(&quot;ticksPerWheel must be greater than 0: &quot; + ticksPerWheel);
    }

    // 创建时间轮基本的数据结构，一个数组。长度为不小于ticksPerWheel的最小2的n次方
    wheel = createWheel(ticksPerWheel);
    // 这是一个标示符，用来快速计算任务应该呆的格子。
    // 我们知道，给定一个deadline的定时任务，其应该呆的格子=deadline%wheel.length.但是%操作是个相对耗时的操作，所以使用一种变通的位运算代替：
    // 因为一圈的长度为2的n次方，mask = 2^n-1后低位将全部是1，然后deadline&amp;mast == deadline%wheel.length
    // java中的HashMap也是使用这种处理方法
    mask = wheel.length - 1;

    // 转换成纳秒处理
    this.tickDuration = unit.toNanos(tickDuration);

    // 校验是否存在溢出。即指针转动的时间间隔不能太长而导致tickDuration*wheel.length&gt;Long.MAX_VALUE
    if (this.tickDuration &gt;= Long.MAX_VALUE / wheel.length) {
        throw new IllegalArgumentException(String.format(
                &quot;tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d&quot;,
                tickDuration, Long.MAX_VALUE / wheel.length));
    }
    // 创建worker线程
    workerThread = threadFactory.newThread(worker);

    // 这里默认是启动内存泄露检测：当HashedWheelTimer实例超过当前cpu可用核数*4的时候，将发出警告
    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.open(this) : null;
}
</code></pre><p>再来看下<code>createWheel</code>的代码：</p>
<pre><code>private static HashedWheelBucket[] createWheel(int ticksPerWheel) {
    // 一些参数校验
    if (ticksPerWheel &lt;= 0) {
        throw new IllegalArgumentException(
                &quot;ticksPerWheel must be greater than 0: &quot; + ticksPerWheel);
    }
    if (ticksPerWheel &gt; 1073741824) {
        throw new IllegalArgumentException(
                &quot;ticksPerWheel may not be greater than 2^30: &quot; + ticksPerWheel);
    }

    // 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方
    ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);
    // 初始化wheel数组
    HashedWheelBucket[] wheel = new HashedWheelBucket[ticksPerWheel];
    for (int i = 0; i &lt; wheel.length; i ++) {
        wheel[i] = new HashedWheelBucket();
    }
    return wheel;
}
</code></pre><p><code>normalizeTicksPerWheel()</code>的代码：</p>
<pre><code>// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方
private static int normalizeTicksPerWheel(int ticksPerWheel) {
    int normalizedTicksPerWheel = 1;
    while (normalizedTicksPerWheel &lt; ticksPerWheel) {
        normalizedTicksPerWheel &lt;&lt;= 1;
    }
    return normalizedTicksPerWheel;
}
</code></pre><p>这里其实不建议使用这种方式，因为当ticksPerWheel的值很大的时候，这个方法会循环很多次，方法执行时间不稳定，效率也不够。推荐使用java8 HashMap的做法：</p>
<pre><code>private int normalizeTicksPerWheel(int ticksPerWheel) {
    // 这里参考java8 hashmap的算法，使推算的过程固定
    int n = ticksPerWheel - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    // 这里1073741824 = 2^30,防止溢出
    return (n &lt; 0) ? 1 : (n &gt;= 1073741824) ? 1073741824 : n + 1;
}
</code></pre><h3 id="HashedWheelTimer源码之启动、停止与添加任务"><a href="#HashedWheelTimer源码之启动、停止与添加任务" class="headerlink" title="HashedWheelTimer源码之启动、停止与添加任务"></a>HashedWheelTimer源码之启动、停止与添加任务</h3><p><code>start()</code>启动时间轮的方法：</p>
<pre><code>// 启动时间轮。这个方法其实不需要显示的主动调用，因为在添加定时任务（newTimeout()方法）的时候会自动调用此方法。
// 这个是合理的设计，因为如果时间轮里根本没有定时任务，启动时间轮也是空耗资源
public void start() {
    // 判断当前时间轮的状态，如果是初始化，则启动worker线程，启动整个时间轮；如果已经启动则略过；如果是已经停止，则报错
    // 这里是一个Lock Free的设计。因为可能有多个线程调用启动方法，这里使用AtomicIntegerFieldUpdater原子的更新时间轮的状态
    switch (WORKER_STATE_UPDATER.get(this)) {
        case WORKER_STATE_INIT:
            if (WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_INIT, WORKER_STATE_STARTED)) {
                workerThread.start();
            }
            break;
        case WORKER_STATE_STARTED:
            break;
        case WORKER_STATE_SHUTDOWN:
            throw new IllegalStateException(&quot;cannot be started once stopped&quot;);
        default:
            throw new Error(&quot;Invalid WorkerState&quot;);
    }

    // 等待worker线程初始化时间轮的启动时间
    while (startTime == 0) {
        try {
            startTimeInitialized.await();
        } catch (InterruptedException ignore) {
            // Ignore - it will be ready very soon.
        }
    }
}
</code></pre><p>AtomicIntegerFieldUpdater是JUC里面的类，原理是利用反射进行原子操作。有比AtomicInteger更好的性能和更低得内存占用。跟踪这个类的github 提交记录，可以看到更详细的<a href="https://github.com/netty/netty/commit/1f68479e3cd94deb3172edd3c01aa74f35032b9b" target="_blank" rel="external">原因</a></p>
<p><code>stop()</code>停止时间轮的方法：</p>
<pre><code>public Set&lt;Timeout&gt; stop() {
    // worker线程不能停止时间轮，也就是加入的定时任务，不能调用这个方法。
    // 不然会有恶意的定时任务调用这个方法而造成大量定时任务失效
    if (Thread.currentThread() == workerThread) {
        throw new IllegalStateException(
                HashedWheelTimer.class.getSimpleName() +
                        &quot;.stop() cannot be called from &quot; +
                        TimerTask.class.getSimpleName());
    }
    // 尝试CAS替换当前状态为“停止：2”。如果失败，则当前时间轮的状态只能是“初始化：0”或者“停止：2”。直接将当前状态设置为“停止：2“
    if (!WORKER_STATE_UPDATER.compareAndSet(this, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {
        // workerState can be 0 or 2 at this moment - let it always be 2.
        WORKER_STATE_UPDATER.set(this, WORKER_STATE_SHUTDOWN);

        if (leak != null) {
            leak.close();
        }

        return Collections.emptySet();
    }

    // 终端worker线程
    boolean interrupted = false;
    while (workerThread.isAlive()) {
        workerThread.interrupt();
        try {
            workerThread.join(100);
        } catch (InterruptedException ignored) {
            interrupted = true;
        }
    }

    // 从中断中恢复
    if (interrupted) {
        Thread.currentThread().interrupt();
    }

    if (leak != null) {
        leak.close();
    }
    // 返回未处理的任务
    return worker.unprocessedTimeouts();
}
</code></pre><p><code>newTimeout()</code>添加定时任务：</p>
<pre><code>public Timeout newTimeout(TimerTask task, long delay, TimeUnit unit) {
    // 参数校验
    if (task == null) {
        throw new NullPointerException(&quot;task&quot;);
    }
    if (unit == null) {
        throw new NullPointerException(&quot;unit&quot;);
    }
    // 如果时间轮没有启动，则启动
    start();

    // Add the timeout to the timeout queue which will be processed on the next tick.
    // During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.
    // 计算任务的deadline
    long deadline = System.nanoTime() + unit.toNanos(delay) - startTime;
    // 这里定时任务不是直接加到对应的格子中，而是先加入到一个队列里，然后等到下一个tick的时候，会从队列里取出最多100000个任务加入到指定的格子中
    HashedWheelTimeout timeout = new HashedWheelTimeout(this, task, deadline);
    timeouts.add(timeout);
    return timeout;
}
</code></pre><p>这里使用的Queue不是普通java自带的Queue的实现，而是使用<a href="https://github.com/JCTools/JCTools" target="_blank" rel="external">JCTool</a>–一个高性能的的并发Queue实现包。</p>
<h3 id="HashedWheelTimer源码之HashedWheelTimeout"><a href="#HashedWheelTimer源码之HashedWheelTimeout" class="headerlink" title="HashedWheelTimer源码之HashedWheelTimeout"></a>HashedWheelTimer源码之HashedWheelTimeout</h3><p><code>HashedWheelTimeout</code>是一个定时任务的内部包装类，双向链表结构。会保存定时任务到期执行的任务、deadline、round等信息。</p>
<pre><code>private static final class HashedWheelTimeout implements Timeout {

    // 定义定时任务的3个状态：初始化、取消、过期
    private static final int ST_INIT = 0;
    private static final int ST_CANCELLED = 1;
    private static final int ST_EXPIRED = 2;
    // 用来CAS方式更新定时任务状态
    private static final AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER;

    static {
        AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; updater =
                PlatformDependent.newAtomicIntegerFieldUpdater(HashedWheelTimeout.class, &quot;state&quot;);
        if (updater == null) {
            updater = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, &quot;state&quot;);
        }
        STATE_UPDATER = updater;
    }

    // 时间轮引用
    private final HashedWheelTimer timer;
    // 具体到期需要执行的任务
    private final TimerTask task;
    private final long deadline;

    @SuppressWarnings({&quot;unused&quot;, &quot;FieldMayBeFinal&quot;, &quot;RedundantFieldInitialization&quot; })
    private volatile int state = ST_INIT;

    // 离任务执行的轮数，当将次任务加入到格子中是计算该值，每过一轮，该值减一。
    long remainingRounds;

    // 双向链表结构，由于只有worker线程会访问，这里不需要synchronization / volatile
    HashedWheelTimeout next;
    HashedWheelTimeout prev;

    // 定时任务所在的格子
    HashedWheelBucket bucket;

    HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, long deadline) {
        this.timer = timer;
        this.task = task;
        this.deadline = deadline;
    }

    @Override
    public Timer timer() {
        return timer;
    }

    @Override
    public TimerTask task() {
        return task;
    }

    @Override
    public boolean cancel() {
        // 这里只是修改状态为ST_CANCELLED，会在下次tick时，在格子中移除      
        if (!compareAndSetState(ST_INIT, ST_CANCELLED)) {
            return false;
        }       
        // 加入到时间轮的待取消队列，并在每次tick的时候，从相应格子中移除。
        timer.cancelledTimeouts.add(this);
        return true;
    }

    // 从格子中移除自身
    void remove() {
        HashedWheelBucket bucket = this.bucket;
        if (bucket != null) {
            bucket.remove(this);
        }
    }

    public boolean compareAndSetState(int expected, int state) {
        return STATE_UPDATER.compareAndSet(this, expected, state);
    }

    public int state() {
        return state;
    }

    @Override
    public boolean isCancelled() {
        return state() == ST_CANCELLED;
    }

    @Override
    public boolean isExpired() {
        return state() == ST_EXPIRED;
    }

    // 过期并执行任务
    public void expire() {
        if (!compareAndSetState(ST_INIT, ST_EXPIRED)) {
            return;
        }

        try {
            task.run(this);
        } catch (Throwable t) {
            if (logger.isWarnEnabled()) {
                logger.warn(&quot;An exception was thrown by &quot; + TimerTask.class.getSimpleName() + &apos;.&apos;, t);
            }
        }
    }

    // 略过toString()
}
</code></pre><h3 id="HashedWheelTimer源码之HashedWheelBucket"><a href="#HashedWheelTimer源码之HashedWheelBucket" class="headerlink" title="HashedWheelTimer源码之HashedWheelBucket"></a>HashedWheelTimer源码之HashedWheelBucket</h3><p><code>HashedWheelBucket</code>用来存放HashedWheelTimeout，结构类似于LinkedList。提供了<code>expireTimeouts(long deadline)</code>方法来过期并执行格子中的定时任务</p>
<pre><code>private static final class HashedWheelBucket {
    // 指向格子中任务的首尾
    private HashedWheelTimeout head;
    private HashedWheelTimeout tail;

    // 基础的链表添加操作
    public void addTimeout(HashedWheelTimeout timeout) {
        assert timeout.bucket == null;
        timeout.bucket = this;
        if (head == null) {
            head = tail = timeout;
        } else {
            tail.next = timeout;
            timeout.prev = tail;
            tail = timeout;
        }
    }

    // 过期并执行格子中的到期任务，tick到该格子的时候，worker线程会调用这个方法，根据deadline和remainingRounds判断任务是否过期
    public void expireTimeouts(long deadline) {
        HashedWheelTimeout timeout = head;

        // 遍历格子中的所有定时任务
        while (timeout != null) {
            boolean remove = false;
            if (timeout.remainingRounds &lt;= 0) { // 定时任务到期
                if (timeout.deadline &lt;= deadline) {
                    timeout.expire();
                } else {
                    // 如果round数已经为0，deadline却&gt;当前格子的deadline，说放错格子了，这种情况应该不会出现
                    throw new IllegalStateException(String.format(
                            &quot;timeout.deadline (%d) &gt; deadline (%d)&quot;, timeout.deadline, deadline));
                }
                remove = true;
            } else if (timeout.isCancelled()) {
                remove = true;
            } else { //没有到期，轮数-1
                timeout.remainingRounds --;
            }
            // 先保存next，因为移除后next将被设置为null
            HashedWheelTimeout next = timeout.next;
            if (remove) {
                remove(timeout);
            }
            timeout = next;
        }
    }

    // 基础的链表移除node操作
    public void remove(HashedWheelTimeout timeout) {
        HashedWheelTimeout next = timeout.next;
        // remove timeout that was either processed or cancelled by updating the linked-list
        if (timeout.prev != null) {
            timeout.prev.next = next;
        }
        if (timeout.next != null) {
            timeout.next.prev = timeout.prev;
        }

        if (timeout == head) {
            // if timeout is also the tail we need to adjust the entry too
            if (timeout == tail) {
                tail = null;
                head = null;
            } else {
                head = next;
            }
        } else if (timeout == tail) {
            // if the timeout is the tail modify the tail to be the prev node.
            tail = timeout.prev;
        }
        // null out prev, next and bucket to allow for GC.
        timeout.prev = null;
        timeout.next = null;
        timeout.bucket = null;
    }

    /**
     * Clear this bucket and return all not expired / cancelled {@link Timeout}s.
     */
    public void clearTimeouts(Set&lt;Timeout&gt; set) {
        for (;;) {
            HashedWheelTimeout timeout = pollTimeout();
            if (timeout == null) {
                return;
            }
            if (timeout.isExpired() || timeout.isCancelled()) {
                continue;
            }
            set.add(timeout);
        }
    }

    // 链表的poll操作
    private HashedWheelTimeout pollTimeout() {
        HashedWheelTimeout head = this.head;
        if (head == null) {
            return null;
        }
        HashedWheelTimeout next = head.next;
        if (next == null) {
            tail = this.head =  null;
        } else {
            this.head = next;
            next.prev = null;
        }

        // null out prev and next to allow for GC.
        head.next = null;
        head.prev = null;
        head.bucket = null;
        return head;
    }
}
</code></pre><h3 id="HashedWheelTimer源码之Worker"><a href="#HashedWheelTimer源码之Worker" class="headerlink" title="HashedWheelTimer源码之Worker"></a>HashedWheelTimer源码之Worker</h3><p><code>Worker</code>是时间轮的核心线程类。tick的转动，过期任务的处理都是在这个线程中处理的。</p>
<pre><code>private final class Worker implements Runnable {
    private final Set&lt;Timeout&gt; unprocessedTimeouts = new HashSet&lt;Timeout&gt;();

    private long tick;

    @Override
    public void run() {
        // 初始化startTime.只有所有任务的的deadline都是想对于这个时间点
        startTime = System.nanoTime();
        // 由于System.nanoTime()可能返回0，甚至负数。并且0是一个标示符，用来判断startTime是否被初始化，所以当startTime=0的时候，重新赋值为1
        if (startTime == 0) {
            startTime = 1;
        }

        // 唤醒阻塞在start()的线程
        startTimeInitialized.countDown();

        // 只要时间轮的状态为WORKER_STATE_STARTED，就循环的“转动”tick，循环判断响应格子中的到期任务
        do {
            // waitForNextTick方法主要是计算下次tick的时间, 然后sleep到下次tick
            // 返回值就是System.nanoTime() - startTime, 也就是Timer启动后到这次tick, 所过去的时间
            final long deadline = waitForNextTick();
            if (deadline &gt; 0) { // 可能溢出或者被中断的时候会返回负数, 所以小于等于0不管
                // 获取tick对应的格子索引
                int idx = (int) (tick &amp; mask);
                // 移除被取消的任务
                processCancelledTasks();
                HashedWheelBucket bucket =
                        wheel[idx];
                // 从任务队列中取出任务加入到对应的格子中
                transferTimeoutsToBuckets();
                // 过期执行格子中的任务
                bucket.expireTimeouts(deadline);
                tick++;
            }
        } while (WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == WORKER_STATE_STARTED);

        // 这里应该是时间轮停止了，清除所有格子中的任务，并加入到未处理任务列表，以供stop()方法返回
        for (HashedWheelBucket bucket: wheel) {
            bucket.clearTimeouts(unprocessedTimeouts);
        }
        // 将还没有加入到格子中的待处理定时任务队列中的任务取出，如果是未取消的任务，则加入到未处理任务队列中，以供stop()方法返回
        for (;;) {
            HashedWheelTimeout timeout = timeouts.poll();
            if (timeout == null) {
                break;
            }
            if (!timeout.isCancelled()) {
                unprocessedTimeouts.add(timeout);
            }
        }
        // 处理取消的任务
        processCancelledTasks();
    }

    // 将newTimeout()方法中加入到待处理定时任务队列中的任务加入到指定的格子中
    private void transferTimeoutsToBuckets() {
        // 每次tick只处理10w个任务，以免阻塞worker线程
        for (int i = 0; i &lt; 100000; i++) {
            HashedWheelTimeout timeout = timeouts.poll();
            // 如果没有任务了，直接跳出循环
            if (timeout == null) {
                break;
            }
            // 还没有放入到格子中就取消了，直接略过
            if (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {
                continue;
            }

            // 计算任务需要经过多少个tick
            long calculated = timeout.deadline / tickDuration;
            // 计算任务的轮数
            timeout.remainingRounds = (calculated - tick) / wheel.length;

            //如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行.
            final long ticks = Math.max(calculated, tick); // Ensure we don&apos;t schedule for past.
            int stopIndex = (int) (ticks &amp; mask);

            // 将任务加入到响应的格子中
            HashedWheelBucket bucket = wheel[stopIndex];
            bucket.addTimeout(timeout);
        }
    }

    // 将取消的任务取出，并从格子中移除
    private void processCancelledTasks() {
        for (;;) {
            HashedWheelTimeout timeout = cancelledTimeouts.poll();
            if (timeout == null) {
                // all processed
                break;
            }
            try {
                timeout.remove();
            } catch (Throwable t) {
                if (logger.isWarnEnabled()) {
                    logger.warn(&quot;An exception was thrown while process a cancellation task&quot;, t);
                }
            }
        }
    }

    /**
     * calculate goal nanoTime from startTime and current tick number,
     * then wait until that goal has been reached.
     * @return Long.MIN_VALUE if received a shutdown request,
     * current time otherwise (with Long.MIN_VALUE changed by +1)
     */
    //sleep, 直到下次tick到来, 然后返回该次tick和启动时间之间的时长
    private long waitForNextTick() {
        //下次tick的时间点, 用于计算需要sleep的时间
        long deadline = tickDuration * (tick + 1);

        for (;;) {
            // 计算需要sleep的时间, 之所以加999999后再除10000000, 是为了保证足够的sleep时间
            // 例如：当deadline - currentTime=2000002的时候，如果不加999999，则只睡了2ms，
            // 而2ms其实是未到达deadline这个时间点的，所有为了使上述情况能sleep足够的时间，加上999999后，会多睡1ms
            final long currentTime = System.nanoTime() - startTime;
            long sleepTimeMs = (deadline - currentTime + 999999) / 1000000;

            if (sleepTimeMs &lt;= 0) {
                // 以下为个人理解：（如有错误，欢迎大家指正）
                // 这里的意思应该是从时间轮启动到现在经过太长的时间(跨度大于292年...)，以至于让long装不下，都溢出了...对于netty的严谨，我服！
                if (currentTime == Long.MIN_VALUE) {
                    return -Long.MAX_VALUE;
                } else {
                    return currentTime;
                }
            }

            // Check if we run on windows, as if thats the case we will need
            // to round the sleepTime as workaround for a bug that only affect
            // the JVM if it runs on windows.
            //
            // See https://github.com/netty/netty/issues/356
            if (PlatformDependent.isWindows()) { // 这里是因为windows平台的定时调度最小单位为10ms，如果不是10ms的倍数，可能会引起sleep时间不准确
                sleepTimeMs = sleepTimeMs / 10 * 10;
            }

            try {
                Thread.sleep(sleepTimeMs);
            } catch (InterruptedException ignored) {
                // 调用HashedWheelTimer.stop()时优雅退出
                if (WORKER_STATE_UPDATER.get(HashedWheelTimer.this) == WORKER_STATE_SHUTDOWN) {
                    return Long.MIN_VALUE;
                }
            }
        }
    }

    public Set&lt;Timeout&gt; unprocessedTimeouts() {
        return Collections.unmodifiableSet(unprocessedTimeouts);
    }
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读源码，学到了很多之前不知道的知识点和注意事项。比如：</p>
<ol>
<li>操作数字型要考虑溢出问题</li>
<li>System.nanoTime(）返回值</li>
<li>Atomic*FieldUpdater类的运用</li>
<li>一些代码设计方式</li>
<li>不断优化性能，Lock Less代替Lock；Lock Free 代码Lock Less</li>
<li>JCTool高性能队列的使用</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/09/11/spring3-async/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/11/spring3-async/" itemprop="url">
                  spring3的@Async异步执行失效
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-11T09:45:37+08:00">
                2016-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/09/11/spring3-async/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/11/spring3-async/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近有个项目的spring的<code>@Async</code>的异步执行突然失效了。生产环境异步执行正常，那肯定是开发改了某个地方而导致的。</p>
<h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>查看最近提交代码记录。与<code>@Async</code>有相关的改动只有一个spring.xml的改动。初步推断是这个改动引起的。回滚这部分代码，跑测试类，果然异步执行生效了。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>在stackoverflow中找到了答案：</p>
<blockquote>
<p>In short, the context loaded by the ContextLoaderListener (generally from applicationContext.xml) is the parent of the context loaded by the DispatcherServlet (generally from <em>-servlet.xml). If you have the bean with the @Async method declared/component-scanned in both contexts, the version from the child context (DispatcherServlet) will override the one in the parent context (ContextLoaderListener). I verified this by excluding that component from component scanning in the </em>-servlet.xml – it now works as expected. </p>
</blockquote>
<p>意思是说：如果项目中存在多个配置文件（例如：applicationContext.xml、applicationContext-servlet.xml）并且这两个文件中配置的扫描包（即配置的：context:component-scan）都包含了配置过@Async的bean，那么后者就会覆盖前者。</p>
<p>例如以下xml配置:</p>
<p>applicationContext.xml:</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.demo&quot; /&gt;
&lt;task:annotation-driven/&gt;
&lt;task:executor id=&quot;executor&quot; pool-size=&quot;5-10&quot; queue-capacity=&quot;100&quot; rejection-policy=&quot;CALLER_RUNS&quot;/&gt;
</code></pre><p>applicationContext-servlet.xml:</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.demo&quot; /&gt;
</code></pre><p>并且在web.xml中配置的加载顺序为：applicationContext.xml &gt; applicationContext-servlet.xml，那么后者的component-scan就会覆盖前者的，同时前者配置的task也会被覆盖掉不起作用！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/09/08/mac-jdk-dir/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/08/mac-jdk-dir/" itemprop="url">
                  mac中jdk的路径
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-08T11:20:08+08:00">
                2016-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/09/08/mac-jdk-dir/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/08/mac-jdk-dir/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mac中如何查询jdk安装路径"><a href="#mac中如何查询jdk安装路径" class="headerlink" title="mac中如何查询jdk安装路径"></a>mac中如何查询jdk安装路径</h1><p>可以使用工具命令<code>/usr/libexec/java_home</code>.</p>
<p>例如以下所示：</p>
<p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/mac-jdk-dir1.png" alt=""></p>
<p>还可以加-V选项列出所有的java home.</p>
<p>例如以下所示:</p>
<p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/mac-jdk-dir2.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/08/29/hash-collision/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/29/hash-collision/" itemprop="url">
                  Hash碰撞
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-29T15:54:02+08:00">
                2016-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/08/29/hash-collision/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/29/hash-collision/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Hash定义"><a href="#Hash定义" class="headerlink" title="Hash定义"></a>Hash定义</h1><p>摘自百度百科：</p>
<blockquote>
<p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
</blockquote>
<h1 id="为什么会产生Hash碰撞"><a href="#为什么会产生Hash碰撞" class="headerlink" title="为什么会产生Hash碰撞"></a>为什么会产生Hash碰撞</h1><blockquote>
<p>…通过散列算法，变换成固定长度的输出，该输出就是散列值…</p>
</blockquote>
<p>既然是根据输入值，变换成<strong>固定长度</strong>的输出，那就必然会存在不同的输入产生相同的输出。</p>
<h1 id="如何解决Hash碰撞"><a href="#如何解决Hash碰撞" class="headerlink" title="如何解决Hash碰撞"></a>如何解决Hash碰撞</h1><h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><p>这种方法就是在计算一个key的哈希的时候，发现目标地址已经有值了，即发生冲突了，这个时候通过相应的函数在此地址后面的地址去找，直到没有冲突为止。这个方法常用的有线性探测，二次探测，再哈希。这种解决方法有个不好的地方就是，当发生冲突之后，会在之后的地址空间中找一个放进去，这样就有可能后来出现一个key哈希出来的结果也正好是它放进去的这个地址空间，这样就会出现非同义词的两个key发生冲突。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/29/hash-collision/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/08/26/treeMap-theory/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/26/treeMap-theory/" itemprop="url">
                  红黑树&TreeMap的实现原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-26T21:02:14+08:00">
                2016-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/08/26/treeMap-theory/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/26/treeMap-theory/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于TreeMap的实现原理就是以红黑树为基础数据结构的，所以基本也是红黑树的原理解读。</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>红黑树是一种自平衡的二叉查找树。是一种复杂但高效的数据结构，它可以在O(log n)时间内做查找，插入和删除。</p>
<p>红黑树的规定：</p>
<p>1.一个节点只能是红色或者黑色<br>2.根节点是黑色<br>3.每个叶节点（null节点/空节点）为黑色<br>4.如果一个节点为红色，则他们的2个子节点都为黑色<br>5.从任意节点到其每个叶节点</p>
<p>红黑树结构java代码示例：（TreeMap中的内部类Entry）</p>
<pre><code>/**
 * 红黑树节点结构
 */
static final class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; {
    K key; // 红黑树的排序字段
    V value; // 节点存储的值
    Entry&lt;K, V&gt; left; // 左子树节点
    Entry&lt;K, V&gt; right; // 右子树节点
    Entry&lt;K, V&gt; parent; // 父节点
    boolean color = BLACK; // 节点颜色，默认为黑

    /**
     * Make a new cell with given key, value, and parent, and with
     * {@code null} child links, and BLACK color.
     */
    Entry(K key, V value, Entry&lt;K, V&gt; parent) {
        this.key = key;
        this.value = value;
        this.parent = parent;
    }

    /**
     * Returns the key.
     *
     * @return the key
     */
    public K getKey() {
        return key;
    }

    /**
     * Returns the value associated with the key.
     *
     * @return the value associated with the key
     */
    public V getValue() {
        return value;
    }

    /**
     * Replaces the value currently associated with the key with the given
     * value.
     *
     * @return the value associated with the key before this method was
     * called
     */
    public V setValue(V value) {
        V oldValue = this.value;
        this.value = value;
        return oldValue;
    }

    public boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry&lt;?, ?&gt; e = (Map.Entry&lt;?, ?&gt;) o;

        return valEquals(key, e.getKey()) &amp;&amp; valEquals(value, e.getValue());
    }

    public int hashCode() {
        int keyHash = (key == null ? 0 : key.hashCode());
        int valueHash = (value == null ? 0 : value.hashCode());
        return keyHash ^ valueHash;
    }

    public String toString() {
        return key + &quot;=&quot; + value;
    }
}
</code></pre>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/26/treeMap-theory/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/08/19/why-chmod777/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/19/why-chmod777/" itemprop="url">
                  chmod777原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-19T17:06:47+08:00">
                2016-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/08/19/why-chmod777/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/19/why-chmod777/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>很多Linux新手发现某个文件没有相关权限，一言不合就是<code>chmod 777</code>。<strong>首先说一句，<code>chmod 777</code>应该杜绝使用，尤其生产环境。</strong></p>
<p>那<code>chmod 777</code>的背后原理到底是什么呢？</p>
<h3 id="Unix权限设计"><a href="#Unix权限设计" class="headerlink" title="Unix权限设计"></a>Unix权限设计</h3><p>首先Unix系统的权限分为三种，分别为拥有者(owner)、用户组(group)、其他用户(other)。用<code>ll</code>命令可以查看具体的权限设置，如下图所示：</p>
<p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/819111111.png" alt=""></p>
<p>每个项目前面那一串字母和横杠就是权限。第一位指的是文件类型：-代表普通文件，d代表文件夹。后面9位分为三组，每组代表了对应用户的权限：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/113/263/113263737-57ad2eec7ba6e_articlex" alt=""></p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/19/why-chmod777/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/08/12/docker-7-jetty/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/12/docker-7-jetty/" itemprop="url">
                  Docker学习系列七：构建jetty镜像
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-12T09:51:38+08:00">
                2016-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/08/12/docker-7-jetty/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/12/docker-7-jetty/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Docker hub官方已经维护了一套比较完善的jetty镜像，但是依赖的是openjdk。所以这里只是把jdk换成之前学习系列中构建过的oracle-jdk8。</p>
<h3 id="Dockerfile描述"><a href="#Dockerfile描述" class="headerlink" title="Dockerfile描述"></a>Dockerfile描述</h3><pre><code>FROM oraclejdk8
MAINTAINER zacard &lt;mmaxiaolei@gmail.com&gt;

# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN addgroup -S jetty &amp;&amp; adduser -D -S -H -G jetty jetty &amp;&amp; rm -rf /etc/group- /etc/passwd- /etc/shadow-

ENV JETTY_HOME /usr/local/jetty
ENV PATH $JETTY_HOME/bin:$PATH
RUN mkdir -p &quot;$JETTY_HOME&quot;
WORKDIR $JETTY_HOME

ENV JETTY_BASE /var/lib/jetty
RUN mkdir -p &quot;$JETTY_BASE&quot;

ENV JETTY_VERSION 9.3.10.v20160621
ENV JETTY_TGZ_URL https://repo1.maven.org/maven2/org/eclipse/jetty/jetty-distribution/$JETTY_VERSION/jetty-distribution-$JETTY_VERSION.tar.gz

# GPG Keys are personal keys of Jetty committers (see https://dev.eclipse.org/mhonarc/lists/jetty-users/msg05220.html)
ENV JETTY_GPG_KEYS \
        # 1024D/8FB67BAC 2006-12-10 Joakim Erdfelt &lt;joakime@apache.org&gt;
        B59B67FD7904984367F931800818D9D68FB67BAC \
        # 1024D/D7C58886 2010-03-09 Jesse McConnell (signing key) &lt;jesse.mcconnell@gmail.com&gt;
        5DE533CB43DAF8BC3E372283E7AE839CD7C58886

RUN set -xe \
        # Install required packages for build time. Will be removed when build finishes.
        &amp;&amp; apk add --no-cache --virtual .build-deps gnupg coreutils curl \

        &amp;&amp; curl -SL &quot;$JETTY_TGZ_URL&quot; -o jetty.tar.gz \
        &amp;&amp; curl -SL &quot;$JETTY_TGZ_URL.asc&quot; -o jetty.tar.gz.asc \
        &amp;&amp; export GNUPGHOME=&quot;$(mktemp -d)&quot; \
        &amp;&amp; for key in $JETTY_GPG_KEYS; do \
                gpg --keyserver ha.pool.sks-keyservers.net --recv-keys &quot;$key&quot;; done \
        &amp;&amp; gpg --batch --verify jetty.tar.gz.asc jetty.tar.gz \
        &amp;&amp; rm -r &quot;$GNUPGHOME&quot; \
        &amp;&amp; tar -xvzf jetty.tar.gz \
        &amp;&amp; mv jetty-distribution-$JETTY_VERSION/* ./ \
        &amp;&amp; sed -i &apos;/jetty-logging/d&apos; etc/jetty.conf \
        &amp;&amp; rm -fr demo-base javadoc \
        &amp;&amp; rm jetty.tar.gz* \
        &amp;&amp; rm -fr jetty-distribution-$JETTY_VERSION/ \

        # Get the list of modules in the default start.ini and build new base with those modules, then add setuid
        &amp;&amp; cd $JETTY_BASE \
        &amp;&amp; modules=&quot;$(grep -- ^--module= &quot;$JETTY_HOME/start.ini&quot; | cut -d= -f2 | paste -d, -s)&quot; \
        &amp;&amp; java -jar &quot;$JETTY_HOME/start.jar&quot; --add-to-startd=&quot;$modules,setuid&quot; \

        # Remove installed packages and various cleanup
        &amp;&amp; apk del .build-deps \
        &amp;&amp; rm -fr .build-deps \
        &amp;&amp; rm -rf /tmp/hsperfdata_root

WORKDIR $JETTY_BASE

ENV TMPDIR /tmp/jetty
RUN set -xe \
        &amp;&amp; mkdir -p &quot;$TMPDIR&quot; \
        &amp;&amp; chown -R jetty:jetty &quot;$TMPDIR&quot; &quot;$JETTY_BASE&quot;

COPY docker-entrypoint.sh /

EXPOSE 8080
ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]
CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;/usr/local/jetty/start.jar&quot;]
</code></pre>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/12/docker-7-jetty/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/08/09/java-pass-by-value-or-reference/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/09/java-pass-by-value-or-reference/" itemprop="url">
                  java是值传递还是引用传递
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-09T16:46:53+08:00">
                2016-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/08/09/java-pass-by-value-or-reference/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/09/java-pass-by-value-or-reference/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="java到底是值传递还是引用传递"><a href="#java到底是值传递还是引用传递" class="headerlink" title="java到底是值传递还是引用传递"></a>java到底是值传递还是引用传递</h3><blockquote>
<p>“Java manipulates objects ‘by reference,’ but it passes object references to methods ‘by value.’” –David Flanagan</p>
</blockquote>
<p><strong>大神解释了：java操作对象都是通过引用传递，而给方法传参都是通过值传递</strong></p>
<p>首先，操作对象通过引用传递这个大家应该没有什么争议。但是方法传参都是通过值传递，估计大家还有些疑虑。</p>
<h4 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h4><p>我们知道，如果是值传递，那么实际上传的是一份拷贝。引用传递的话一般传递的是内存地址（看具体的jvm实现）。<br>所以，值传递是无法修改原值的，而引用传递是可以修改原值。</p>
<p>请看以下代码例子:</p>
<pre><code>@Test
public void testPassedByValueOrReference() {
    char[] c1 = {&apos;a&apos;,&apos;b&apos;};
    change1(c1);
    System.out.println(&quot;c1 after change1:&quot; + Arrays.toString(c1));
    change2(c1);
    System.out.println(&quot;c1 after change2:&quot; + Arrays.toString(c1));
}

private void change1(char[] c1) {
    char[] c2 = {&apos;e&apos;,&apos;f&apos;};
    c1 = c2;
}

private void change2(char[] c1) {
    char[] c2 = {&apos;e&apos;,&apos;f&apos;};
    c1[0] = c2[0];
}
</code></pre><p>输出：</p>
<pre><code>c1 after change1:[a, b]
c1 after change2:[e, b]
</code></pre><p>我们知道，数组是个对象。传递给2个不同的方法，确出现了不一致的行为，既有点像值传递，有好像是引用传递。我们来看看这2个方法在内存中到底做了什么：</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/09/java-pass-by-value-or-reference/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/07/15/docker-six-zookeeper/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/15/docker-six-zookeeper/" itemprop="url">
                  docker学习系列六：构建zookeeper镜像
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-15T15:57:33+08:00">
                2016-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/07/15/docker-six-zookeeper/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/15/docker-six-zookeeper/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是zookeeper"><a href="#什么是zookeeper" class="headerlink" title="什么是zookeeper"></a>什么是zookeeper</h3><p>zookeeper 是一个分布式的，开源的协调服务框架，服务于分布式应用程序。</p>
<h3 id="为什么要zookeeper"><a href="#为什么要zookeeper" class="headerlink" title="为什么要zookeeper"></a>为什么要zookeeper</h3><p>可以将分布式应用从处理协调服务的泥潭中解救出来。且性能优越，设计简洁优雅。</p>
<ul>
<li>顺序一致性: 来自客户端的更新操作将会按照顺序被作用</li>
<li>原子性操作: 更新要么全部成功,要么全部失败,没有部分的结果</li>
<li>统一的系统镜像: 无论客户端链接的是哪台服务器,都能获得同样的服务视图,也就是说他是无状态的</li>
<li>可靠性保证: 一旦写入操作被执行(作用到服务器),这个状态将会被持久化,直到其他客户端的修改生效</li>
<li>时间线特性: 客户端访问服务器系统镜像能在一个特定时间访问内保证当前系统是实时更新的</li>
</ul>
<h3 id="Dockfile"><a href="#Dockfile" class="headerlink" title="Dockfile"></a>Dockfile</h3><pre><code>FROM oraclejdk8
MAINTAINER zacard &lt;mmaxiaolei@gmail.com&gt;

# Install required packages
RUN apk add --no-cache \
    bash \
    su-exec

ENV ZOO_USER zookeeper
ENV ZOO_CONF_DIR /conf
ENV ZOO_DATA_DIR /data
ENV ZOO_DATA_LOG_DIR /datalog

# Add a user and make dirs
RUN set -x \
    &amp;&amp; adduser -D &quot;$ZOO_USER&quot; \
    &amp;&amp; mkdir -p &quot;$ZOO_DATA_LOG_DIR&quot; &quot;$ZOO_DATA_DIR&quot; &quot;$ZOO_CONF_DIR&quot; \
    &amp;&amp; chown &quot;$ZOO_USER:$ZOO_USER&quot; &quot;$ZOO_DATA_LOG_DIR&quot; &quot;$ZOO_DATA_DIR&quot; &quot;$ZOO_CONF_DIR&quot;

ARG GPG_KEY=C823E3E5B12AF29C67F81976F5CECB3CB5E9BD2D
ARG DISTRO_NAME=zookeeper-3.4.9

# Download Apache Zookeeper, verify its PGP signature, untar and clean up
RUN set -x \
    &amp;&amp; apk add --no-cache --virtual .build-deps \
        gnupg \
    &amp;&amp; wget -q &quot;http://www.apache.org/dist/zookeeper/$DISTRO_NAME/$DISTRO_NAME.tar.gz&quot; \
    &amp;&amp; wget -q &quot;http://www.apache.org/dist/zookeeper/$DISTRO_NAME/$DISTRO_NAME.tar.gz.asc&quot; \
    &amp;&amp; export GNUPGHOME=&quot;$(mktemp -d)&quot; \
    &amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-key &quot;$GPG_KEY&quot; \
    &amp;&amp; gpg --batch --verify &quot;$DISTRO_NAME.tar.gz.asc&quot; &quot;$DISTRO_NAME.tar.gz&quot; \
    &amp;&amp; tar -xzf &quot;$DISTRO_NAME.tar.gz&quot; \
    &amp;&amp; mv &quot;$DISTRO_NAME/conf/&quot;* &quot;$ZOO_CONF_DIR&quot; \
    &amp;&amp; rm -r &quot;$GNUPGHOME&quot; &quot;$DISTRO_NAME.tar.gz&quot; &quot;$DISTRO_NAME.tar.gz.asc&quot; \
    &amp;&amp; apk del .build-deps

WORKDIR $DISTRO_NAME
VOLUME [&quot;$ZOO_DATA_DIR&quot;, &quot;$ZOO_DATA_LOG_DIR&quot;]

ENV ZOO_PORT 2181
EXPOSE $ZOO_PORT

ENV PATH $PATH:/$DISTRO_NAME/bin
ENV ZOOCFGDIR $ZOO_CONF_DIR

COPY docker-entrypoint.sh /
ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]
CMD [&quot;zkServer.sh&quot;, &quot;start-foreground&quot;]
</code></pre><p>注意：这里依赖的镜像<code>oraclejdk8</code>请查看之前的文章“Docker学习系列五：构建oracle-jdk8镜像” </p>
<h4 id="依赖的docker-entrypoint-sh"><a href="#依赖的docker-entrypoint-sh" class="headerlink" title="依赖的docker-entrypoint.sh"></a>依赖的docker-entrypoint.sh</h4><pre><code>#!/bin/bash

set -e

# Allow the container to be started with `--user`
if [ &quot;$1&quot; = &apos;zkServer.sh&apos; -a &quot;$(id -u)&quot; = &apos;0&apos; ]; then
    exec su-exec &quot;$ZOO_USER&quot; &quot;$0&quot; &quot;$@&quot;
fi

# Generate the config only if it doesn&apos;t exist
if [ ! -f &quot;$ZOO_CONF_DIR/zoo.cfg&quot; ]; then
    CONFIG=&quot;$ZOO_CONF_DIR/zoo.cfg&quot;

    echo &quot;clientPort=$ZOO_PORT&quot; &gt;&gt; &quot;$CONFIG&quot;
    echo &quot;dataDir=$ZOO_DATA_DIR&quot; &gt;&gt; &quot;$CONFIG&quot;
    echo &quot;dataLogDir=$ZOO_DATA_LOG_DIR&quot; &gt;&gt; &quot;$CONFIG&quot;

    echo &apos;tickTime=2000&apos; &gt;&gt; &quot;$CONFIG&quot;
    echo &apos;initLimit=5&apos; &gt;&gt; &quot;$CONFIG&quot;
    echo &apos;syncLimit=2&apos; &gt;&gt; &quot;$CONFIG&quot;

    for server in $ZOO_SERVERS; do
        echo &quot;$server&quot; &gt;&gt; &quot;$CONFIG&quot;
    done
fi

# Write myid only if it doesn&apos;t exist
if [ ! -f &quot;$ZOO_DATA_DIR/myid&quot; ]; then
    echo &quot;${ZOO_MY_ID:-1}&quot; &gt; &quot;$ZOO_DATA_DIR/myid&quot;
fi

exec &quot;$@&quot;
</code></pre><p>设置docker-entrypoint.sh权限：</p>
<pre><code>chmod 755 docker-entrypoint.sh
</code></pre><h3 id="build镜像"><a href="#build镜像" class="headerlink" title="build镜像"></a>build镜像</h3><pre><code>docker build -t zookeeper:3.4.9 .
</code></pre><h3 id="测试镜像"><a href="#测试镜像" class="headerlink" title="测试镜像"></a>测试镜像</h3><h4 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h4><pre><code>docker run --name zookeeper --restart always -d zookeeper:3.4.9
</code></pre><blockquote>
<p>This image includes EXPOSE 2181 (the zookeeper port), so standard container linking will make it automatically available to the linked containers. Since the Zookeeper “fails fast” it’s better to always restart it.</p>
</blockquote>
<p>这个镜像内部开放了2181端口(zookeeper默认端口)，所有标准的容器链接会使之自动可用。然后因为Zookeeper是<code>fail fast</code>，所以最好总是能自动重启。</p>
<h4 id="从另一个应用容器链接到zookeeper容器"><a href="#从另一个应用容器链接到zookeeper容器" class="headerlink" title="从另一个应用容器链接到zookeeper容器"></a>从另一个应用容器链接到zookeeper容器</h4><pre><code>docker run --name some-app --link some-zookeeper:zookeeper -d application-that-uses-zookeeper
</code></pre><h4 id="从zookeeper命令行客户端链接到zookeeper容器"><a href="#从zookeeper命令行客户端链接到zookeeper容器" class="headerlink" title="从zookeeper命令行客户端链接到zookeeper容器"></a>从zookeeper命令行客户端链接到zookeeper容器</h4><pre><code>docker run -it --rm --link some-zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper
</code></pre><h4 id="集群模式启动zookeeper"><a href="#集群模式启动zookeeper" class="headerlink" title="集群模式启动zookeeper"></a>集群模式启动zookeeper</h4><p>docker-compose.yml:</p>
<pre><code>version: &apos;2&apos;
services:
    zoo1:
        image: zookeeper:3.4.9
        restart: always
        ports:
            - 2181
        environment:
            ZOO_MY_ID: 1
            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888

    zoo2:
        image: zookeeper:3.4.9
        restart: always
        ports:
            - 2181
        environment:
            ZOO_MY_ID: 2
            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888

    zoo3:
        image: zookeeper:3.4.9
        restart: always
        ports:
            - 2181
        environment:
            ZOO_MY_ID: 3
            ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888
</code></pre><p>启动集群：</p>
<pre><code>docker-compose up
</code></pre><p>查看集群状态（端口）：</p>
<pre><code>docker-compose ps  
</code></pre><p>这里需要注意：这里是伪集群。因为所有容器都启动在同一个物理主机中。实际应该是在不同的主机中启动zookeeper容器。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>zookeeper的配置在<code>/conf</code>目录下。如果需要修改配置，可以挂载本地配置文件。例如以下所示：</p>
<pre><code>docker run --name some-zookeeper --restart always -d -v $(pwd)/zoo.cfg:/conf/zoo.cfg zookeeper
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://zacard.net/2016/05/31/mybatis-batch-java8/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="zacard">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/88666.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Zacard's Notes">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Zacard's Notes" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/31/mybatis-batch-java8/" itemprop="url">
                  创造Lambda风格的mybatis批量操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-31T16:07:51+08:00">
                2016-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/软件技术/" itemprop="url" rel="index">
                    <span itemprop="name">软件技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/05/31/mybatis-batch-java8/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/31/mybatis-batch-java8/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="mybatis批量操作"><a href="#mybatis批量操作" class="headerlink" title="mybatis批量操作"></a>mybatis批量操作</h3><p>mybatis如何批量插入呢？常用的做法如下代码所示：</p>
<pre><code>// UserDao.java
/**
 * 批量插入
 */
int batchInsert(@Param(&quot;users&quot;) List&lt;User&gt; users);

// UserDao.xml
&lt;insert id=&quot;batchInsert&quot;&gt;
    INSERT INTO user (name,password) VALUES
    &lt;foreach collection=&quot;users&quot; item=&quot;user&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt;
        (#{user.name},#{user.password})
    &lt;/foreach&gt;
&lt;/insert&gt;
</code></pre><p>但是，这样有个影藏的bug：当user集合超过一定数量，会导致动态拼接的sql过长而导致执行报错。并且，批量更新就不能使用这种形式了。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/31/mybatis-batch-java8/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/88666.jpg"
               alt="zacard" />
          <p class="site-author-name" itemprop="name">zacard</p>
          <p class="site-description motion-element" itemprop="description">优生笑，菜鸟哭</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">65</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/mmaxiaolei" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/xiaoguodeshijie" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/za-qia" target="_blank" title="ZhiHu">
                  
                    <i class="fa fa-fw fa-zhihu"></i>
                  
                  ZhiHu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zacard</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zacard"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
