<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zacard&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zacard.net/"/>
  <updated>2021-01-19T14:28:25.149Z</updated>
  <id>https://zacard.net/</id>
  
  <author>
    <name>zacard</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LinkedBlockingQueue，我所忽略的并发安全细节</title>
    <link href="https://zacard.net/2021/01/19/java-linked-queue/"/>
    <id>https://zacard.net/2021/01/19/java-linked-queue/</id>
    <published>2021-01-19T13:30:54.000Z</published>
    <updated>2021-01-19T14:28:25.149Z</updated>
    
    <content type="html"><![CDATA[<p>首先抛出一个问题：</p><blockquote><p>LinkedBlockingQueue首尾2把锁是如何保证并发安全的？</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道，要保证共享变量的多线程并发读写安全需要用同一把锁。但是<code>LinkedBlockingQueue</code>有putLock和takeLock2把锁，是如何保证并发安全的呢？</p><p>先来看下LinkedBlockingQueue源码上的注释：</p><blockquote><p>A variant of the “two lock queue” algorithm</p></blockquote><p>“two lock queue” algorithm的一个变种。那什么是”two lock queue” algorithm呢？</p><a id="more"></a><h2 id="two-lock-queue-algorithm"><a href="#two-lock-queue-algorithm" class="headerlink" title="two lock queue algorithm"></a>two lock queue algorithm</h2><p>这其实是Maged M. Michael 和 Michael L. Scott在1996年发表的论文 <a href="https://www.cs.rochester.edu/research/synchronization/pseudocode/queues.html" target="_blank" rel="external">Simple, Fast, and Practical Non-Blocking and Blocking</a>描述的其中一种算法</p><p>为了提高并发队列的性能，他们提出了一种lock free的无锁算法（基于CAS）。但是在某些不支持CAS指令的机器上，他们同样提出了优化的算法，就是“two lock queue”算法</p><h3 id="为什么要用2把锁"><a href="#为什么要用2把锁" class="headerlink" title="为什么要用2把锁"></a>为什么要用2把锁</h3><p>如果用一把锁，不管是enqueue入队操作和dequeue出队操作，都需要获取这把唯一的排它锁。在高并发下容易引起激烈竞争导致性能下降。而我们分析下queue的2个主要操作：</p><ul><li>enqueue操作：总是在队列尾部插入节点</li><li>dequeue操作：总是在队列头部删除节点</li></ul><p>可以发现，enqueue和dequeue在大部分情况下都是相互独立的，并没有发生冲突，无需锁住整个队列。我们自然而然就能想到一个锁的常见优化方法：<strong>分段锁</strong>。所以队列用头尾2个锁可以大大降低冲突的概率</p><p>但是用2把锁在临界点会有些不太好处理的逻辑：</p><ul><li>在一个空队列入队一个节点</li><li>只剩最后一个节点的时候出队这个节点</li></ul><p>这2种情况都需要同时操作修改头尾指针，即需要同时获取<code>head lock</code>和<code>tail lock</code></p><p>危险的逻辑来了，同时获取多把锁非常容易造成死锁。即使我们小心翼翼的设计这块加锁/解锁顺序，这块代码逻辑就会出现多次加锁/解锁逻辑，性能反而可能会下降</p><p>论文的算法既然有个“simple”，我们看看论文的算法是如何处理的：</p><h3 id="并发分析"><a href="#并发分析" class="headerlink" title="并发分析"></a>并发分析</h3><p>伪代码（摘自论文）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">structure node_t &#123;value: data type, next: pointer to node_t&#125;</div><div class="line"> structure queue_t &#123;Head: pointer to node_t, Tail: pointer to node_t,</div><div class="line">                       H_lock: lock type, T_lock: lock type&#125;</div><div class="line"> </div><div class="line"> initialize(Q: pointer to queue_t)</div><div class="line">    node = new_node()<span class="comment">// Allocate a free node</span></div><div class="line">    node-&gt;next = NULL          <span class="comment">// Make it the only node in the linked list</span></div><div class="line">    Q-&gt;Head = Q-&gt;Tail = node<span class="comment">// Both Head and Tail point to it</span></div><div class="line">    Q-&gt;H_lock = Q-&gt;T_lock = FREE<span class="comment">// Locks are initially free</span></div><div class="line"> </div><div class="line"> enqueue(Q: pointer to queue_t, value: data type)</div><div class="line">    node = new_node()        <span class="comment">// Allocate a new node from the free list</span></div><div class="line">    node-&gt;value = value<span class="comment">// Copy enqueued value into node</span></div><div class="line">    node-&gt;next = NULL          <span class="comment">// Set next pointer of node to NULL</span></div><div class="line">    lock(&amp;Q-&gt;T_lock)<span class="comment">// Acquire T_lock in order to access Tail</span></div><div class="line">       Q-&gt;Tail-&gt;next = node<span class="comment">// Link node at the end of the linked list</span></div><div class="line">       Q-&gt;Tail = node<span class="comment">// Swing Tail to node</span></div><div class="line">    unlock(&amp;Q-&gt;T_lock)<span class="comment">// Release T_lock</span></div><div class="line"> </div><div class="line"> dequeue(Q: pointer to queue_t, pvalue: pointer to data type): <span class="function"><span class="keyword">boolean</span></span></div><div class="line">    <span class="title">lock</span><span class="params">(&amp;Q-&gt;H_lock)</span>        <span class="comment">// Acquire H_lock in order to access Head</span></div><div class="line">       node = Q-&gt;Head<span class="comment">// Read Head</span></div><div class="line">       new_head = node-&gt;next<span class="comment">// Read next pointer</span></div><div class="line">       <span class="keyword">if</span> new_head == NULL<span class="comment">// Is queue empty?</span></div><div class="line">          unlock(&amp;Q-&gt;H_lock)<span class="comment">// Release H_lock before return</span></div><div class="line">          <span class="keyword">return</span> FALSE<span class="comment">// Queue was empty</span></div><div class="line">       endif</div><div class="line">       *pvalue = new_head-&gt;value<span class="comment">// Queue not empty.  Read value before release</span></div><div class="line">       Q-&gt;Head = new_head<span class="comment">// Swing Head to next node</span></div><div class="line">    unlock(&amp;Q-&gt;H_lock)<span class="comment">// Release H_lock</span></div><div class="line">    free(node)<span class="comment">// Free node</span></div><div class="line">    <span class="keyword">return</span> TRUE<span class="comment">// Queue was not empty, dequeue succeeded</span></div></pre></td></tr></table></figure><p>可以看到：队列初始化的时候new了一个空节点，这样在首次入队的时候，队列就不再是空队列，无需修改head指针。在只剩最后一个元素的时候也不是只有一个节点，无需修改tail指针。巧妙的避开了同时修改头尾指针的情况</p><p>但是这里还是有个并发问题，假设以下执行顺序：</p><ul><li>线程A执行enqueue到第16行</li><li>线程B执行dequeue到第24行</li></ul><p>线程A在执行完16行的时候已经将首个元素节点入队了，然而线程B在执行24行的时候很有可能没法立即读到这个最新节点。因为2个线程使用不同锁保护，且没有用类似java中的volatile的手段来保证可见性</p><p>也就是说这个算法有个可见性问题：</p><blockquote><p>新入队的元素可能无法被立即读到而顺利出队</p></blockquote><p>这个问题挺明显的，作者不至于没有注意。网上搜索了下，看到有位博主对这段有解释：</p><blockquote><p>好在一般来讲next指针是32位数据，而现代的CPU已经能保证多线程程序中内存对齐了的32位数据<strong>读写操作的原子性</strong>，而一般来讲编译器会自动帮你对齐32位数据，所以这个不是问题</p></blockquote><p>这位博主的的意思应该是：对于节点指针的赋值是一个原子操作，所以其他线程能立即读到这次操作的最新值</p><p><strong>个人不认同这个解释</strong>，因为原子性（有关原子性/原子操作后面再专门讲下）并不代表可见性！一个原子操作只是代表这个操作是不可分割，不可中断，其他线程不会读到操作一半的值。最典型的例子：在32位多核机器读写long类型的值可能存在问题，因为写long操作是被拆分成<strong>写高32位和写低32位两部分</strong>的，不是一个原子操作了。然而即便是读写int这种32位数据，在没有voltail或者锁的保护下，也仍然无法做到可见性！</p><p><strong>个人看法</strong>：这个算法应该确实存在可见性问题。但是，出现的条件比较严苛，必须要队列为空的时候入队，同时有出队线程在读。然而即使出现这种情况，也只会使出队操作表现为无数据，并不影响queue的正确性：</p><ul><li>queue仍然表现为FIFO的特性，没有错乱</li><li>数据也不会丢失，只会延迟读取（出队）</li></ul><p>我们看下<code>LinkedBlockingQueue</code>是怎么处理这块的吧</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>先贴下<code>put()</code>和<code>take()</code>的源码（jdk-1.8）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// offer,即enqueue入队</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">if</span> (count.get() == capacity)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    putLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</div><div class="line">        <span class="comment">// 这里直接把enqueue这个私有方法内联进来方便分析</span></div><div class="line">        <span class="comment">// enqueue(node);</span></div><div class="line">        last = last.next = node;</div><div class="line">          </div><div class="line">            c = count.getAndIncrement();</div><div class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">                notFull.signal();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// poll,即dequeue出队</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    E x = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">// 这里直接把dequeue这个私有方法内联进来方便分析</span></div><div class="line">            <span class="comment">// x = dequeue();</span></div><div class="line">          Node&lt;E&gt; h = head;</div><div class="line">        Node&lt;E&gt; first = h.next;</div><div class="line">        h.next = h; <span class="comment">// help GC</span></div><div class="line">        head = first;</div><div class="line">        x = first.item;</div><div class="line">        first.item = <span class="keyword">null</span>;</div><div class="line">          </div><div class="line">            c = count.getAndDecrement();</div><div class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">                notEmpty.signal();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="并发分析-1"><a href="#并发分析-1" class="headerlink" title="并发分析"></a>并发分析</h3><p>逻辑和论文基本一致，所以看起来也有一样的<strong>可见性</strong>问题。请看以下执行序列：</p><ul><li>线程A执行到17行</li><li>线程B执行到43行</li></ul><p>在这个执行序列中，线程A本质上已经将节点入队了，且更新了队列容量。但是由于队列节点无法保证可见性，似乎也没法被线程B立即读到。如果真的是这样，第46行代码是很可能会报NullPointerException的，这肯定不是一个库会有的行为</p><p>回过头来再仔细看了一遍注释（源码第97行）和代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Visibility between writers and readers is provided as follows:</div><div class="line">     </div><div class="line">      Whenever an element is enqueued, the putLock is acquired and</div><div class="line">      count updated.  <span class="function">A subsequent reader guarantees visibility to the</span></div><div class="line">      enqueued Node by either acquiring the <span class="title">putLock</span> <span class="params">(via fullyLock)</span></div><div class="line">      or by acquiring the takeLock, and then reading n = count.get();</div><div class="line">      <span class="keyword">this</span> gives visibility to the first n items.</div></pre></td></tr></table></figure><p>其实<code>LinkedBlockingQueue</code>的注释中有专门对于可见性的解释说明：</p><blockquote><p>当一个元素入队，获取了<code>putLock</code>并且<code>count</code>更新后。随后的出队线程保证能读到最新入队的节点需要用以下2种的任意一种方法：</p><ul><li>方法一：出队线程用时获取<code>putLock</code>：这块大家都能理解，相当于获取2把锁，必然能保证可见性</li><li>方法二：获取<code>takeLock</code>后，执行<code>n = count.get()</code>即可保证可见性</li></ul></blockquote><p>之前对于方法二为什么能保证可见性一直没有想明白，为什么执行下<code>count.get()</code>就能保证节点的可见性。直到最近看到《深入Java虚拟机（第三版）》出了，突然想到volatile的语义（count是个AtomicInteger，对于AtomicInteger的读写本质上都是读写一个volatile变量）：</p><ol><li>保证被修饰的变量对所有线程的可见性</li><li>禁止指令重排序优化</li></ol><blockquote><p>附加规则：如果是写操作，会强制将本处理器的缓存写入了主内存，该写入动作也会引起别的处理器或者别的内核无效化(Invalidate)其缓存</p></blockquote><p>基于第2点语义可以得出：当线程1执行到17后，由于完成了volatile的写操作，将强制将缓存的修改写入主内存，因此对于入队节点的更新操作也会立即写入主内存，并且其他核的相关缓存会失效。因此到线程2执行到43行的时候必然能读到最新的值！</p><p>volatile的这个技巧的典型应该场景如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Properties config;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    config = readFromFile();</div><div class="line">    initialized = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>(!initialized)&#123;</div><div class="line">        sleep();</div><div class="line">    &#125;</div><div class="line">    doSomethingWithConfig();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>假设线程A执行<code>init()</code>后，线程B立即执行了<code>start()</code>。如果没有volatile的第2条语义保证，线程B执行第14行代码，使用的config很可能没有初始化好或者初始化好了，但是对线程B还不可见。这样很可能执行报错！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“two lock queue” 算法并没有保证线程可见性，而使queue的enqueue入队操作对dequeue出队立即可见，存在不可预知的延迟。然而基于此算法的<code>LinkedBlockingQueue</code>利用volatile的“禁止重排序”语义保证了可见性</p><p>举一反三一下，使用同样技巧的还有<code>FutureTask</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 源码第92行</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"></div><div class="line"><span class="comment">// 源码第104行</span></div><div class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></div></pre></td></tr></table></figure><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>学习到了：</p><blockquote><p>当使用volatile变量后，其他变量的修改要保证可见性其实已经无需额外使用volatile修饰，只需要在使用的时候优先读写这个volatile即可</p></blockquote><p>另外，看到大哥李（Doug Lea）的博客上说，<code>LinkedBlockingQueue</code>这段500行的代码写了将近1年。深深的感叹：</p><blockquote><p>并发编程从来都不是一件简单的事，性能优化的路上也没有终点</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先抛出一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LinkedBlockingQueue首尾2把锁是如何保证并发安全的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们知道，要保证共享变量的多线程并发读写安全需要用同一把锁。但是&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;有putLock和takeLock2把锁，是如何保证并发安全的呢？&lt;/p&gt;
&lt;p&gt;先来看下LinkedBlockingQueue源码上的注释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A variant of the “two lock queue” algorithm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“two lock queue” algorithm的一个变种。那什么是”two lock queue” algorithm呢？&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="并发" scheme="https://zacard.net/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="可见性" scheme="https://zacard.net/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>日志采集高可用之重试</title>
    <link href="https://zacard.net/2021/01/13/log-agent-backoff/"/>
    <id>https://zacard.net/2021/01/13/log-agent-backoff/</id>
    <published>2021-01-13T06:35:58.000Z</published>
    <updated>2021-01-13T06:38:09.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在开发自研日志平台的日志采集agent。这里记录下高可用设计的一些思考和技术细节。</p><p>当遇到发送到下游失败需要重试的场景。我们如何合理设计重试？如何优雅重试呢？</p><p>首先，我们需要明确重试的本质是什么？</p><h2 id="重试的本质"><a href="#重试的本质" class="headerlink" title="重试的本质"></a>重试的本质</h2><blockquote><p>重试的本质是我们认为这个故障是暂时的，而不是永久的，所以我们会去重试</p></blockquote><p>因此，我们需要清晰的定义什么情况下需要重试，什么情况下重试是没有意义的</p><a id="more"></a><h2 id="何时重试"><a href="#何时重试" class="headerlink" title="何时重试"></a>何时重试</h2><p>对于日志采集这个场景来说，为了保证<code>at least once</code>语义，大部分场景我们都需要无限重试。例如下游超时、限流，甚至宕机等。所以我们只需要定义出不需要重试的几种场景：</p><ul><li>未知错误：通常为下游代码bug。重试有限次数即丢弃（可配置记录到磁盘）</li><li>业务错误：例如格式错误（非法数据）。这种错误不管重试几次永远都是错误，没有重试的必要</li></ul><h2 id="如何重试"><a href="#如何重试" class="headerlink" title="如何重试"></a>如何重试</h2><p>通常重试会设置一个上界，例如最大重试次数、最大重试间隔</p><p>对于日志采集的场景，为了保证数据的可靠投递，上界选择最大重试间隔更合理。部分情况结合了最大重试次数（例如有限重试的场景：下游未知异常）</p><p>具体如何进行重试呢？常见的方式是每次重试失败时都会“休息”一段时间再重试，以避免一窝蜂的过快重试导致下游过大的负担和无谓的资源消耗</p><p>而常见的”重修-&gt;休息-&gt;重试”的算法叫做backoff退避算法。所以什么是backoff呢？</p><h3 id="backoff是什么"><a href="#backoff是什么" class="headerlink" title="backoff是什么"></a>backoff是什么</h3><p>这里用wiki中的<strong>Exponential backoff</strong>定义：</p><blockquote><p><strong>Exponential backoff</strong> is an <a href="https://en.wikipedia.org/wiki/Algorithm" target="_blank" rel="external">algorithm</a> that uses <a href="https://en.wikipedia.org/wiki/Feedback" target="_blank" rel="external">feedback</a> to multiplicatively decrease the rate of some process, in order to gradually find an acceptable rate</p></blockquote><p>简单来说：backoff退避算法就是一种利用反馈对某个过程的速率进行成倍的降低，以逐步找到一个可接受的速率的算法</p><p>从重试场景看，就是用某种算法，找到一个合理的重试时间，而不是所有异常请求都一窝蜂的直接去重试</p><h3 id="为什么要有backoff"><a href="#为什么要有backoff" class="headerlink" title="为什么要有backoff"></a>为什么要有backoff</h3><p>backoff使用场景是在网络中的节点发送数据发送冲突的时候，等待一定时间后再发，从而避免频繁的发生冲突。通常作为避免网络堵塞的一部分用于同一数据块的重发策略</p><p>想想一下这种场景，某个rpc服务的其中一个节点挂了，突然大规模的流量全部重试打到另一个节点，另一个节点很可能瞬间也被压垮。这也是一种“惊群效应”</p><p>另一个场景是，下游服务挂了，上游一直在重试直至下游服务恢复。如果没有backoff，上游全部无限循环重试，也是一种资源浪费</p><p>为了避免这些问题，我们希望发生异常的时候不是立即重试，而且等待一定时间后再重试</p><p>所以，大部分重试、重发等场景都会利用backoff算法来降低冲突和无谓的资源消耗</p><h3 id="backoff的原理"><a href="#backoff的原理" class="headerlink" title="backoff的原理"></a>backoff的原理</h3><p>backoff基本都需要设定最大重试次数或者最大间隔时间。因为无限次的重试往往没有意义，过长的间隔时间也不利于响应下游的恢复</p><p>backoff算法有以下几种常见实现方式：</p><h4 id="fixed-backoff"><a href="#fixed-backoff" class="headerlink" title="fixed backoff"></a>fixed backoff</h4><p>固定间隔时间的退避算法。每次重试都会间隔固定的<code>interval</code>时间</p><ul><li>优点：实现非常简单</li><li>缺点：<code>interval</code>不太好设定。设置的过小，下游长时间的故障可能造成大量资源浪费；设置的过大，对于偶现的网络抖动不能及时投递数据</li></ul><h4 id="random-backoff"><a href="#random-backoff" class="headerlink" title="random backoff"></a>random backoff</h4><p>给定一个重试等待的最大时间<code>maxInterval</code>，直接随机一个等待时间出来。范围是<code>[0,maxInterval)</code>，比较暴力</p><ul><li>优点：实现非常简单，较好的避免冲突</li><li>缺点也很明显：可能一次偶然的网络抖动，却等待了相当长一段时间才重试成功</li></ul><h4 id="fibonacci-backoff"><a href="#fibonacci-backoff" class="headerlink" title="fibonacci backoff"></a>fibonacci backoff</h4><p>基于fibonacci数列的退避算法。能较好的避免冲突，及时响应短暂的下游故障</p><p>核心算法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">next:=prev+prevPrev</div><div class="line">prevPrev = prev</div><div class="line">prev = next</div><div class="line"><span class="keyword">return</span> next</div></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">=== RUN   TestFibonacci_Next</div><div class="line"><span class="number">0</span>ms</div><div class="line"><span class="number">10</span>ms</div><div class="line"><span class="number">10</span>ms</div><div class="line"><span class="number">20</span>ms</div><div class="line"><span class="number">30</span>ms</div><div class="line"><span class="number">50</span>ms</div><div class="line"><span class="number">80</span>ms</div><div class="line"><span class="number">130</span>ms</div></pre></td></tr></table></figure><ul><li>优点：能够快速恢复数据投递。适合下游故障能够快速恢复或者故障率很低的情况</li><li>缺点：对于下游较长时间的故障，比较浪费资源</li></ul><h4 id="exponential-backoff"><a href="#exponential-backoff" class="headerlink" title="exponential backoff"></a>exponential backoff</h4><p>指数退避算法。也就是每次重试的间隔时间都是指数增长的。那为什么是指数增长呢？</p><p>可以从指数分布来看：</p><blockquote><p>指数分布是独立事件的时间间隔的概率分布</p></blockquote><p>指数分布满足下图：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/backoff/zsfb.png" alt=""></p><p>可以看到，随着间隔时间变长，事件的发生概率急剧下降，呈指数式衰减</p><p>所以，指数退避算法随着重试次数的增加，时间间隔变长，发生冲突的概率是非常低的。因此很适合作为backoff的一种实现算法</p><p>核心代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">next := <span class="keyword">float64</span>(minInterval) * math.Pow(factor, attempts)</div></pre></td></tr></table></figure><p><code>minInterval</code>: 表示初始的时间间隔。例如10ms</p><p><code>factor</code>: 表示指数因子。例如2</p><p><code>attempts</code>: 表示重试的次数</p><p>输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">=== RUN   TestExponential_Next</div><div class="line"><span class="number">10</span>ms</div><div class="line"><span class="number">20</span>ms</div><div class="line"><span class="number">40</span>ms</div><div class="line"><span class="number">80</span>ms</div><div class="line"><span class="number">160</span>ms</div><div class="line"><span class="number">320</span>ms</div><div class="line"><span class="number">640</span>ms</div><div class="line"><span class="number">1280</span>ms</div><div class="line">...</div></pre></td></tr></table></figure><ul><li>优点：实现比较简单。同时冲突的概率也很低，在重试初期可以在相对比较短的时间内完成。对于服务宕机时间较长的情况，也可以在一个稳定的长时段内重试，不会空耗系统资源</li><li>缺点：当大部分节点恰好都在同一个时间点发生异常，那由于每次重试的间隔时间都是一致的会导致容易发生冲突</li></ul><h4 id="exponential-jitter-backoff"><a href="#exponential-jitter-backoff" class="headerlink" title="exponential jitter backoff"></a>exponential jitter backoff</h4><p>指数抖动退避算法，就是<strong>弥补指数退避算法的缺点</strong>。每次计算出下一次重试的间隔时间的时候加上一定的随机抖动时间，使同一时间需要重试的请求错开</p><p>核心代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">next := <span class="keyword">float64</span>(minInterval) * math.Pow(factor, attempts)</div><div class="line"><span class="keyword">if</span> jitterFactor &gt; <span class="number">0</span> &#123;</div><div class="line">j := jitterFactor * next</div><div class="line">min := next - j</div><div class="line">max := next + j</div><div class="line">next = min + rand.Float64()*(max-min+<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>minInterval</code>: 表示初始的时间间隔。例如10ms</p><p><code>factor</code>: 表示指数因子。例如2</p><p><code>attempts</code>: 表示重试的次数</p><p><code>jitterFactor</code>: 表示抖动的因子。例如0.5</p><p>输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">=== RUN   TestExponential_NextWithJitter</div><div class="line"><span class="number">11</span>ms</div><div class="line"><span class="number">28</span>ms</div><div class="line"><span class="number">46</span>ms</div><div class="line"><span class="number">75</span>ms</div><div class="line"><span class="number">147</span>ms</div><div class="line"><span class="number">379</span>ms</div><div class="line"><span class="number">362</span>ms</div><div class="line"><span class="number">840</span>ms</div></pre></td></tr></table></figure><p>自己用go实现了<code>exponential jitter backoff</code>：<a href="https://github.com/mmaxiaolei/backoff" target="_blank" rel="external">传送门</a></p><p>欢迎大家使用和反馈</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解了重试的本质后，我们只需要根据特定场景选择合适的重试backoff算法即可。backoff的实现有很多，大部分场景<code>exponential jitter backoff</code>都能胜任</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在开发自研日志平台的日志采集agent。这里记录下高可用设计的一些思考和技术细节。&lt;/p&gt;
&lt;p&gt;当遇到发送到下游失败需要重试的场景。我们如何合理设计重试？如何优雅重试呢？&lt;/p&gt;
&lt;p&gt;首先，我们需要明确重试的本质是什么？&lt;/p&gt;
&lt;h2 id=&quot;重试的本质&quot;&gt;&lt;a href=&quot;#重试的本质&quot; class=&quot;headerlink&quot; title=&quot;重试的本质&quot;&gt;&lt;/a&gt;重试的本质&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;重试的本质是我们认为这个故障是暂时的，而不是永久的，所以我们会去重试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，我们需要清晰的定义什么情况下需要重试，什么情况下重试是没有意义的&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="日志采集" scheme="https://zacard.net/tags/%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86/"/>
    
      <category term="agent" scheme="https://zacard.net/tags/agent/"/>
    
      <category term="backoff" scheme="https://zacard.net/tags/backoff/"/>
    
  </entry>
  
  <entry>
    <title>日志收集Agent，阴暗潮湿的地底世界</title>
    <link href="https://zacard.net/2019/06/15/log-agent/"/>
    <id>https://zacard.net/2019/06/15/log-agent/</id>
    <published>2019-06-15T04:31:05.000Z</published>
    <updated>2021-01-19T13:29:21.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分享我参与严选技术工作组的日志平台项目中的时候，在日志收集agent这块遇到的一些问题，深入到每个底层细节和大家谈谈。</p></blockquote><p>日志agent对于使用日志平台的用户来说，是一个黑盒。对于用户来说，agent有些不好的地方：</p><ul><li>agent私底下偷偷摸摸都做了些什么事情呢？（阴暗的）</li><li>agent的设计实现其实有一些dirty、creepy的地方（潮湿的）</li></ul><p>所以我觉得日志收集agent对大家来说是一个阴暗潮湿的地底世界:</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/log-agent/creepy1.jpeg" alt=""></p><p>就让我举起火把，照亮所有dark、dirty、creepy的地方。</p><a id="more"></a><h2 id="背景提要"><a href="#背景提要" class="headerlink" title="背景提要"></a>背景提要</h2><p>日志收集我们知道是在<strong>宿主服务器</strong>通过一个agent来收集日志数据，并且将收集到的数据源源不断的发送到日志平台的下游链路消费。</p><p>正是因为日志收集agent是整个日志平台的唯一数据来源，所以日志收集的地位非常重要。一旦日志收集agent出现问题，轻则影响后续链路的报警和查询，重则影响宿主服务器，反客为主，影响更为重要的应用系统。</p><p>所以，先来看看我们选型agent的时候有些什么阴暗的地方:</p><h2 id="日志收集agent方案"><a href="#日志收集agent方案" class="headerlink" title="日志收集agent方案"></a>日志收集agent方案</h2><p>由于日志收集agent的特殊性，我们对于agent的要求优先级由高到低如下:</p><p>低耗&gt;稳定&gt;高效&gt;轻量</p><p>以此原则，我们逐步推动agent的演进。</p><h3 id="日志收集agent初期方案"><a href="#日志收集agent初期方案" class="headerlink" title="日志收集agent初期方案"></a>日志收集agent初期方案</h3><p>其实日志平台一开始并没有对比太多其他的agent方案，直接就是使用的flume作为agent。</p><p>why？</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/log-agent/mvp-product.jpg" alt=""></p><p>基于MVP(minimum viable product)原则，日志平台第一版的选项更看重能快速上线、快速试错、快速验证。而且严选这边其实之前就存在一套日志收集系统是用的flume，我们决定先复用flume，再对其定制。然后其实还有一个更重要的原因：为了兼容一些历史问题（例如收集的日志要写到北京kafka的情况），我一开始不得不沿用flume作为agent的方案。</p><p>then?</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/log-agent/no-move.jpeg" alt=""></p><p>以为我们agent就此受困于历史的漩涡中束手束脚，止步不前？不存在的，我们同步调研了filebeat的方案。来看看我们对filebeat的调研工作：</p><h3 id="filebeat作为日志收集agent"><a href="#filebeat作为日志收集agent" class="headerlink" title="filebeat作为日志收集agent"></a>filebeat作为日志收集agent</h3><p>先来看下2者之间的对比：</p><table><thead><tr><th></th><th>filebeat</th><th>flume</th></tr></thead><tbody><tr><td>语言</td><td>go</td><td>java</td></tr><tr><td>包大小</td><td>&lt;10m</td><td>&gt;68m</td></tr><tr><td>额外依赖</td><td>无</td><td>根据source与sink的不同可能需要额外的依赖包</td></tr><tr><td>配置复杂度</td><td>中</td><td>较高</td></tr><tr><td>性能</td><td>高</td><td>低</td></tr><tr><td>资源占用</td><td>低</td><td>高</td></tr><tr><td>扩展性</td><td>低</td><td>高</td></tr><tr><td>可靠性</td><td>高(at-least-once)</td><td>高(at-least-once)</td></tr><tr><td>限流</td><td>自带，背压敏感协议</td><td>自定义开发扩展的一个Interceptor</td></tr><tr><td>负载均衡</td><td>内置</td><td>内置</td></tr><tr><td>输入源</td><td>内置了几个</td><td>支持多样的输入源，方便的自定义扩展输入源</td></tr><tr><td>输出源</td><td>内置了几个</td><td>内置比较丰富，方便的扩展</td></tr></tbody></table><p>权衡优劣后，我更倾向于选择<strong>filebeat</strong>作为日志收集的agent，原因如下：</p><ol><li>我们对于agent的需求是低耗、稳定、高效、轻量。扩展性显得并不那么重要，功能丰富与稳定性，我更倾向于后者</li><li>对于输入源，我们的场景也正好只是基于文件的日志数据收集，filebeat已经满足我们的需求场景</li><li>对于输出源，filebeat需要定制开发，支持http/grpc，有一定开发成本，但是完全可以接受</li><li>目前flume-agent的方案，日志切分是在flink任务中，导致后续架构链路冗长。使用filebeat完全可以把切分的工作放在agent端来简化架构链路，这对于后续日志平台的运维也大有裨益</li></ol><p>同时，我们做了filebeat的压测，压测数据如下：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/log-agent/%E6%97%A0%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%981.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/log-agent/%E6%97%A0%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%982.jpg" alt=""></p><p>其结果让我们震惊，在内存占用很低的情况下(3%以下)，最高cpu占用只有70%，flume（平均145%）的一半不到。这使我们以后的agent方案逐渐向filebeat倾斜。</p><p>好了，是时候来点干货了，我们来看看日志收集都有哪些问题？哪些creepy的设计？</p><h2 id="如何发现日志文件"><a href="#如何发现日志文件" class="headerlink" title="如何发现日志文件"></a>如何发现日志文件</h2><p>agent如何发现哪些日志文件是要被收集的呢？主要有如下几种方式：</p><ul><li>用户配置<ul><li>优点：简单高效。用户直接把需要采集的日志文件给配进来，可以说是最简单高效的办法。</li><li>缺点：日志文件很可能是会按天<strong>滚动</strong>(rotate)的，提前配置肯定覆盖不了后面新创建的日志文件。</li></ul></li><li>正则匹配(例如：<code>access_log\.\d{4}-\d{2}-\d{2}\.\d{2}</code>)<ul><li>优点：灵活。能够很好的覆盖到各种滚动新建的日志文件</li><li>缺点：正则由用户输入，效率堪忧，一旦发生大量回溯，很可能cpu100%。这也是我们最不希望发生在agent端的问题</li></ul></li><li>占位符匹配(例如：<code>access_log.yyyy-MM-dd.log</code>)<ul><li>优点：灵活高效。即能很好的匹配新创建的日志文件，agent端的匹配效率也非常高</li><li>缺点：对于一些奇葩命名滚动规则的日志文件不太好适应</li></ul></li></ul><p>日志平台使用的是占位符匹配的方式，但是后端其实是兼容正则匹配的，这是出于兼容历史的原因，后面将逐步去掉正则的匹配的方式。</p><p>解决了如何发现文件后，紧接着就会遇到另一个问题：</p><h2 id="如何发现新创建的文件"><a href="#如何发现新创建的文件" class="headerlink" title="如何发现新创建的文件"></a>如何发现新创建的文件</h2><p>直觉做法肯定是轮询目录中的日志文件，显然这不是个完美的方案。因为轮询的周期太长会导致不够实时，太短又会耗CPU。</p><blockquote><p>这真是一个艰难的trade-off</p></blockquote><p>我们来对比下flume（<strong>以下所说的flume都是我们基于flume改造定制的yanxuan-flume</strong>）和filebeat的做法：</p><ul><li><p>yanxuan-flume：轮询</p><p>flume目前是每隔500ms去轮询查找是否有新的日志文件，基本上就我们前面提到的”直觉做法”。实现简单，但是我们很难衡量这个<code>500ms</code>是否是一个合适合理的值。</p></li><li><p>fliebeat：OS内核指令+轮询</p><p>filebeat的方案就完善优雅很多。依赖OS内核提供的高效指令，分别是：</p><ul><li>linux：inotify</li><li>macos：fsevents</li><li>windows：ReadDirectoryChangesW</li></ul><p>来通知是否有新文件，并且辅助一个周期相对较长的轮询来避免内核指令的bug(具体参考其<a href="[http://man7.org/linux/man-pages/man7/inotify.7.html](http://man7.org/linux/man-pages/man7/inotify.7.html">man page</a>))，取长补短，低耗与高效兼得</p></li></ul><blockquote><p>又多了一个使用filebeat的理由</p></blockquote><p>好了，现在我们已经清楚如何发现文件了，那么问题又来了，<strong>我们如何知道这个文件是否已经收集过了？如果没有收集完，应该从什么位置开始接着收集？</strong></p><h2 id="如何标识一个日志文件收集的位置"><a href="#如何标识一个日志文件收集的位置" class="headerlink" title="如何标识一个日志文件收集的位置"></a>如何标识一个日志文件收集的位置</h2><p>一般是用一个文件（这里我们称之为<strong>点位文件</strong>）来记录收集的<strong>文件名</strong>（包含文件路径）与<strong>收集位置</strong>（偏移量）的对应关系，key就是文件名称，value就是偏移量。记录到文件的好处是，在机器宕掉后修复，我们还能从文件中恢复出上次采集的位置来继续收集。如下图所示：</p><p>那么，点位文件存在什么问题呢？点位文件使用日志文件名称作为key，但是一个日志文件的名称是有可能被更改的，当文件被改名后，由于点位文件中查询不到对应的采集位置，agent会认为是一个全新的日志文件而重头重新收集。所以用文件名称不能识别一个文件。那么问题又来了：</p><h2 id="如何识别一个文件"><a href="#如何识别一个文件" class="headerlink" title="如何识别一个文件"></a>如何识别一个文件</h2><p>如何识别一个文件，最简单的就是根据文件路径+文件名称。但是我们上面说了，文件很可能被改名。每个文件其实都有个inode属性（可以使用命令<code>stat test.log</code>查看），这个inode由OS保证同一个device下inode唯一。所以自然而然的我们就会想到用device+inode来唯一确定一个文件。然而inode是会重新分配的，即当我们删除一个文件后，其inode是会被重复利用，分配给新创建的文件。</p><p>举个常见例子：假如日志文件配置为保留30天，那30天以前的日志文件是会被自动删除的。当删除30天前的日志文件，其inode正好分配给当天新创建的日志文件，那当天的日志是不会被收集的，因为在点位文件中记录了其采集偏移量。</p><p>我们来看看flume和filebeat是怎么做的：</p><ul><li><p>yanxuan-flume：device+inode+首行内容MD5</p><ul><li><p>优点：无需用户干预，能保证唯一识别一个文件</p></li><li><p>缺点：需要打开文件读取文件内容，而且首行内容MD5还是太暴力了，因为首行很可能是一个超长日志，再加上MD5，不仅耗CPU，而且判断效率有点低。</p><blockquote><p>可以考虑读取首行N个字节的内容md5，但是N到底取多大呢? 越大相同的概率越小，效率越低。反过来，N越小重复的概率越大，效率越高。这又是一个艰难的trade-off啊</p></blockquote></li></ul></li><li><p>filebeat：device+inode</p><ul><li><p>优点：判断效率高。无需打开文件读取内容即可判断</p></li><li><p>缺点：可能会误判</p><blockquote><p>filebeat提供了一个配置选项来决定何时删除点位文件中的记录：<code>clean_inactive:72h</code>表示清除72h不活跃的文件对应的点位文件中的记录。基本上我们的文件都是每天（24h）滚动（rotated）的，那前一天的日志文件是不会写入的，所以设置<code>clean_inactive:72h</code>是合理的。</p><p>那为什么不在日志文件被删除后直接删除点位文件中对应的记录呢？因为假如我们的日志文件在一个共享的存储分区中，当这个分区消失了一会(接触不良等情况)又重新出现后，里面的所有日志文件都会重头开始重新收集，因为他们的收集状态已经从点位文件中删除了。</p><p>我觉得这是一个合理的”甩锅”给使用者的配置选项。</p></blockquote></li></ul></li></ul><p>解决了如何标识文件，如何标识采集状态，那如何判断一个日志文件采集完了呢？采集到末尾返回EOF的时候就算采集完了，可是当采集速度大于日志生产速度的时候，很可能我们采集到末尾返回EOF后，又有新的内容写入。所以，问题就变成：</p><h2 id="如何知道文件内容更新了"><a href="#如何知道文件内容更新了" class="headerlink" title="如何知道文件内容更新了"></a>如何知道文件内容更新了</h2><p>最简单通用的方案就是轮询要采集的文件，发现文件内容有更新就采集，采集完成后再触发下一次的轮询，既简单又通用。</p><p>那具体是轮询什么呢？</p><ul><li>yanxuan-flume：按照文件的修改时间排序，轮询文件内容，尝试收集，如果返回是EOF则继续下一份文件</li><li>filebeat：按照文件的修改时间排序，轮询文件的stat状态，修改时间大于点位文件中记录的时间，则打开文件收集，返回EOF则继续下一份文件</li></ul><p>相比flume，filebeat又做了一个小优化，每次不会直接就打开文件，而是先比较文件的修改时间再决定是否打开文件进行收集。</p><blockquote><p>不得不感叹，魔鬼在细节！低耗和高效如何兼得，filebeat处处都是细节</p></blockquote><p>好了，知道该什么时候收集了，那我们具体收集的时候会遇到什么问题呢？</p><h2 id="如何收集多行日志"><a href="#如何收集多行日志" class="headerlink" title="如何收集多行日志"></a>如何收集多行日志</h2><p>目前的agent默认都是单行收集的，即遇到换行符就认为是一条全新的日志。可是很多情况下，我们的一条日志是多行的，比如异常堆栈、格式化后的sql&amp;json等。</p><p>那如何判断那几行是属于同一条日志呢？</p><ul><li><p>yanxuan-flume：flume原生是不支持的，我们自己写了个插件，通过配置一条日志的开头字符S来判断。假如一行日志的开头不是S，则认为是和上一行属于同一条日志</p></li><li><p>filebeat：支持flume类似的方式，同时提供了配置项<code>negate</code>：true 或 false；默认是false，匹配开头字符S的行合并到上一行；true，不匹配S的行合并到上一行。能够覆盖更多的多行日志场景。</p><blockquote><p>当然还有其他相关配置来兜底合并行可能带来的问题，例如一次最多合并几行和合并行的超时时间来防止可能的<strong>内存溢出与卡死</strong></p></blockquote></li></ul><p>万无一失了吗？想想多行日志的最后一行按照以上的逻辑可以正常收集吗？例如下图所示：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/log-agent/muri-log.jpg" alt=""></p><h2 id="如何处理多行日志的最后一行"><a href="#如何处理多行日志的最后一行" class="headerlink" title="如何处理多行日志的最后一行"></a>如何处理多行日志的最后一行</h2><p>当多行日志收集遇到最后一行怎么收集呢？还是来比较下flume和filebeat的做法：</p><ul><li>yanxuan-flume：遇到EOF即认为是这条多行日志收集完了。这有个问题就是，很可能这条多行日志还没有写完，就被收集发送出去了。而且当收集速度大于日志写入速度的时候或者异步打印日志的时候，又很容易发生这种情况</li><li>filebeat：遇到EOF会回退之前读取的内容，然后一直持有这个文件句柄（直到超时），直到新一行日志写入，根据新一行日志的行首字符匹配来判断是否当前行的日志结束。所以filebeat的存在的问题是很可能最后一行永远不会被收集</li></ul><blockquote><p>目前业界貌似没有太好的办法来完美解决这个问题。个人觉得基于filebeat的多行合并的超时时间配置选项能够很大程度缓解这个问题，因为多行日志往往也是一次性写入的，超过一定时间写入的往往都是一条全新的日志。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;分享我参与严选技术工作组的日志平台项目中的时候，在日志收集agent这块遇到的一些问题，深入到每个底层细节和大家谈谈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日志agent对于使用日志平台的用户来说，是一个黑盒。对于用户来说，agent有些不好的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;agent私底下偷偷摸摸都做了些什么事情呢？（阴暗的）&lt;/li&gt;
&lt;li&gt;agent的设计实现其实有一些dirty、creepy的地方（潮湿的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我觉得日志收集agent对大家来说是一个阴暗潮湿的地底世界:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/log-agent/creepy1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;就让我举起火把，照亮所有dark、dirty、creepy的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="agent" scheme="https://zacard.net/tags/agent/"/>
    
      <category term="日志收集" scheme="https://zacard.net/tags/%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>程序员的自我修养</title>
    <link href="https://zacard.net/2019/04/04/dqc-think/"/>
    <id>https://zacard.net/2019/04/04/dqc-think/</id>
    <published>2019-04-04T02:51:13.000Z</published>
    <updated>2019-06-15T03:54:06.896Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>程序员的自我修养</p></blockquote><p>这里主要和大家分享我在开发DQC（数据质量中心）的过程中，对产品需求、架构设计、编码、自我提升这4个环节的反思与经验。</p><h2 id="产品需求"><a href="#产品需求" class="headerlink" title="产品需求"></a>产品需求</h2><blockquote><p>产品需求阶段，我们能做什么，该做些什么？</p></blockquote><p>我认为有2点很重要:</p><ul><li>沟通：高效沟通，可以减少歧义，加快开发</li><li>参与：参与其中，可以减少返工，保持扩展</li></ul><p>那如何做到这2点呢？我认为有个非常重要的概念：领域通用语言</p><a id="more"></a><h3 id="领域通用语言"><a href="#领域通用语言" class="headerlink" title="领域通用语言"></a>领域通用语言</h3><p>领域通用语言(Ubiquitous Language)，其实是DDD(Domain-Driven Design，领域驱动设计)中一个非常重要的概念。但是我认为他适用于每个项目的开发流程。</p><ol><li>什么叫领域通用语言：领域（业务）专家、产品经理、开发、一个团队中的所有人使用的一种公共语言，能够准确表达领域结构的术语</li><li>为什么要用领域通用语言<ul><li>降低沟通成本：一个团队中的所有人，使用同一种语言，中间没有翻译的过程，也不会产生歧义</li><li>提升沟通效率：产品、开发、测试使用同一种语言。产品提需求开发能够准确的明白其意图；测试反馈bug，开发能做准确得知异常模块</li><li>加速开发：清晰定义好领域通用语言，也为之后的程序设计也定义了一个清晰的概念(领域模型)</li></ul></li><li>如何定义领域通用语言<ol><li>提炼领域专家的术语：合适的领域术语也将降低系统的使用门槛</li><li>团队成员共同确认：一个团队，一种语言</li><li>领域专家认可：领域专家都无法理解的语言肯定有问题</li></ol></li></ol><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><blockquote><p>架构设计阶段，我们应该遵循什么原则，应该注意什么？</p></blockquote><p>我认为有一个原则：<strong>升维思考，降维攻击</strong></p><h3 id="升维思考，降维攻击"><a href="#升维思考，降维攻击" class="headerlink" title="升维思考，降维攻击"></a>升维思考，降维攻击</h3><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img//dqc-think/%E5%8D%87%E7%BB%B4%E6%80%9D%E8%80%83.jpg" alt=""></p><p>之前网上看过一句话：</p><blockquote><p>你所解决问题的复杂度决定了你技术的高度</p></blockquote><p>抛开业务逻辑自身的复杂度，我认为维度越高，复杂度必然也越高。所以我们要在更高的维度思考，才能得到更大的技术挑战和更快的技术成长。</p><h3 id="何为高维-amp-低维"><a href="#何为高维-amp-低维" class="headerlink" title="何为高维&amp;低维"></a>何为高维&amp;低维</h3><p>我认为的高维-&gt;低维：跨部门-&gt;跨项目-&gt;跨节点-&gt;跨线(进)程</p><p>想想我们做的技术方案、公共服务、基础类库等，能否做到跨线程、跨节点、跨项目甚至跨部门使用呢？</p><h3 id="如何升维思考"><a href="#如何升维思考" class="headerlink" title="如何升维思考"></a>如何升维思考</h3><p>先和大家分享一张图:</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img//dqc-think/4w3w.jpeg" alt=""></p><p>上图表达的其实是一个4维人看3维人下楼梯。我们可以看到，4维人可以看到3维人下楼梯的全过程。所以我想说的是，我们在更高的维度，可以看到更全面的信息，看到更多的问题。</p><p>如何升维思考，我认为要做好2点：</p><ul><li><p>总是递归的在更高维度思考</p><p>例如，写了一段代码，要想想，在跨线程维度，会不会有什么问题？有没有更好的方案适应多线程环境？完了之后再想想在跨节点这个维度是否会有什么问题？有没有适应跨节点维度的更好方案？以此类推…</p></li><li><p>保持对问题的饥渴和敏感</p><p>例如，popo群里的产品或者前端提的问题我往往第一时间去排查，然后总是想，为什么会出现这样的问题？我能否通过技术手段或者架构设计来屏蔽此类问题？</p></li></ul><h3 id="什么是降维攻击"><a href="#什么是降维攻击" class="headerlink" title="什么是降维攻击"></a>什么是降维攻击</h3><p>降维攻击这个词出自《三体》，看过《三体》的同学肯定知道。其大体流程为:</p><blockquote><p>（歌者文明）先把自己改造为低维度生物，而后发动降维打击，投掷“二向箔”使得目标空间的一个维度无限蜷缩，这样，原先的那些同维度的生物，就都被无限压缩挂掉……</p></blockquote><p>例如如下图降维攻击地球：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img//dqc-think/%E9%99%8D%E7%BB%B4%E6%89%93%E5%87%BB.jpeg" alt=""></p><p>使用<strong>二向箔</strong>，无限压缩地球，导致地球上的生物都被压成纸片挂掉。</p><p>所以，我总结降维攻击的步骤，如下：</p><ol><li>改造自己</li><li>创造某种有利条件</li><li>发起攻击</li></ol><p>再举个通俗例子:</p><ol><li>一个习武之人，<strong>戴着眼罩</strong>每天苦练听声辨位，终成一位”盲人”武学高手</li><li>将整个武林都带到一个伸手不见五指的小山洞里</li><li>在黑暗中轻松击败所有人</li></ol><blockquote><p>题外话: 这个例子改编自一个网友写的，原文是习武之人戳瞎自己的双眼再苦练，我觉的实在太蠢了，改成戴着眼罩苦练。其实一直不太明白武侠小说中练某种武功为什么会动不动就要自残，比如《xxx宝典》</p></blockquote><p>大家应该都知道，这个例子其实就是《笑傲江湖》里面思过崖的桥段。</p><p>所以，降维打击<strong>最关键</strong>的一步就是<strong>别人凭什么愿意跟你进伸手不见五指的小山洞呢？</strong></p><p>《笑傲江湖》中的做法是：让别人主动进“<strong>小山洞</strong>”！告诉整个武林，思过崖里面有各大门派的失传武功秘籍，让大家免费参观。</p><p>那我们技术如何降维攻击呢？</p><h3 id="技术如何降维攻击"><a href="#技术如何降维攻击" class="headerlink" title="技术如何降维攻击"></a>技术如何降维攻击</h3><p><strong>KISS（Keep It Simple &amp; Stupid）原则</strong> - 好用方便，这才是我们技术方案的<strong>二向箔</strong>。其优点如下：</p><ul><li>接入便捷：接入只需引入jar-&gt;提供少许配置项-&gt;代码有侵入 (接入是否便捷决定了迁移成本)</li><li>侵入低：无侵入-&gt;低侵入-&gt;高侵入 (是否有侵入决定了修改成本)</li><li>适用度高：适应多个维度，多种语言 (适应度高低决定了受众程度，kpi)</li></ul><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>coding的艺术</p><h3 id="认知负载"><a href="#认知负载" class="headerlink" title="认知负载"></a>认知负载</h3><p>这里指的是理解你写的代码所需要的思维量。</p><p>你写的代码逻辑越清晰，越简洁，理解起来就越容易。</p><p>常见错误:</p><ul><li>主流程中一堆的get/set。一屏代码可能也就30，40行，结果你一堆get/set占用了20行，不仅代码丑陋，理解起来也相当费劲，这时候特别适合在实体类中出一个<strong>静态工厂模式</strong>来生成你想要的实体对象</li><li>命名混乱。代码尽量要能自解释，命名尤为关键。那如何命名呢？有个相对通用的原则:<strong>释义命名选择器</strong>，什么意思呢，就是在命名的时候，要<strong>描述他们的效果和目的</strong>，而不需要表露他们是通过何种方式达到目的</li></ul><h3 id="做个调包侠"><a href="#做个调包侠" class="headerlink" title="做个调包侠"></a>做个调包侠</h3><p>何谓”调包侠”？就是直接使用开源的jar包，而不用自己写相关的代码逻辑。这样有如下好处：</p><ul><li>充分测试：开源代码通常经过严格测试，我们可以省略很大一部分的测试时间</li><li>该有的坑，别人都踩过了：我们可以相对正确的使用这个jar包</li><li>设计优雅：通常来说，开源代码设计都比较优雅，使用方便</li><li><p>社区支持良好：遇到问题，可以得到社区的支持</p><p>所以，做个调包侠，轻松又愉快，高效不费劲，何乐不为呢？</p></li></ul><h3 id="测试友好"><a href="#测试友好" class="headerlink" title="测试友好"></a>测试友好</h3><p>我们这边的测开比其实非常低，一度达到了1：5。所以，QA同学很辛苦，我们要对他们好一点。</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img//dqc-think/%E5%90%88%E4%BD%9C%E6%84%89%E5%BF%AB.jpg" alt=""></p><p>如何编写对测试友好的代码呢？我觉得要关注以下2点：</p><ul><li>职责单一：职责单一的类/方法，测试目的是明确的。反例就是一堆if/else，不仅代码臃肿，测试也非常不友好</li><li>抽象与封装：需要QA测试的，抽象出来（例如主业务逻辑的某个功能，用接口明确定义出来）；不需要QA测试的，封装起来（例如一堆get/set操作，封装到实体内部。给他们点空间，不要什么隐私都暴露给他们，好吧）</li></ul><h2 id="自我提升"><a href="#自我提升" class="headerlink" title="自我提升"></a>自我提升</h2><blockquote><p>技术道路，如何“打怪”升级？</p></blockquote><h3 id="享受coding"><a href="#享受coding" class="headerlink" title="享受coding"></a>享受coding</h3><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img//dqc-think/%E7%96%AF%E7%8B%82coding.gif" alt=""></p><p>我经常看到开发在码代码的时候，表情狰狞。其实我在写代码的时候是非常乐在其中的。我总是想着我要设计一段多么牛逼，多么优雅的代码，用上xxx算法，不仅高效而且简洁易懂，高度可扩展。秀出强劲的coding能力、设计能力、架构能力…</p><blockquote><p>秀，就完事了</p></blockquote><p>那我们如何才能享受其中呢？我觉得要有如下2点：</p><ul><li>成就感：有成就感才能享受coding</li><li>认同感：有认同感才能保持coding的激情</li></ul><p>具体怎么去做呢？</p><ul><li>精细设计：用上xxx算法，xxx设计模式；架构风骚，代码犀利</li><li>回头重构：隔一整子，回头看总会觉得有些地方写的跟坨屎一样……继续重构优化</li></ul><p>这是一个良性的过程。不仅能不断提高我们的技术能力，还能保持代码的活性，不至于变成一团大煤球僵死的代码。</p><p>为什么还是有些同学没法享受coding呢？我觉得是缺乏自信！</p><h3 id="自信"><a href="#自信" class="headerlink" title="自信"></a>自信</h3><blockquote><p>青天不算高，人心第一高</p></blockquote><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img//dqc-think/%E8%87%AA%E4%BF%A1.png" alt=""></p><p>我觉得自信真的特别重要，即使是迷之自信，也强过没有自信。</p><p>缺乏自信的表现大致有2类：</p><ul><li><p>害怕使用、尝试新技术、新设计</p><p>这类开发害怕使用尝试新技术，担心出了问题，自己解决不了，影响业务开发的进度。我觉得这个问题非常严重，你不能把你学到的技术应用起来，你永远不知道你是否掌握了，学到的是否对的，你永远没法成长。其实这也反映出一些问题：</p><ol><li>代码缺乏review，导致他们对自己的代码没有自信，害怕出现问题</li><li>发布上线规范制定的不够好</li></ol></li><li><p>觉得自己设计实现的代码或者方案就那样</p><p>这类开发觉得自己的代码就是：一顿操作猛如虎，一看代码渣如雏。</p><p>我经常和这类人说的是：<strong>战略上藐视所有人，战术上重视所有人</strong>。什么意思呢？就是说战略上，你要知道，你不比任何人差，你的技术也并不比任务人弱多少，你有什么好虚的呢？但是战术上，每个人都可能会有特别的想法意见值得我们去学习吸收。</p><blockquote><p>总有人要赢，那这个人为什么不能是你呢？</p></blockquote></li></ul><p>和缺乏自信的人相反，还有一类是超级自信的那种，觉得自己牛逼坏了。那这种情况应该怎么办呢？我们先来看看一张图：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img//dqc-think/zxx1.jpg" alt=""></p><p>当我们自信心爆炸的时候，我们如何检验自己是在<strong>愚昧山峰</strong>，还是在<strong>平稳高原</strong>呢？我觉得要挑战自己。</p><h3 id="挑战自己"><a href="#挑战自己" class="headerlink" title="挑战自己"></a>挑战自己</h3><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img//dqc-think/%E6%8E%A5%E5%8F%97%E6%8C%91%E6%88%98.jpg" alt=""></p><p>其实我在工作大概2-3年的时候，突然有一天，我觉得java不就那点东西嘛，我感觉我都会了。什么并发，AQS，锁，自旋锁、重入锁、读写锁、jvm、对象内存分布、gc、框架spring等，我都会啊。我那会觉得我可以做架构师了，然后我做了一个非常明智的决定，我决定去写一个框架，彻底代替spring，以后提到java企业级开发，就是我写的框架了(然后名字都起好了，他不是叫spring嘛，我就叫summer)。然后我大概构思设计了2周，发现我找不到一个点下手，我应该用个什么思想呢？用什么高大上的技术手段呢？然后再过了几天，我突然发现，我连java多线程都不了解了，并发他背后到底做了什么事情？我一度怀疑自己失忆了…</p><p>所以，我想说，如果你觉得自己牛逼坏了，不妨多挑战一下自己，比如自己设计个框架啊、写个提升工作效率的小工具等等，你会发现一个不一样的你。</p><p>那当我们挑战自己后，陷入迷茫困顿的时候怎么办呢？看书。</p><h3 id="看书"><a href="#看书" class="headerlink" title="看书"></a>看书</h3><blockquote><p>付出的是价格，收获的是价值</p></blockquote><p>我那会陷入迷茫的时候，我又做了一个非常明智的决定，看书。所有我感觉我不懂的地方，我都针对的买了相应的书，然后非常庆幸我把大部分书都看完了，至少现在我没有当时的那种啥都不知道，感觉掉入黑洞的焦虑。</p><ul><li><p>如何针对性的看书呢？</p><p>我的做法是，一次性买3本相关领域的书。兼听则明，花几十块钱就能学到3位作者花了2-3年总结的知识，我真是太赚了！</p></li><li><p>看一本书，其实很快</p><p>很多开发跟我说，技术书都太厚了，看不完。我想说，看一本书，其实很快。我现在每天中午看10-20分钟，大概能看10页，一个月20天大概能看200页。一本稍微厚点的书也就400多页，2个月就看完了！</p></li></ul><blockquote><p>重要的不是你学习了多少新东西，而是你改正了多少错误，弥补了多少短板，根据你的需要学习了多少新东西</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;程序员的自我修养&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里主要和大家分享我在开发DQC（数据质量中心）的过程中，对产品需求、架构设计、编码、自我提升这4个环节的反思与经验。&lt;/p&gt;
&lt;h2 id=&quot;产品需求&quot;&gt;&lt;a href=&quot;#产品需求&quot; class=&quot;headerlink&quot; title=&quot;产品需求&quot;&gt;&lt;/a&gt;产品需求&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;产品需求阶段，我们能做什么，该做些什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为有2点很重要:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;沟通：高效沟通，可以减少歧义，加快开发&lt;/li&gt;
&lt;li&gt;参与：参与其中，可以减少返工，保持扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那如何做到这2点呢？我认为有个非常重要的概念：领域通用语言&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="架构设计" scheme="https://zacard.net/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="编码" scheme="https://zacard.net/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="自我提升" scheme="https://zacard.net/tags/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>X-UID:分布式唯一id服务</title>
    <link href="https://zacard.net/2018/04/24/x-uid/"/>
    <id>https://zacard.net/2018/04/24/x-uid/</id>
    <published>2018-04-24T08:49:38.000Z</published>
    <updated>2018-12-27T07:35:42.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前开发的分布式唯一id比较简陋。这段时间重新设计优化，变成一个独立的项目X-UID。这里记录下设计优化的一些东西</p><p>基本算法还是基于snowflake。因为需求就是要一个long型数字，snowflake算法简单高效。</p><h2 id="snowflake简单介绍"><a href="#snowflake简单介绍" class="headerlink" title="snowflake简单介绍"></a>snowflake简单介绍</h2><p>算法生成的id结构图：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/xuid/snowflake.png" alt=""></p><p>说明：</p><ul><li>1-bit：符号位，一般不设置，默认为0</li><li>41-bit：时间戳，大约能用69年</li><li>10-bit：工作机器id，最大支持1024个workerId</li><li>12-bit：序列号，毫秒内的自增序列。这也决定了其QPS的上限为400w/s这个数量级</li></ul><a id="more"></a><p>核心代码如下(重点关注nextId()方法)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RawSnowFlake</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 相对于2018-04-20 00:00:00的时间戳</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> START_TIME = <span class="number">1524153600000L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间戳位数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMESTAMP_BITS = <span class="number">41</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 相对于START_TIME的时间戳最大大小</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_TIMESTAMP = START_TIME + ~(-<span class="number">1L</span> &lt;&lt; TIMESTAMP_BITS);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作节点标示id所占的位数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_BITS = <span class="number">10L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最大工作节点的数量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_WORKER_ID = ~(-<span class="number">1L</span> &lt;&lt; WORKER_ID_BITS);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 序列号所占的位数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_BITS = <span class="number">12L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作节点标示id位移数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_SHIFT = SEQUENCE_BITS;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间戳位移数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMESTAMP_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 就是用来对sequence做快速取模操作的</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_MASK = ~(-<span class="number">1L</span> &lt;&lt; SEQUENCE_BITS);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作节点标示id</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 序列号</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 上次时间戳</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RawSnowFlake</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RawSnowFlake</span><span class="params">(<span class="keyword">long</span> workerId)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (workerId &lt; <span class="number">0</span> || workerId &gt; MAX_WORKER_ID) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"worker id过大,不能超过"</span> + MAX_WORKER_ID);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.workerId = workerId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> timestamp = timeGen();</div><div class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"时间回拨"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (timestamp == lastTimestamp) &#123;</div><div class="line">            <span class="comment">// 同一毫秒内，进行序列自增</span></div><div class="line">            sequence = (sequence + <span class="number">1</span>) &amp; SEQUENCE_MASK;</div><div class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 数字溢出了，等待下一个毫秒</span></div><div class="line">                timestamp = tilNextMillis(lastTimestamp);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 时间戳改变，毫秒内序列重置</span></div><div class="line">            sequence = <span class="number">0L</span>;</div><div class="line">        &#125;</div><div class="line">        lastTimestamp = timestamp;</div><div class="line">        <span class="keyword">return</span> generateId(timestamp, workerId, sequence);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 组装id</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">generateId</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">long</span> workerId, <span class="keyword">long</span> sequence)</span> </span>&#123;</div><div class="line">        <span class="comment">// 超过了时间戳位数的情况</span></div><div class="line">        <span class="keyword">if</span> (timestamp &gt; MAX_TIMESTAMP) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"设置的时间戳位数已经使用到上限"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_SHIFT)</div><div class="line">                | (workerId &lt;&lt; WORKER_ID_SHIFT)</div><div class="line">                | sequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 等待到下一个毫秒时间戳</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> timestamp = timeGen();</div><div class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</div><div class="line">            timestamp = timeGen();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> timestamp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前时间戳</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="snowflake的优点"><a href="#snowflake的优点" class="headerlink" title="snowflake的优点"></a>snowflake的优点</h3><ul><li>性能高，算法简单高效</li><li>生成的id趋势递增，不会像单调递增会被竞争对手预测量级</li><li>无依赖，没有依赖第三方包，更稳定</li></ul><h3 id="snowflake的缺点"><a href="#snowflake的缺点" class="headerlink" title="snowflake的缺点"></a>snowflake的缺点</h3><ul><li><p>无法处理时间回拨：一旦发生时间回拨(特别是<strong>闰秒</strong>的时候)，服务不可用或者可能生成重复的id（个人觉得这个最为致命）</p><p>  以下摘自百度百科：</p><blockquote><p><strong>闰秒</strong>，是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时<strong>增加或减少1秒</strong>的调整。</p><p>关于闰秒，推荐阅读：<a href="https://coolshell.cn/articles/7804.html" target="_blank" rel="external">传说门</a></p></blockquote><p>  作为一个如此基础的服务，稳定性特别的重要！</p></li><li><p>瞬时流量高峰，响应时间波动较大。因为生成id的方法整个处于锁的保护下，所有线程串行执行，遇到瞬时大流量，响应时间波动较大</p></li><li>功能相对单一。只有一个生成趋势递增id的方法</li></ul><h2 id="X-UID的改进优化"><a href="#X-UID的改进优化" class="headerlink" title="X-UID的改进优化"></a>X-UID的改进优化</h2><h3 id="解决时间回拨"><a href="#解决时间回拨" class="headerlink" title="解决时间回拨"></a>解决时间回拨</h3><p>2个策略：</p><ul><li>假如回拨的时间毫秒数小于15毫秒（可配置），则等待当前时间赶上lastTimestamp</li><li>否则，更换一个更大的workerId – 这里就必须有一个集中式的workerId管理了，比如zookeeper</li></ul><p>策略存在的问题：</p><p>还存在理论上的id重复问题，例如以下执行序列：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/xuid/更换workid异常时序图.png" alt=""></p><p>当连续遇到时间回拨，workerId耗尽时，我们选择从0开始寻找一个目前没有在使用的workerId，例如0.这时候，workerId是从大变成了小。如果同时当前机器的时间戳仍然小于使用0这个workerId生成的id使用的时间戳(基本不可能发生)，那生成的id将会重复。目前没有一个比较好的解决方案，不过我们对此还是采用了一种<strong>柔性处理</strong>，这个下面讲</p><h3 id="提高响应时间稳定性"><a href="#提高响应时间稳定性" class="headerlink" title="提高响应时间稳定性"></a>提高响应时间稳定性</h3><blockquote><p>其实大部分情况不会有这个量级。纯当挑战下，能否进一步提高性能。</p></blockquote><p>首先就是对原方法的批量改造，即允许一次性生成指定数量的id,核心代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] generateIds(<span class="keyword">long</span> timestamp, <span class="keyword">long</span> workerId, <span class="keyword">int</span> count) &#123;</div><div class="line">    <span class="comment">// 超过了时间戳位数的情况</span></div><div class="line">    <span class="keyword">if</span> (((sequence + count) &gt;&gt; SEQUENCE_BITS) + timestamp &gt; MAX_TIMESTAMP) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"设置的时间戳位数已经使用到上限"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span>[] ids = <span class="keyword">new</span> <span class="keyword">long</span>[count];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="comment">// 同一毫秒内，进行序列自增</span></div><div class="line">        <span class="keyword">if</span> ((++sequence &amp; SEQUENCE_MASK) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 数字溢出了，等待下一个毫秒</span></div><div class="line">            lastTimestamp = timestamp = tilNextMillis(lastTimestamp);</div><div class="line">        &#125;</div><div class="line">        ids[i] = (workerId &lt;&lt; WORKER_ID_SHIFT) | ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_SHIFT) | sequence;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ids;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后的关键就是，如何提升性能来应对瞬时大并发。核心思想就是缓存，缓存部分流量低峰或者是平稳期被浪费的id。例如当某个毫秒时刻只有2个生成id的请求，相当于这一毫秒被浪费了4094个id.这部分id完全可以缓存起来应对瞬时大并发。</p><p>如下3级缓存架构：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/xuid/3级缓存架构图.png" alt=""></p><p>1级缓存是个数组，并发取数据，取空后发布异步任务去2级缓存拉取数据；2级缓存是个阻塞队列，3级缓存其实是文件，会有个线程不断在<strong>空闲期</strong>调用批量生成id的方法来填充2&amp;3级缓存。并且有另外一个线程不断读取数据推送到2级缓存</p><h4 id="1级缓存结构"><a href="#1级缓存结构" class="headerlink" title="1级缓存结构"></a>1级缓存结构</h4><p>结构图如下：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/xuid/1级缓存结构图.jpg" alt=""></p><p>说明：</p><ol><li><p>1级缓存是一个环形数组，默认长度为4096，每个数组槽位采用缓存行填充，避免伪共享(伪共享请参考：<a href="https://zacard.net/2018/02/26/false-share/">传送门</a>)。如何做到环形，就是利用cas让数组下标原子的在0~4095之间循环变动即可</p></li><li><p>数据填充方式：不是每次被取走就马上填充。而是逻辑上的分为4个分区，也就是每个分区1024个id.当整个分区的id被取走后才发布id填充异步任务。这样有2个好处，减少数组的竞争和批量填充，效率更高。那如何判断这个分区被取空了呢？就是使用<code>(index+1)&amp;1023==0</code>逻辑与操作代替相对昂贵的取模操作</p></li><li><p>处理异步拉取任务的线程池做过特定优化：会对任务去重。当同一时刻进来4096*2的id请求时，将会发布8个分区填充的任务，而事实上有一半的任务是重复的(填充同一个分区)，浪费id，无谓的加重竞争，所以会对任务去重</p></li><li><p>拉取任务会先尝试(poll()方法)去阻塞队列里获取数据，如果阻塞队列为空，则调用加锁的批量生成id方法生成</p></li></ol><h4 id="2-amp-3级缓存结构"><a href="#2-amp-3级缓存结构" class="headerlink" title="2&amp;3级缓存结构"></a>2&amp;3级缓存结构</h4><p>结构图如下：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/xuid/2&amp;3级缓存结构图.jpg" alt=""></p><p>说明：</p><ol><li><p>3级缓存是文件，默认大小3G≈4亿个id.文件顺序读顺序写，系统维护一个读偏移量，每次读取16kb=2048个id的数据量，充分利用磁盘io的预读。数据读完不删除，只有到数据全部读完的时候才会删除整个文件，重新生成一个新的空白文件</p></li><li><p>有一个定时任务线程，在<strong>空闲期</strong>不断的调用加锁的批量生成id的方法，把数据推送到2&amp;3级缓存</p></li><li><p>还有一个定时任务线程，不断的读取文件的id推送到2级缓存阻塞队列</p></li></ol><h4 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h4><ol><li><p>有了1级环形数组缓存，为何还有2级缓存？</p><p> 因为1级数组缓存使用了缓存行填充，其实浪费了将近7/8的内存空间，给其分配的空间不宜过大。二级缓存是个阻塞队列，存的是原始的Long型，内存空间利用率高</p><p> 而且1级缓存的数据其实是采用主动拉的模式，不能很好的利用生成id方法的空闲期</p></li><li><p>只使用2级缓存，不用1级缓存，怎么样？</p><p> 效率没有2着结合的高。首先1级缓存的并发竞争点是对一个int型的数组下标的cas操作，比较的短平快。而阻塞队列竞争是在锁的保护下的，效率相对更低</p></li><li><p>不使用3级文件缓存可以吗？</p><p> 不使用文件缓存将失去一些HA(高可用方面的保障)。比如文件可以保存更多的id数据，保障了应对更长时间的大并发大流量。其次，之前说的对时间回拨的<strong>柔性处理</strong>，其实是利用的文件缓存。因为workerId相对属于有限资源(只有1024个)，不到万不得已，不能轻易更换。所以，当发现需要更换workerId(或者更换的workerId比当前小)的时候，我们优先读取文件缓存的id</p><p> 并且当机器意外重启的时候，文件中的id能保证一段时间的高并发流量的使用</p></li><li><p>如何判定是否处于空闲期？</p><p> 判定当前等待锁的线程数。默认等待的线程数大于2(可配置，并且会结合可用的cpu核数综合判定)即认为是繁忙的。</p></li></ol><h3 id="数据对比"><a href="#数据对比" class="headerlink" title="数据对比"></a>数据对比</h3><p>电脑配置：MacBook Pro，i5-4核，16G</p><p>性能测试使用JMH</p><p>吞吐量：</p><p><img src="https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/xuid/吞吐量对比图.jpg" alt=""></p><blockquote><p>x-uid取的是最低值800w+,正常情况能跑到1200w+.提升了1倍多</p></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这些优化其实就2个人花了2天的时间做的，有些设计还比较混乱，后面会重新整理设计一版。还有一些优化的想法暂时没有实践。比如</p><ul><li>设计一个更适合这个应用场景(单消费者多生产者)的队列</li><li>对于从1级缓存获取id的线程分组。因为目前最大竞争点应该是cas1级缓存的数组下标。cas操作有个问题就是大并发下可能造成线程饥饿。考虑对线程hash分组到不同的分区来进一步分散cas热点</li><li>目前弱依赖了zookeeper，就启动的时候去zk获取workerId，会写入到本地文件。然后更换workerId的时候需要zk。后续考虑自己设计开发一个轻量级的注册中心来做这个事情</li><li>其他。。。</li></ul><blockquote><p>先完成，再完美</p></blockquote><p>还有就是一个snowflake无法保证的场景，就是需要全局严格的趋势递增(一般是mq的顺序消息排序)，snowflake其实是做不到的，它毫秒内无法保证这点。而X-UID只要调用批量生成id，在同一台拉取足够数量的顺序消息id是能严格保证这点的</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前开发的分布式唯一id比较简陋。这段时间重新设计优化，变成一个独立的项目X-UID。这里记录下设计优化的一些东西&lt;/p&gt;
&lt;p&gt;基本算法还是基于snowflake。因为需求就是要一个long型数字，snowflake算法简单高效。&lt;/p&gt;
&lt;h2 id=&quot;snowflake简单介绍&quot;&gt;&lt;a href=&quot;#snowflake简单介绍&quot; class=&quot;headerlink&quot; title=&quot;snowflake简单介绍&quot;&gt;&lt;/a&gt;snowflake简单介绍&lt;/h2&gt;&lt;p&gt;算法生成的id结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mmaxiaolei/resource/master/img/xuid/snowflake.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1-bit：符号位，一般不设置，默认为0&lt;/li&gt;
&lt;li&gt;41-bit：时间戳，大约能用69年&lt;/li&gt;
&lt;li&gt;10-bit：工作机器id，最大支持1024个workerId&lt;/li&gt;
&lt;li&gt;12-bit：序列号，毫秒内的自增序列。这也决定了其QPS的上限为400w/s这个数量级&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="snowflake" scheme="https://zacard.net/tags/snowflake/"/>
    
      <category term="分布式" scheme="https://zacard.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="唯一id" scheme="https://zacard.net/tags/%E5%94%AF%E4%B8%80id/"/>
    
  </entry>
  
  <entry>
    <title>mysql等数据库索引为什么偏爱b+tree</title>
    <link href="https://zacard.net/2018/03/30/mysql-b-tree/"/>
    <id>https://zacard.net/2018/03/30/mysql-b-tree/</id>
    <published>2018-03-30T06:10:40.000Z</published>
    <updated>2018-03-30T06:34:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>类似mysql等数据库偏爱用b+tree这个数据结构作为索引，这是为什么呢？要解释这个原因，必须先讲下计算机组成原理中的磁盘数据存取原理。</p><h2 id="磁盘数据读取原理"><a href="#磁盘数据读取原理" class="headerlink" title="磁盘数据读取原理"></a>磁盘数据读取原理</h2><p><strong>这里指普通的机械磁盘。</strong></p><p>先看下磁盘的结构:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/b+tree1.png" alt=""></p><a id="more"></a><p>如上图，磁盘由盘片构成,每个盘片有两面，又称为盘面(Surface)，这些盘面覆盖有磁性材料。盘片中央有一个可以旋转的主轴(spindle)，他使得盘片以固定的旋转速率旋转，通常是5400转每分钟(Revolution Per Minute,RPM)或者是7200RPM。磁盘包含多个这样的盘片并封装在一个密封的容器内。上图左，展示了一个典型的磁盘表面结构。每个表面是由一组称为磁道(track)的同心圆组成的，每个磁道被划分为了一组<strong>扇区(sector)</strong>.每个扇区包含相等数量的数据位，通常是512子节。扇区之间由一些间隔(gap)隔开,不存储数据。</p><p>磁盘的读写操作：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/b+tree2.png" alt=""></p><p>如上图，磁盘用读/写头(磁头)来读写存储在磁性表面的位，而读写头连接到一个传动臂的一端。通过沿着半径轴前后移动传动臂，驱动器可以将读写头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到位的值，也可以修改值。对磁盘的访问时间分为<strong>寻道时间，旋转时间，以及传送时间</strong>。</p><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I/O，减少读写操作。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p>程序运行期间所需要的数据通常比较集中。</p></blockquote><p>由于磁盘顺序读取的效率很高（<strong>不需要寻道时间，只需很少的旋转时间</strong>），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p><strong>预读的长度一般为页（page）的整倍数</strong>。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，<strong>页的大小通常为4KB</strong>），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h3 id="磁盘读取原理总结"><a href="#磁盘读取原理总结" class="headerlink" title="磁盘读取原理总结"></a>磁盘读取原理总结</h3><p><strong>一次磁盘I/O：读n页(因为存在预读)，1页包含m个扇区。</strong></p><p>先实际看下linux系统（centos）的一个扇区大小和一个页(逻辑块，一次I/O的大小)大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;fdisk -l</div><div class="line">&gt;磁盘 /dev/sda：500.1 GB, 500107862016 字节，976773168 个扇区</div><div class="line">Units = 扇区 of 1 * 512 = 512 bytes</div><div class="line">扇区大小(逻辑/物理)：512 字节 / 4096 字节</div><div class="line">I/O 大小(最小/最佳)：4096 字节 / 4096 字节</div></pre></td></tr></table></figure><p><strong>可以看到一个扇区大小是512B,一个页大小为4096B,也就是一个页包含8个扇区</strong></p><p>再看看预读的扇区数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;/sbin/blockdev --getra /dev/sda</div><div class="line">&gt;256</div></pre></td></tr></table></figure><p><strong>这里指的的是最大预读256个扇区，也就是32页。但是OS会有个自适应的过程，一般从4页(16KB)开始，在一定的时间窗口中倍增</strong></p><h2 id="为什么不用平衡二叉树"><a href="#为什么不用平衡二叉树" class="headerlink" title="为什么不用平衡二叉树"></a>为什么不用平衡二叉树</h2><p>比如红黑树。</p><p>由于数据库索引其实也是很大的，不可能全部存储在内存中，索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以<strong>评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度</strong></p><p>所以，不使用平衡二叉树的原因如下：</p><ul><li><strong>最大原因：深度太大(因为一个节点最多只有2个子节点)，一次查询需要的I/O复杂度为O(lgN),而b+tree只需要O(log_mN),而其出度m非常大，其深度一般不会超过4</strong></li><li>平衡二叉树逻辑上很近的父子节点，物理上可能很远，无法充分发挥磁盘顺序读和预读的高效特性。</li></ul><p>举例：</p><p>InnoDB存储引擎中页的大小为16KB，我们假设主键类型为BIGINT（占用8个字节，8B），指针类型为8个字节。也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K≈1000个键值。也就是说一个深度为3的B+Tree索引可以维护<code>10^3 * 10^3 * 10^3 = 10亿</code>条记录，而且磁盘I/O最多<strong>3</strong>次。</p><p>同样10亿条数据，红黑树的深度为<strong>30</strong>，也就是最多需要<strong>30</strong>次磁盘I/O才能查询到数据。远高于b+tree</p><h2 id="为什么用b-tree而不用b-tree"><a href="#为什么用b-tree而不用b-tree" class="headerlink" title="为什么用b+tree而不用b-tree"></a>为什么用b+tree而不用b-tree</h2><p>先来看看b-tree和b+tree结构比较图：</p><p>一颗b-tree:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/b-tree1" alt=""></p><p>一颗b+tree:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/b+tree3" alt=""></p><p>b+tree相对于b-tree的区别：</p><ul><li>有n棵子树的结点中含有n个索引key信息(而b-tree是n棵子树有n-1个)</li><li>b+tree的非叶子仅仅存储索引key信息，不包含其他列内容</li><li>b+tree所有的叶子结点中包含了全部索引key信息，及指向含有这些关键字记录的指针，且叶子结点本身按照索引key的大小自小而大的顺序链接（叶子节点有个指向下一个叶子节点的指针</li></ul><p>所以，b+tree的优势在于：</p><ol><li>深度更低，磁盘I/O更少。因为b+tree非叶子节点仅仅包含索引key信息，想比较b-tree,一个节点能够容纳更多的索引key信息，也就是树的出度更大，树的深度也就更小</li><li>查询效率更加稳定。由于非叶子节点并不包含其他列内容，所以任何关键字的查找必须走完从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</li><li>范围查找、有序遍历非常方便。因为叶子节点之间有指针，遍历非常便捷。而b-tree就需要中序遍历才能做到</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;类似mysql等数据库偏爱用b+tree这个数据结构作为索引，这是为什么呢？要解释这个原因，必须先讲下计算机组成原理中的磁盘数据存取原理。&lt;/p&gt;
&lt;h2 id=&quot;磁盘数据读取原理&quot;&gt;&lt;a href=&quot;#磁盘数据读取原理&quot; class=&quot;headerlink&quot; title=&quot;磁盘数据读取原理&quot;&gt;&lt;/a&gt;磁盘数据读取原理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里指普通的机械磁盘。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看下磁盘的结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/b+tree1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="b-tree" scheme="https://zacard.net/tags/b-tree/"/>
    
      <category term="index" scheme="https://zacard.net/tags/index/"/>
    
      <category term="mysql" scheme="https://zacard.net/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch写入优化记录</title>
    <link href="https://zacard.net/2018/03/27/es-write-optimize/"/>
    <id>https://zacard.net/2018/03/27/es-write-optimize/</id>
    <published>2018-03-27T01:59:23.000Z</published>
    <updated>2018-03-27T02:12:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>基于elasticsearch-5.6.0</li><li>机器配置：3个阿里云ecs节点，16G,4核，机械硬盘</li></ul><p>优化前，写入速度平均3000条/s，一遇到压测，写入速度骤降，甚至es直接频率gc、oom等；优化后，写入速度平均8000条/s，遇到压测，能在压测结束后30分钟内消化完数据，各项指标回归正常。</p><a id="more"></a><h2 id="优化设置"><a href="#优化设置" class="headerlink" title="优化设置"></a>优化设置</h2><ol><li>精细设置全文域：string类型字段默认会分词，不仅会额外占用资源，而且会影响创建索引的速度。所以，把不需要分词的字段设置为<code>not_analyzed</code></li><li>禁用<code>_all</code>字段:对于日志和apm数据，目前没有场景会使用到</li><li>副本数量设置为0:因为我们目前日志数据和apm数据在es只保留最近7天的量，全量日志保存在hadoop，可以根据需要通过spark读回到es – <strong>况且副本数量是可以随时修改的，区别分片数量</strong></li><li>使用es自动生成id：es对于自动生成的id有优化，避免了版本查找。因为其生成的id是唯一的</li><li>设置<code>index.refresh_interval</code>：索引刷新间隔，默认为1s。因为不需要如此高的实时性，我们修改为30s – <strong>扩展学习：刷新索引到底要做什么事情？</strong></li><li><p>设置段合并的线程数量：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -XPUT &apos;your-es-host:9200/nginx_log-2018-03-20/_settings&apos; -d &apos;&#123; </div><div class="line">   &quot;index.merge.scheduler.max_thread_count&quot; : 1</div><div class="line">&#125;&apos;</div></pre></td></tr></table></figure><blockquote><p>段合并的计算量庞大，而且还要吃掉大量磁盘I/O。合并在后台定期操作，因为他们可能要很长时间才能完成，尤其是比较大的段</p><p><strong>机械磁盘</strong>在并发I/O支持方面比较差，所以我们需要降低每个索引并发访问磁盘的线程数。这个设置允许<code>max_thread_count + 2</code>个线程同时进行磁盘操作，也就是设置为<code>1</code>允许三个线程</p><p><strong>扩展学习：什么是段(segment)？如何合并段？为什么要合并段？（what、how、why）</strong></p></blockquote></li><li><p>设置异步刷盘事务日志文件：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;index.translog.durability&quot;: &quot;async&quot;,</div><div class="line">   &quot;index.translog.sync_interval&quot;: &quot;30s&quot;</div></pre></td></tr></table></figure><p> 对于日志场景，能够接受部分数据丢失。同时有全量可靠日志存储在hadoop，丢失了也可以从hadoop恢复回来</p><blockquote><p><strong>扩展学习：事务日志translog何时刷盘？具体流程是什么？</strong></p></blockquote></li><li><p>elasticsearch.yml中增加如下设置：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">indices.memory.index_buffer_size: <span class="number">20</span>%</div><div class="line">indices.memory.min_index_buffer_size: <span class="number">96</span>mb</div></pre></td></tr></table></figure><p> 已经索引好的文档会先存放在内存缓存中，等待被写到到段(segment)中。缓存满的时候会触发段刷盘(吃i/o和cpu的操作)。默认最小缓存大小为48m，不太够，最大为堆内存的10%。对于大量写入的场景也显得有点小。</p><blockquote><p><strong>扩展学习：数据写入流程是怎么样的(具体到如何构建索引)？</strong></p></blockquote></li><li><p>设置index、merge、bulk、search的线程数和队列数。例如以下elasticsearch.yml设置：</p> <figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Search pool</span></div><div class="line">thread_pool.search.size: <span class="number">5</span></div><div class="line">thread_pool.search.queue_size: <span class="number">100</span></div><div class="line"><span class="comment"># 这个参数慎用！强制修改cpu核数，以突破写线程数限制</span></div><div class="line"><span class="comment"># processors: 16</span></div><div class="line"><span class="comment"># Bulk pool</span></div><div class="line">thread_pool.bulk.size: <span class="number">16</span></div><div class="line">thread_pool.bulk.queue_size: <span class="number">300</span></div><div class="line"><span class="comment"># Index pool</span></div><div class="line">thread_pool.index.size: <span class="number">16</span></div><div class="line">thread_pool.index.queue_size: <span class="number">300</span></div></pre></td></tr></table></figure></li><li><p>设置filedata cache大小，例如以下elasticsearch.yml配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">indices.fielddata.cache.size: <span class="number">15</span>%</div></pre></td></tr></table></figure><blockquote><p>filedata cache的使用场景是一些聚合操作(包括排序),构建filedata cache是个相对昂贵的操作。所以尽量能让他保留在内存中</p></blockquote><p>然后日志场景聚合操作比较少，绝大多数也集中在半夜，所以限制了这个值的大小，默认是不受限制的，很可能占用过多的堆内存</p><blockquote><p><strong>扩展学习：什么是filedata？构建流程是怎样的？为什么要用filedata？（what、how、why）</strong></p></blockquote></li><li><p>设置节点之间的故障检测配置，例如以下elasticsearch.yml配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">discovery.zen.fd.ping_timeout: <span class="number">120</span>s</div><div class="line">discovery.zen.fd.ping_retries: <span class="number">6</span></div><div class="line">discovery.zen.fd.ping_interval: <span class="number">30</span>s</div></pre></td></tr></table></figure><p>大数量写入的场景，会占用大量的网络带宽，很可能使节点之间的心跳超时。并且默认的心跳间隔也相对过于频繁（1s检测一次）</p><p>此项配置将大大缓解节点间的超时问题</p></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这里仅仅是记录对我们实际写入有提升的一些配置项，没有针对个别配置项做深入研究。</p><p>扩展学习后续填坑。基本都遵循（what、how、why）原则去学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基于elasticsearch-5.6.0&lt;/li&gt;
&lt;li&gt;机器配置：3个阿里云ecs节点，16G,4核，机械硬盘&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优化前，写入速度平均3000条/s，一遇到压测，写入速度骤降，甚至es直接频率gc、oom等；优化后，写入速度平均8000条/s，遇到压测，能在压测结束后30分钟内消化完数据，各项指标回归正常。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="elasticsearch" scheme="https://zacard.net/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>阿里中间件6轮面试被砍的血泪总结</title>
    <link href="https://zacard.net/2018/03/20/alibaba-middleware-interview/"/>
    <id>https://zacard.net/2018/03/20/alibaba-middleware-interview/</id>
    <published>2018-03-20T14:13:02.000Z</published>
    <updated>2018-03-21T02:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>年前在v2ex遇到阿里中间件的哥们，内推面试。从2018.02.01开始到今天2018.03.20，一场浩浩荡荡，跨年，持续了1个半月时间的残酷面试终于尘埃落定。遗憾的未能加入阿里中间件部门这个大家庭，让我深感痛惜。</p><p>最终未能如愿的原因是“名额有限，有更适合的同学”。这也可能是内推大哥为了顾及我的感受的说辞，可能是最后一面面的不好。</p><p>这里凭借隐约的记忆，总结下面试经过。让我自己<strong>引以为戒，奋发自强，继续前行</strong></p><a id="more"></a><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>主要问一些java基础。包括集合、多线程、ClassLoader、锁、juc类库等都要知道大致的<strong>原理、使用规范、约定</strong>等</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>根据项目，深入探讨。你需要清楚你所做项目的关键细节、优化、特点、原理。所用第三方库&amp;中间件等的原理，<strong>即使不知道，也要有自己的想法能够说出如何代替实现</strong>！而且需要一定的<strong>技术知识的广度</strong>，对于如何选型，为何这么选型能够说出自己的理由</p><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>个人感觉着重<strong>技术深度</strong>。</p><p>从ConcurrentHashMap一路问到锁&amp;锁优化-&gt;LongAdder-&gt;伪共享-&gt;缓存行填充-&gt;cas等诸多技术细节；</p><p>从hystrix一路问到原理-&gt;自己如何实现-&gt;如何优化-&gt;响应流编程(reactive streams);</p><p>从简单的生产者消费者模式设计到如何高效健壮实现；</p><p>等等。</p><h2 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h2><p>纯coding。</p><blockquote><p>如何倒序输出单向链表？</p></blockquote><p>个人直接想法是用栈先进后出的特点，把链表数据读到栈里然后输出。</p><blockquote><p>有更好的实现方式吗？</p></blockquote><p>仔细一想，确实不够优雅，还好之前刷过一阵子的leetcode，一般能用<strong>栈解决的都能用递归搞定</strong>。换了一种递归实现：</p><p>具体看本人的<a href="https://github.com/mmaxiaolei/algorithm/blob/master/src/main/java/com/zacard/algorithm/test/Test.java" target="_blank" rel="external">github传送门</a></p><h2 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h2><p>hr面，唯一一次现场面，一直以为是最后一面呢。</p><p>给大家抛出几大深坑问题：</p><ul><li>个人的职业规划是什么</li><li>你遇到的最大问题或者是困难是什么</li><li>你如何看待阿里</li><li>你能为阿里带来什么</li><li>你的优缺点是什么</li></ul><p>这几个问题，大家深思啊，不多说。</p><h2 id="六面"><a href="#六面" class="headerlink" title="六面"></a>六面</h2><p>大概晚上20:00的时候接的电面。那会刚刚游泳游了大概2，300百米，然后又没有吃饭，肚子咕咕叫。忍着接听。</p><p>主要问项目情况，然后根据一个项目，问如果量级扩大1000倍，你会怎么做？有哪些优化措施？高性能&amp;高可用措施？</p><p>后面有点饿的眩晕，不知道怎么结束的。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉阿里更偏重<strong>扎实的基础和解决问题的创意与能力</strong>。个人感觉自己缺乏大并发、大流量下面对各种复杂问题的处理经验与解决方案，继续沉淀学习吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;年前在v2ex遇到阿里中间件的哥们，内推面试。从2018.02.01开始到今天2018.03.20，一场浩浩荡荡，跨年，持续了1个半月时间的残酷面试终于尘埃落定。遗憾的未能加入阿里中间件部门这个大家庭，让我深感痛惜。&lt;/p&gt;
&lt;p&gt;最终未能如愿的原因是“名额有限，有更适合的同学”。这也可能是内推大哥为了顾及我的感受的说辞，可能是最后一面面的不好。&lt;/p&gt;
&lt;p&gt;这里凭借隐约的记忆，总结下面试经过。让我自己&lt;strong&gt;引以为戒，奋发自强，继续前行&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://zacard.net/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://zacard.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="阿里" scheme="https://zacard.net/tags/%E9%98%BF%E9%87%8C/"/>
    
      <category term="中间件" scheme="https://zacard.net/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁研究</title>
    <link href="https://zacard.net/2018/03/20/distributed-lock/"/>
    <id>https://zacard.net/2018/03/20/distributed-lock/</id>
    <published>2018-03-20T11:30:27.000Z</published>
    <updated>2018-03-20T12:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司使用基于redis setNX的分布式锁偶现失效，对此深入研究一番</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>大体来说，分布式锁的场景有两种：</p><ol><li>为了效率：相当于去重，避免各个系统做重复的事情。比如重复发送一封email</li><li>为了正确性：不允许出现任何的失效，不然就可能造成数据不一致</li></ol><h2 id="基于单节点的redis实现"><a href="#基于单节点的redis实现" class="headerlink" title="基于单节点的redis实现"></a>基于单节点的redis实现</h2><blockquote><p>为什么强调单节点？因为我们就一个redis主从，没有redis集群。而且redis有官方的分布式锁redlock是基于redis集群的，这个对我们不适用，而且感觉有点过重。</p></blockquote><p>我们一开始的方案是基于setNX(key,value,timeout)。后来发现原来这是jedis的封装，这其实是2个redis命令<code>：setnx+expire</code>。也就是说<strong>这不是个原子操作，很可能setnx成功，但是设置过期时间失败导致锁永远无法释放</strong></p><p>翻看redlock的套路才知道，应该这样操作：</p><ol><li><p>获取锁：<code>set key randomValue NX PX 3000</code></p><blockquote><p>redis的set操作有NX(if not exist)选项和PX(过期时间)选项，可以实现原子操作</p></blockquote></li><li><p>释放锁：需要使用LUA脚本实现复合操作的原子性：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1) get key</div><div class="line">(2) 比较random value</div><div class="line">(3) random value一致即删除key</div></pre></td></tr></table></figure></li></ol><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一些疑问：</p><ol><li><p>必须要设置过期时间吗？</p><blockquote><p>必须要。因为假如获取锁的程序阻塞/崩溃/与redis网络异常等情况，锁将永远不能被释放</p></blockquote></li><li><p>必须要设置一个随机值吗？</p><blockquote><p>必须要。考虑以下执行序列：</p></blockquote><p> (1) 程序1获取了锁</p><p> (2) 程序1假死导致锁超时被释放</p><p> (3) 程序2获取了锁</p><p> (4) 程序1从假死中恢复，直接释放了锁（没有比较随机值，相当于把程序2的锁给释放了）</p><p> (5) 程序2的执行将得不到锁的保护</p></li><li><p>必须使用lua脚本来释放锁吗？</p><blockquote><p>必须要。因为释放锁需要3步（<code>get-&gt;比较random value-&gt;del</code>）,需要保证3个复合操作的原子性。也不能用redis的事务消息，因为redis没有比较和if else这样命令啊…redis要是有类似cas这种操作就好了，compare and delete一步就能搞定</p></blockquote></li></ol><p>这样处理的redis锁已经是万无一失了吗？其实还存在2个主要问题：</p><ol><li>过期时间设置多久合适？如果设置太短，锁就可能在程序完成对共享资源的操作之前失效，从而得不到保护；如果设置的太长，一旦某个获取锁的程序释放锁失败(比如与redis网络异常)，那么就可能导致其他系统长时间无法获取锁而无法正常工作</li><li>如果程序假死(例如长时间的GC pause)将导致锁过期失效，这时候共享资源其实已经失去了保护(可能这时候有另一个程序获取了锁，而假死的程序恢复过来后同时在操作共享资源)</li></ol><blockquote><p>另外redlock还存在另一个问题就是强依赖于几个节点之间的系统时钟，一旦发生时钟跳跃，redlock很可能就失效</p></blockquote><p>很多人说可以用更可靠的zookeeper来解决，那基于zookeeper的分布式锁真的万无一失吗？先来看看zookeeper分布式锁的套路</p><h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p>具体参考官网文档：<a href="http://zookeeper.apache.org/doc/r3.4.9/recipes.html#sc_recipes_Locks" target="_blank" rel="external">传送门</a></p><ol><li><p>获取锁：</p><p> (1) 客户端调用create()在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推</p><p> (2) 客户端调用getChildren()获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得了锁，获取锁流程结束</p><p> (3) 否则在前一个节点调用exists()并设置watch监听节点删除消息</p><p> (4) 如果exists()返回false，重试第(2)步；否则等待节点删除通知再重试第(2)步直到获取锁</p></li><li><p>删除锁：删除创建的节点即可</p></li></ol><p>这样设计有以下优点：</p><ul><li>删除节点即释放锁时，只会导致最多一个客户端被唤醒，避免了“惊群效应（herd effect）”</li><li>不存在轮询或者超时</li><li>临时节点，会在客户端奔溃/假死等情况自动释放锁</li><li>能够直观的知道竞争锁的数量，甚至能退出锁，debug锁问题等</li></ul><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>zookeeper实现的分布式锁相对于redis确实更完善，功能也更丰富。没有redis过期时间的问题，而且能在需要的时候让锁自动释放。然而redis存在的问题中第2点，zookeeper也依然存在。假设有以下执行序列：</p><p>(1) 客户端1创建了节点/lock/lock-0000000000并且获取到了锁</p><p>(2)    客户端1进入长时间的GC pause</p><p>(3)    客户端1与zookeeper的session过期(心跳检测失败)，lock-0000000000被自动删除</p><p>(4)    客户端2创建了/lock/lock-0000000001并获得了锁</p><p>(5)    客户端1从GC pause中恢复，依然认为自己持有锁</p><p>(6) 客户端1和2都认为自己持有锁，就产生了冲突</p><p><strong>类似这种假死造成的锁失效问题，redis和zookeeper目前貌似没有完美的解决方案</strong></p><p>这里肯定有人会说google的Chubby可以做到完美，那就来看下Chubby对这个问题的解决方案</p><h2 id="Chubby分布式锁"><a href="#Chubby分布式锁" class="headerlink" title="Chubby分布式锁"></a>Chubby分布式锁</h2><p>Chubby分布式锁有2种实现，主要是针对之前提到问题的<strong>解决和缓解</strong></p><h3 id="完美实现："><a href="#完美实现：" class="headerlink" title="完美实现："></a>完美实现：</h3><p>获取Chubby锁的时候，锁包含了一个sequencer，里面有个单调递增的数字，要求<strong>资源服务器</strong>在对资源做修改的时候需要检查这个sequencer</p><p>Chubby提供了2种检查方式：</p><ul><li>调用Chubby提供的API，CheckSequencer()，将整个sequencer传进去进行检查。这个检查是为了保证客户端持有的锁在进行资源访问的时候仍然有效</li><li>将客户端传来的sequencer与资源服务器当前观察到的最新的sequencer进行对比检查</li></ul><p><strong>这种实现方式类似乐观锁，有个版本号作为控制</strong>。但是要求有个“资源服务器”能在共享资源做修改的时候检查当前的sequencer。也就是说很可能需要修改“资源服务器（比如数据库）”对共享资源的操作方式。我觉得，绝大多数的“资源服务器”都不能做这个修改，这个完美方案<strong>不太普适</strong></p><h3 id="缓解实现"><a href="#缓解实现" class="headerlink" title="缓解实现"></a>缓解实现</h3><p>获取锁的时候，同时会设置一个lock-deploy(默认一分钟)。当Chubby服务端发现客户端被动失效后，并不是立即释放锁，而是会在lock-delay指定的时间内阻止其它客户端获得这个锁。但是正常的Release操作释放的锁可以立刻被再次获取</p><p><strong>这种方式相当于牺牲了一定的可用性换来更普适的使用场景</strong></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>google Chubby的做法貌似更加优雅一点，提供了足够的方案，把选择权留给了使用者。使用者可以根据特定的场景选择特定的解决方案。</p><p>但是Chubby没有开源，非常可惜。我们只能借鉴其思想。</p><blockquote><p>个人觉得zookeeper完全可以借鉴Chubby的做法，获取锁的时候同样设置lock-deloy或者使用节点序列号作为Chubby中的sequencer，对共享资源的操作可以原子的比较sequencer</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>基于场景1的分布式锁（即为了效率），使用单点的redis已经足够了，简单高效。</li><li>基于场景2的分布式锁（即为了正确性），基于zookeeper已经比较适合，能够满足比redis有更好的正确性，但也无法做到绝对的正确。</li><li>基于场景2的分布式锁（即为了正确性），并且需要绝对的正确，需要定制zookeeper与“资源服务器”</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司使用基于redis setNX的分布式锁偶现失效，对此深入研究一番&lt;/p&gt;
&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;大体来说，分布式锁的场景有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了效率：相当于去重，避免各个系统做重复的事情。比如重复发送一封email&lt;/li&gt;
&lt;li&gt;为了正确性：不允许出现任何的失效，不然就可能造成数据不一致&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;基于单节点的redis实现&quot;&gt;&lt;a href=&quot;#基于单节点的redis实现&quot; class=&quot;headerlink&quot; title=&quot;基于单节点的redis实现&quot;&gt;&lt;/a&gt;基于单节点的redis实现&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为什么强调单节点？因为我们就一个redis主从，没有redis集群。而且redis有官方的分布式锁redlock是基于redis集群的，这个对我们不适用，而且感觉有点过重。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们一开始的方案是基于setNX(key,value,timeout)。后来发现原来这是jedis的封装，这其实是2个redis命令&lt;code&gt;：setnx+expire&lt;/code&gt;。也就是说&lt;strong&gt;这不是个原子操作，很可能setnx成功，但是设置过期时间失败导致锁永远无法释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;翻看redlock的套路才知道，应该这样操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取锁：&lt;code&gt;set key randomValue NX PX 3000&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redis的set操作有NX(if not exist)选项和PX(过期时间)选项，可以实现原子操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;释放锁：需要使用LUA脚本实现复合操作的原子性：&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(1) get key&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(2) 比较random value&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(3) random value一致即删除key&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="distributed lock" scheme="https://zacard.net/tags/distributed-lock/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq源码阅读之message发送</title>
    <link href="https://zacard.net/2018/03/18/rocketmq-1-send-message/"/>
    <id>https://zacard.net/2018/03/18/rocketmq-1-send-message/</id>
    <published>2018-03-18T07:43:31.000Z</published>
    <updated>2018-03-18T10:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>基于rocketmq 4.2.0</strong></p><blockquote><p>先不关注顺序消息和事务消息，后面独立看。</p></blockquote><h2 id="发送消息入口"><a href="#发送消息入口" class="headerlink" title="发送消息入口"></a>发送消息入口</h2><p><code>DefaultMQProducer#send(Message)</code></p><p>默认的是同步发送。最终调用的是<code>DefaultMQProducerImpl#sendDefaultImpl</code>，直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(</span></span></div><div class="line">    Message msg,</div><div class="line">    <span class="keyword">final</span> CommunicationMode communicationMode,</div><div class="line">    <span class="keyword">final</span> SendCallback sendCallback,</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> timeout</div><div class="line">) <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 确保producer已经启动</span></div><div class="line">    <span class="keyword">this</span>.makeSureStateOK();</div><div class="line">    <span class="comment">// 校验message，例如topic不能为空</span></div><div class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</div><div class="line"></div><div class="line">    <span class="comment">// 目前来看，仅在日志输出时标示此次调用</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</div><div class="line">    <span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</div><div class="line">    <span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</div><div class="line">    <span class="keyword">long</span> endTimestamp = beginTimestampFirst;</div><div class="line"></div><div class="line">    <span class="comment">// 获取topic发布路由信息 -- 会先尝试缓存中获取，其次从namesrv中获取</span></div><div class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</div><div class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</div><div class="line">        MessageQueue mq = <span class="keyword">null</span>;</div><div class="line">        Exception exception = <span class="keyword">null</span>;</div><div class="line">        SendResult sendResult = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 同步发送默认重试3次</span></div><div class="line">        <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</div><div class="line">        String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</div><div class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</div><div class="line">            String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</div><div class="line">            <span class="comment">/*</span></div><div class="line">                * 选择一个消息队列</div><div class="line">                * 规则：1）默认情况，不开启发送的延迟容错策略时，RoundRobin形式的选择一个不属于上一次发送的broker队列</div><div class="line">                *      2）开启延迟容错策略时：</div><div class="line">                *          2.1）优先从上一次的发送的broker中RoundRobin形式选择一个可用队列</div><div class="line">                *          2.2）其次按照可用性排名（是否可用&gt;延迟时间&gt;开始时间）从前半数中RoundRobin选</div><div class="line">                *          2.3）最次，啥都不管，RoundRobin选</div><div class="line">                */</div><div class="line">            MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</div><div class="line">            <span class="keyword">if</span> (mqSelected != <span class="keyword">null</span>) &#123;</div><div class="line">                mq = mqSelected;</div><div class="line">                brokersSent[times] = mq.getBrokerName();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    beginTimestampPrev = System.currentTimeMillis();</div><div class="line">                    <span class="comment">// 核心消息投递方法</span></div><div class="line">                    sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</div><div class="line">                    endTimestamp = System.currentTimeMillis();</div><div class="line">                    <span class="comment">// 更新延迟容错信息</span></div><div class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">switch</span> (communicationMode) &#123;</div><div class="line">                        <span class="keyword">case</span> ASYNC:</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">case</span> ONEWAY:</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">case</span> SYNC:</div><div class="line">                            <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</div><div class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</div><div class="line">                                    <span class="keyword">continue</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="keyword">return</span> sendResult;</div><div class="line">                        <span class="keyword">default</span>:</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</div><div class="line">                    <span class="comment">// ...省略部分代码</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// ...省略部分代码</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol><li><p><code>final long invokeID = random.nextLong();</code></p><p> 这个invokeID仅在日志输出时标示此次调用，却可能造成性能问题。共享的random虽然是线程安全的，但是每次调用都需要循环cas操作来替换每次的随机种子，高并发下，可能造成线程饥饿</p><p> 这里建议JDK7及以上使用<code>ThreadLocalRandom</code>代替。（不过RocketMQ可能是因为要兼容jdk6才没有用，不过我仍然觉得即使jdk6没有现成的类，也应该自己设计一个类似的类，追求性能的路上没有终点~）</p></li></ol><h2 id="如何选择一个消息队列"><a href="#如何选择一个消息队列" class="headerlink" title="如何选择一个消息队列"></a>如何选择一个消息队列</h2><p>最终由<code>MQFaultStrategy#selectOneMessageQueue</code>处理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 优先从上一次的发送的broker中RoundRobin形式选择一个可用队列</span></div><div class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</div><div class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</div><div class="line">                    pos = <span class="number">0</span>;</div><div class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</div><div class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</div><div class="line">                        <span class="keyword">return</span> mq;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 其次按照可用性排名（是否可用&gt;延迟时间&gt;开始时间）从前半数中RoundRobin选</span></div><div class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</div><div class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</div><div class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</div><div class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</div><div class="line">                    mq.setBrokerName(notBestBroker);</div><div class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> mq;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                latencyFaultTolerance.remove(notBestBroker);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 最次，啥都不管，直接RoundRobin选</span></div><div class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 默认情况，不开启发送的延迟容错策略时，RoundRobin形式的选择一个不属于上一次发送的broker队列</span></div><div class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结选择规则"><a href="#总结选择规则" class="headerlink" title="总结选择规则"></a>总结选择规则</h3><ol><li>默认情况，不开启发送的延迟容错策略时，RoundRobin形式的选择一个不属于上一次发送的broker队列</li><li>开启延迟容错策略时：<ol><li>优先从上一次的发送的broker中RoundRobin形式选择一个可用队列</li><li>其次按照可用性排名（是否可用&gt;延迟时间&gt;开始时间）从前半数中RoundRobin选</li><li>最次，啥都不管，直接RoundRobin选</li></ol></li></ol><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>个人感觉这块代码不够整洁。先看以下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class="line">    <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</div><div class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</div><div class="line">        pos = <span class="number">0</span>;</div><div class="line"><span class="comment">// 省略其他代码</span></div></pre></td></tr></table></figure><p>同时看下tpInfo.getSendWhichQueue().getAndIncrement()具体的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</div><div class="line">    Integer index = <span class="keyword">this</span>.threadLocalIndex.get();</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == index) &#123;</div><div class="line">        index = Math.abs(random.nextInt());</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</div><div class="line">            index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.threadLocalIndex.set(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    index = Math.abs(index + <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</div><div class="line">        index = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.threadLocalIndex.set(index);</div><div class="line">    <span class="keyword">return</span> index;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有2个问题：</p><ul><li><code>Math.abs(index++)</code>这操作绝大多数情况下没有必要的，因为<code>getAndIncrement()</code>保证了其为正数。只有当在循环体内，且index取值为<code>[Integer.MAX_VALUE-tpInfo.getMessageQueueList().size(),Integer.MAX_VALUE]</code>才可能需要，同时后面的<code>if (pos &lt; 0)</code>也是如此。</li><li>pos没有回设到Threadlocal中，导致会有那么几次选择的是同一个消息队列，不过这个倒是影响不大。RocketMQ可能是为了性能考虑。</li></ul><p>个人觉得这段直接使用getAndIncrement会更简洁明确一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class="line">    <span class="keyword">int</span> pos = tpInfo.getSendWhichQueue().getAndIncrement() % tpInfo.getMessageQueueList().size();</div><div class="line">    MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</div><div class="line">    <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName)) &#123;</div><div class="line">            <span class="keyword">return</span> mq;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 剩余代码省略</span></div></pre></td></tr></table></figure><p>可以看到，精简之后，出现了对同一个对象连续调用了其实例方法，感觉有点混乱。其实这里本质就是从上一个发送成功的broker选择队列，为何要独立到<code>MQFaultStrategy</code>中呢？可以仍然由TopicPublishInfo直接出一个方法<code>selectMessageQueueWithBroker</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueueWithBroker</span><span class="params">(String lastBrokerName)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = messageQueueList.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">int</span> pos = sendWhichQueue.getAndIncrement() % size;</div><div class="line">        MessageQueue mq = messageQueueList.get(pos);</div><div class="line">        <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span> || mq.getBrokerName().equals(lastBrokerName)) &#123;</div><div class="line">            <span class="keyword">return</span> mq;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>进一步思考，选择一个消息队列的时候，由一个延迟容错的策略类(<code>MQFaultStrategy</code>)代理，然后基本所有的选择逻辑又都在topic路由类(<code>TopicPublishInfo</code>)中。总感觉有点奇怪。</p><blockquote><p>个人想法: <code>MQFaultStrategy</code>应该设计为由<code>MessageQueueSelector</code>和<code>SendMessageHook</code>组合实现，这样就能和<code>DefaultMQProducerImpl#send(Message msg, MessageQueueSelector selector, Object arg)</code>统一，流程一致。</p><p>目前是<code>MQFaultStrategy</code>强耦合到了默认的消息发送流程中，一方面这个策略类难以被替换，另一方面，和其他重载的的消息发送方法流程不太一致</p></blockquote><h2 id="核心消息发送方法"><a href="#核心消息发送方法" class="headerlink" title="核心消息发送方法"></a>核心消息发送方法</h2><p>调用的是<code>DefaultMQProducerImpl#sendKernelImpl</code>，直接看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></div><div class="line">    <span class="keyword">final</span> MessageQueue mq,</div><div class="line">    <span class="keyword">final</span> CommunicationMode communicationMode,</div><div class="line">    <span class="keyword">final</span> SendCallback sendCallback,</div><div class="line">    <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> timeout) <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 获取broker地址</span></div><div class="line">    String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</div><div class="line">        tryToFindTopicPublishInfo(mq.getTopic());</div><div class="line">        brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SendMessageContext context = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 是否使用broker vip通道,broker会开启两个端口对外服务</span></div><div class="line">        brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] prevBody = msg.getBody();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 设置消息唯一id</span></div><div class="line">            <span class="comment">//for MessageBatch,ID has been set in the generating process</span></div><div class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</div><div class="line">                <span class="comment">// 唯一id生成逻辑：pid+ip+ClassLoader.hashCode+(当前时间-开始时间)+递增数</span></div><div class="line">                MessageClientIDSetter.setUniqID(msg);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 消息压缩</span></div><div class="line">            <span class="keyword">int</span> sysFlag = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</div><div class="line">                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 事务消息</span></div><div class="line">            <span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class="line">            <span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</div><div class="line">                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 钩子：检查是否允许发送消息的扩展点</span></div><div class="line">            <span class="keyword">if</span> (hasCheckForbiddenHook()) &#123;</div><div class="line">                CheckForbiddenContext checkForbiddenContext = <span class="keyword">new</span> CheckForbiddenContext();</div><div class="line">                checkForbiddenContext.setNameSrvAddr(<span class="keyword">this</span>.defaultMQProducer.getNamesrvAddr());</div><div class="line">                checkForbiddenContext.setGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</div><div class="line">                checkForbiddenContext.setCommunicationMode(communicationMode);</div><div class="line">                checkForbiddenContext.setBrokerAddr(brokerAddr);</div><div class="line">                checkForbiddenContext.setMessage(msg);</div><div class="line">                checkForbiddenContext.setMq(mq);</div><div class="line">                checkForbiddenContext.setUnitMode(<span class="keyword">this</span>.isUnitMode());</div><div class="line">                <span class="keyword">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 钩子：发送消息前的扩展点</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context = <span class="keyword">new</span> SendMessageContext();</div><div class="line">                context.setProducer(<span class="keyword">this</span>);</div><div class="line">                context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</div><div class="line">                context.setCommunicationMode(communicationMode);</div><div class="line">                context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</div><div class="line">                context.setBrokerAddr(brokerAddr);</div><div class="line">                context.setMessage(msg);</div><div class="line">                context.setMq(mq);</div><div class="line">                String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class="line">                <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</div><div class="line">                    context.setMsgType(MessageType.Trans_Msg_Half);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</div><div class="line">                    context.setMsgType(MessageType.Delay_Msg);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookBefore(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 构建发送消息请求</span></div><div class="line">            SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</div><div class="line">            requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</div><div class="line">            requestHeader.setTopic(msg.getTopic());</div><div class="line">            requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</div><div class="line">            requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</div><div class="line">            requestHeader.setQueueId(mq.getQueueId());</div><div class="line">            requestHeader.setSysFlag(sysFlag);</div><div class="line">            requestHeader.setBornTimestamp(System.currentTimeMillis());</div><div class="line">            requestHeader.setFlag(msg.getFlag());</div><div class="line">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class="line">            requestHeader.setReconsumeTimes(<span class="number">0</span>);</div><div class="line">            requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</div><div class="line">            requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</div><div class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class="line">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</div><div class="line">                <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</div><div class="line">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</div><div class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</div><div class="line">                <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</div><div class="line">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</div><div class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 发送消息，这里真正要调用网络层发送消息</span></div><div class="line">            SendResult sendResult = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</div><div class="line">                <span class="keyword">case</span> ASYNC:</div><div class="line">                    <span class="comment">// 整整12个入参...</span></div><div class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</div><div class="line">                        brokerAddr,</div><div class="line">                        mq.getBrokerName(),</div><div class="line">                        msg,</div><div class="line">                        requestHeader,</div><div class="line">                        timeout,</div><div class="line">                        communicationMode,</div><div class="line">                        sendCallback,</div><div class="line">                        topicPublishInfo,</div><div class="line">                        <span class="keyword">this</span>.mQClientFactory,</div><div class="line">                        <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</div><div class="line">                        context,</div><div class="line">                        <span class="keyword">this</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> ONEWAY:</div><div class="line">                <span class="keyword">case</span> SYNC:</div><div class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</div><div class="line">                        brokerAddr,</div><div class="line">                        mq.getBrokerName(),</div><div class="line">                        msg,</div><div class="line">                        requestHeader,</div><div class="line">                        timeout,</div><div class="line">                        communicationMode,</div><div class="line">                        context,</div><div class="line">                        <span class="keyword">this</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 钩子：消息发送后的扩展点</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context.setSendResult(sendResult);</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> sendResult;</div><div class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context.setException(e);</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context.setException(e);</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context.setException(e);</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            msg.setBody(prevBody);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// broker地址为空抛出异常</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The broker["</span> + mq.getBrokerName() + <span class="string">"] not exist"</span>, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h3><p>这里感觉最大的问题就是api和spi没有分离好。</p><ol><li><p>扩展点(hook)不一致：有<code>CheckForbiddenHook</code>和<code>SendMessageHook</code>这2个hook，目前看<code>CheckForbiddenHook</code>完全可以由<code>SendMessageHook#sendMessageBefore</code>实现</p><blockquote><p>可以定义一个发送消息的流程类SendMessageProcesser,定义消息发送的流程。然后定义一个一致的hook类，比如ProducerHook。然后出个注解定义hook类型(before或者after)，在流程类中对ProducerHook组装</p></blockquote></li><li><p>扩展点(hook)设置略显简陋：hook设置是通过<code>DefaultMQProducerImpl#registerXXXHook</code>方法add到一个ArrayList中的,这样一方面sdk使用者这法明确添加hook的执行顺序，一方面不能精细设置某个hook必须要在某个hook之前或之后调用</p><blockquote><p>可以出个注解定义顺序，然后使用类似TreeSet来排序</p></blockquote></li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><strong>里面的思考都是基于个人初步阅读源码这个前提的看法，欢迎各位大神斧正！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基于rocketmq 4.2.0&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先不关注顺序消息和事务消息，后面独立看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;发送消息入口&quot;&gt;&lt;a href=&quot;#发送消息入口&quot; class=&quot;headerlink&quot; title=&quot;发送消息入口&quot;&gt;&lt;/a&gt;发送消息入口&lt;/h2&gt;&lt;p&gt;&lt;code&gt;DefaultMQProducer#send(Message)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认的是同步发送。最终调用的是&lt;code&gt;DefaultMQProducerImpl#sendDefaultImpl&lt;/code&gt;，直接看代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; SendResult &lt;span class=&quot;title&quot;&gt;sendDefaultImpl&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Message msg,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; CommunicationMode communicationMode,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SendCallback sendCallback,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeout&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; MQClientException, RemotingException, MQBrokerException, InterruptedException &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 确保producer已经启动&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.makeSureStateOK();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 校验message，例如topic不能为空&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Validators.checkMessage(msg, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.defaultMQProducer);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 目前来看，仅在日志输出时标示此次调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; invokeID = random.nextLong();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; beginTimestampFirst = System.currentTimeMillis();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; beginTimestampPrev = beginTimestampFirst;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; endTimestamp = beginTimestampFirst;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取topic发布路由信息 -- 会先尝试缓存中获取，其次从namesrv中获取&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TopicPublishInfo topicPublishInfo = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tryToFindTopicPublishInfo(msg.getTopic());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (topicPublishInfo != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; topicPublishInfo.ok()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        MessageQueue mq = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Exception exception = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        SendResult sendResult = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 同步发送默认重试3次&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; timesTotal = communicationMode == CommunicationMode.SYNC ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.defaultMQProducer.getRetryTimesWhenSendFailed() : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; times = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        String[] brokersSent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[timesTotal];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (; times &amp;lt; timesTotal; times++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String lastBrokerName = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; == mq ? &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; : mq.getBrokerName();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;/*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                * 选择一个消息队列&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                * 规则：1）默认情况，不开启发送的延迟容错策略时，RoundRobin形式的选择一个不属于上一次发送的broker队列&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                *      2）开启延迟容错策略时：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                *          2.1）优先从上一次的发送的broker中RoundRobin形式选择一个可用队列&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                *          2.2）其次按照可用性排名（是否可用&amp;gt;延迟时间&amp;gt;开始时间）从前半数中RoundRobin选&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                *          2.3）最次，啥都不管，RoundRobin选&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            MessageQueue mqSelected = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.selectOneMessageQueue(topicPublishInfo, lastBrokerName);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mqSelected != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                mq = mqSelected;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                brokersSent[times] = mq.getBrokerName();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    beginTimestampPrev = System.currentTimeMillis();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 核心消息投递方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    sendResult = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    endTimestamp = System.currentTimeMillis();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 更新延迟容错信息&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (communicationMode) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ASYNC:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ONEWAY:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; SYNC:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sendResult.getSendStatus() != SendStatus.SEND_OK) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                    &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sendResult;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (RemotingException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// ...省略部分代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...省略部分代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...省略部分代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="rocketmq" scheme="https://zacard.net/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>分布式追踪系统x-apm拾遗之伪共享与缓存行填充</title>
    <link href="https://zacard.net/2018/02/26/false-share/"/>
    <id>https://zacard.net/2018/02/26/false-share/</id>
    <published>2018-02-26T12:03:18.000Z</published>
    <updated>2018-02-26T13:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前开发分布式追踪系统x-apm的时候，确认了2个目标：</p><ol><li>x-apm的异常绝不能影响业务系统</li><li>x-apm应该尽可能的少暂用系统资源的前提下，尽可能的快(实时)</li></ol><p>针对第2点，用来暂存追踪数据的数据结构碰到了伪共享的问题，导致收集发送的效率不够高，所以使用的缓存行填充。</p><p>这里记录下伪共享和缓存行填充的相关内容。</p><h2 id="基础简介"><a href="#基础简介" class="headerlink" title="基础简介"></a>基础简介</h2><h3 id="cpu-cache"><a href="#cpu-cache" class="headerlink" title="cpu cache"></a>cpu cache</h3><p>一个典型的cpu cache架构：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/cachelinepad-1.png" alt=""></p><p>访问速度：寄存器&lt;L1 cache&lt;L2 cache&lt;L3 cache&lt;主存</p><p>所以，充分利用它的结构和机制，可以有效的提高程序的性能</p><p><strong>这里需要注意：一个cpu中的多核共享L3 cache,而L1、L2 cache是每个核心各自拥有的;一个缓存行一般缓存64byte大小的数据</strong></p><a id="more"></a><h3 id="cpu缓存一致性协议-MESI"><a href="#cpu缓存一致性协议-MESI" class="headerlink" title="cpu缓存一致性协议 - MESI"></a>cpu缓存一致性协议 - MESI</h3><p>在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是： </p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>M(Modified)</td><td>这行数据有效，数据被修改了，和主存冲的数据不一致，数据只存在本Cache中</td></tr><tr><td>E(Exclusive)</td><td>这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中</td></tr><tr><td>S(Shard)</td><td>这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中</td></tr><tr><td>I(Invalid)</td><td>这行数据无效</td></tr></tbody></table><h4 id="MESI协议中的状态"><a href="#MESI协议中的状态" class="headerlink" title="MESI协议中的状态"></a>MESI协议中的状态</h4><ul><li><p>M: 被修改（Modified)</p><p>  该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。</p><p>  当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。</p></li><li><p>E: 独享的（Exclusive)</p><p>  该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。</p><p>  同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。</p></li><li><p>S: 共享的（Shared)</p><p>  该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，</p><p>  其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。</p></li><li><p>I: 无效的 (Invalid)</p><p>  该缓存行数据无效。</p></li></ul><p>M(Modified)和E(Exclusive)状态的Cache line，数据是独有的，不同点在于M状态的数据是dirty的(和内存的不一致)，E状态的数据是clean的(和内存的一致)。</p><p>S(Shared)状态的Cache line，数据和其他Core的Cache共享。只有clean的数据才能被多个Cache共享。</p><p>一个缓存除在Invalid状态外都可以满足cpu的读请求，一个invalid的缓存行必须从主存中读取（变成S或者E状态）来满足该CPU的读请求</p><h3 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h3><p>数据在缓存中不是以独立的项来存储的，如不是一个单独的变量，也不是一个单独的指针。缓存是由缓存行组成的，通常是64字节，并且它有效地引用主内存中的一块地址。一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。</p><p>当缓存行加载数据的时候，会同时加载其后连续的一部分数据。所以你可以非常快速的遍历在连续的内存块中分配的任意数据结构。因此如果你数据结构中的项在内存中不是彼此相邻的（比如链表），你将得不到免费缓存加载所带来的优势。并且在这些数据结构中的每一个项都可能会出现缓存未命中</p><h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><p>伪共享就是2个不同的数据恰好被加载到同一个缓存行中，不同cpu的核分别去修改该缓存行中的不同数据，却导致了相互竞争同一个缓存行。例如以下例子：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/cacheline-2.png" alt=""></p><p>数据X、Y、Z被加载到同一Cache Line中，线程A在Core1修改X，线程B在Core2上修改Y。根据MESI大法，假设是Core1是第一个发起操作的CPU核，Core1上的L1 Cache Line由S（共享）状态变成M（修改，脏数据）状态，然后告知其他的CPU核，图例则是Core2，引用同一地址的Cache Line已经无效了；当Core2发起写操作时，首先导致Core1将X写回主存，Cache Line状态由M变为I（无效），而后才是Core2从主存重新读取该地址内容，Cache Line状态由I变成E（独占），最后进行修改Y操作， Cache Line从E变成M。可见多个线程操作在同一Cache Line上的不同数据，相互竞争同一Cache Line，导致线程彼此牵制影响，变成了串行程序，降低了并发性。</p><h2 id="缓存行填充"><a href="#缓存行填充" class="headerlink" title="缓存行填充"></a>缓存行填充</h2><p>一般解决伪共享的方式就是缓存行填充，将频繁写的变量填充到64byte，不和其他变量加载到同一个缓存行即可。</p><p>例如以下代码：(参考Disruptor作者的博客改写而来)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharingTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WIRTER_NUMBER = <span class="number">800_000_000L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PaddedLong[] ARRAY = <span class="keyword">new</span> PaddedLong[<span class="number">4</span>];</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingLong</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6 = <span class="number">7L</span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 阻止jvm优化掉无用的字段</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">preventOptimisation</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> p1 + p2 + p3 + p4 + p5 + p6;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedLong</span> <span class="keyword">extends</span> <span class="title">PaddingLong</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                ARRAY[index] = <span class="keyword">new</span> PaddedLong();</div><div class="line">                <span class="keyword">long</span> count = WIRTER_NUMBER;</div><div class="line">                <span class="keyword">while</span> (count-- != <span class="number">0</span>) &#123;</div><div class="line">                    ARRAY[index].value = count;</div><div class="line">                &#125;</div><div class="line">                countDownLatch.countDown();</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        countDownLatch.await();</div><div class="line">        System.out.println(<span class="string">"耗时："</span> + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PaddedLong不继承PaddingLong的时候，即没有使用缓存行填充，程序执行时间甚至2倍于填充后</p><p>JDK8后更智能，可以直接使用@sun.misc.Contended来标注需要填充的字段或者类（标注类表示，类中的所有字段都需要填充）。注意，jvm需要添加参数-XX:-RestrictContended才能开启此功能</p><p>例如JDK8中的ConcurrentHashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// ConcurrentHashMap.java line:2506</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A padded cell for distributing counts.  Adapted from LongAdder</div><div class="line">     * and Striped64.  See their internal docs for explanation.</div><div class="line">     */</div><div class="line">    <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</div><div class="line">        CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>@sun.misc.Contended虽然很智能，但是需要jvm开启特定参数。对于中间件产品来说可能手动填充更合适。请看以下常见填充方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingLong</span> </span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6 = <span class="number">7L</span>;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * 阻止jvm优化掉无用的字段</div><div class="line">      */</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">preventOptimisation</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> p1 + p2 + p3 + p4 + p5 + p6;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedLong</span> <span class="keyword">extends</span> <span class="title">PaddingLong</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>以上是参考Disruptor作者的填充方式，也是很多开源产品的填充方式。</p><p>作者只填充了6个long变量，也就是PaddedLong实例对象的内存占用大小为：<code>16(对象头大小)+6*8(填充变量大小)+1*8(被填充变量大小)=72byte&gt;64byte</code></p><p>可以使用JOL工具(<a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="external">下载传送门</a>)查看对象内存布局来验证我们的预想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ java -jar ~/tools/jol-cli-0.9-full.jar internals -cp algorithm-1.0-SNAPSHOT.jar com.zacard.algorithm.test.falseshare.PaddedLong</div><div class="line"></div><div class="line">$ com.zacard.algorithm.test.falseshare.PaddedLong object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           44 08 02 f8 (01000100 00001000 00000010 11111000) (-134084540)</div><div class="line">     12     4        (alignment/padding gap)</div><div class="line">     16     8   long PaddingLong.p1                            0</div><div class="line">     24     8   long PaddingLong.p2                            0</div><div class="line">     32     8   long PaddingLong.p3                            0</div><div class="line">     40     8   long PaddingLong.p4                            0</div><div class="line">     48     8   long PaddingLong.p5                            0</div><div class="line">     56     8   long PaddingLong.p6                            7</div><div class="line">     64     8   long PaddedLong.value                          0</div><div class="line">Instance size: 72 bytes</div><div class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</div></pre></td></tr></table></figure><p>可以看到填充的对象确实占用了72byte。</p><p>看一下作者的解释（<a href="https://mechanical-sympathy.blogspot.jp/2011/08/false-sharing-java-7.html" target="_blank" rel="external">传送门</a>）：</p><blockquote><p>I do not want the mark word to be in the cache line which can be modified by taking out locks or the garbage collector ageing the object</p><p>我不希望在缓存行中的对象头中的“mark word”在设置锁标记或者垃圾回收器在老化对象的时候被修改</p></blockquote><p>这里修改对象头中的锁标记应该能理解，因为当synchronized一个对象的时候，确实会修改对象头中的锁标记，这个也很可能会造成伪共享的问题。</p><p>“garbage collector ageing the object”应该指的是对象挨过一次gc存活下来，需要修改对象头中的对象年龄。</p><p>对于作者的严谨，我服…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前开发分布式追踪系统x-apm的时候，确认了2个目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x-apm的异常绝不能影响业务系统&lt;/li&gt;
&lt;li&gt;x-apm应该尽可能的少暂用系统资源的前提下，尽可能的快(实时)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对第2点，用来暂存追踪数据的数据结构碰到了伪共享的问题，导致收集发送的效率不够高，所以使用的缓存行填充。&lt;/p&gt;
&lt;p&gt;这里记录下伪共享和缓存行填充的相关内容。&lt;/p&gt;
&lt;h2 id=&quot;基础简介&quot;&gt;&lt;a href=&quot;#基础简介&quot; class=&quot;headerlink&quot; title=&quot;基础简介&quot;&gt;&lt;/a&gt;基础简介&lt;/h2&gt;&lt;h3 id=&quot;cpu-cache&quot;&gt;&lt;a href=&quot;#cpu-cache&quot; class=&quot;headerlink&quot; title=&quot;cpu cache&quot;&gt;&lt;/a&gt;cpu cache&lt;/h3&gt;&lt;p&gt;一个典型的cpu cache架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/cachelinepad-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;访问速度：寄存器&amp;lt;L1 cache&amp;lt;L2 cache&amp;lt;L3 cache&amp;lt;主存&lt;/p&gt;
&lt;p&gt;所以，充分利用它的结构和机制，可以有效的提高程序的性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意：一个cpu中的多核共享L3 cache,而L1、L2 cache是每个核心各自拥有的;一个缓存行一般缓存64byte大小的数据&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="false share" scheme="https://zacard.net/tags/false-share/"/>
    
      <category term="pad" scheme="https://zacard.net/tags/pad/"/>
    
  </entry>
  
  <entry>
    <title>分布式追踪系统x-apm开发拾遗之synthetic与bridge方法</title>
    <link href="https://zacard.net/2018/02/13/java-syntethic-and-bridge-methods/"/>
    <id>https://zacard.net/2018/02/13/java-syntethic-and-bridge-methods/</id>
    <published>2018-02-13T06:55:31.000Z</published>
    <updated>2018-02-21T15:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前开发x-apm的时候，自定义增强一个spring bean的时候，出现了一个奇怪的异常 – 找不到无参构造方法，导致bean初始化失败。原来是bytebuddy这个类库在增强类的时候，会自动增加一个synthetic的构造方法，导致spring无法找打正确的构造方法初始化。这里记录下synthetic方法和bridge方法。</p><h2 id="synthetic方法"><a href="#synthetic方法" class="headerlink" title="synthetic方法"></a>synthetic方法</h2><p>synthetic方法是什么呢？先来看个实际例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntheticTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> j + i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJ</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.j = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SyntheticTest syntheticTest = <span class="keyword">new</span> SyntheticTest();</div><div class="line">        A a = syntheticTest.new A();</div><div class="line">        a.setJ(<span class="number">1</span>);</div><div class="line">        System.out.println(<span class="string">"sum="</span> + a.sum());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>当你创建一个嵌套类（内部类）时，顶层类的私有属性和私有方法对内部类是可见的。然而jvm是如何处理这种情况的呢？jvm可不清楚什么是内部嵌套类，什么是顶层类。jvm对所有的类都一视同仁，它都认为是顶级类。所有类都会被编译成顶级类，而那些内部类编译完后会生成…$… class的类文件，如下javac编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ javac SyntheticTest.java</div><div class="line">$ ls</div><div class="line">SyntheticTest$A.class SyntheticTest.class   SyntheticTest.java</div></pre></td></tr></table></figure><p>当你创建内部类时，他会被编译成顶级类。那顶层类的私有属性和私有方法是如何被外部类访问的呢？</p><p>javac是这样解决这个问题的，对于任何private的字段，方法或者构造函数，如果它们也被其它顶层类所使用，就会生成一个<strong>synthetic方法</strong>。这些synthetic方法是用来访问最初的私有变量/方法/构造函数的。这些方法的生成也很智能：只有确实被外部类用到了，才会生成这样的方法</p><p>通过反编译SyntheticTest$A.class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntheticTest</span>$<span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> SyntheticTest$A(SyntheticTest var1) &#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.j + SyntheticTest.access$<span class="number">000</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJ</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.j = var1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有个奇怪的方法<code>SyntheticTest.access$000(this.this$0)</code>，这个就是java的synthetic方法。可以用java的反射再次验证这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Method method : SyntheticTest.class.getDeclaredMethods()) &#123;</div><div class="line">        System.out.println(method.getName() + <span class="string">" is synthetic method:"</span> + method.isSynthetic());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main is synthetic method:<span class="keyword">false</span></div><div class="line">access$<span class="number">000</span> is synthetic method:<span class="keyword">true</span></div><div class="line">setI is synthetic method:<span class="keyword">false</span></div></pre></td></tr></table></figure><p>可以看到<code>access$000</code>这个方法，确实是一个synthetic方法</p><blockquote><p><strong>synthetic方法就是java编译器(例如javac)为了实现特定需求增加的方法，不存在源码中的</strong></p></blockquote><h2 id="bridge方法"><a href="#bridge方法" class="headerlink" title="bridge方法"></a>bridge方法</h2><p>bridge方法又是什么呢？看个简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLink</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"my list "</span> + index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Method method : MyLink.class.getDeclaredMethods()) &#123;</div><div class="line">            System.out.println(method.toString() + <span class="string">" is bridge method:"</span> + method.isBridge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> java.lang.String com.zacard.algorithm.test.BridgeTest$MyLink.get(<span class="keyword">int</span>) is bridge method:<span class="keyword">false</span></div><div class="line"><span class="keyword">public</span> java.lang.Object com.zacard.algorithm.test.BridgeTest$MyLink.get(<span class="keyword">int</span>) is bridge method:<span class="keyword">true</span></div></pre></td></tr></table></figure><p>可以看到，多出来一个方法签名一致，返回类型为Object的bridge方法，这在java语言中是不合法的，不过在jvm中是允许的。那这个bridge方法到底作了什么呢？反编译看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javap -c BridgeTest\$MyLink</div></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class com.zacard.algorithm.test.BridgeTest$MyLink extends java.util.LinkedList &#123;</div><div class="line">  public com.zacard.algorithm.test.BridgeTest$MyLink();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/util/LinkedList."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public java.lang.String get(int);</div><div class="line">    Code:</div><div class="line">       0: new           #2                  // class java/lang/StringBuilder</div><div class="line">       3: dup</div><div class="line">       4: invokespecial #3                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</div><div class="line">       7: ldc           #4                  // String my list</div><div class="line">       9: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">      12: iload_1</div><div class="line">      13: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">      16: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">      19: areturn</div><div class="line"></div><div class="line">  public java.lang.Object get(int);</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: iload_1</div><div class="line">       2: invokevirtual #8                  // Method get:(I)Ljava/lang/String;</div><div class="line">       5: areturn</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，这个birdge不干别的，仅仅就是调用了原始的那个方法。所以这个方法到底有什么用,为什么需要bridge方法？看一下<a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html#bridgeMethods" target="_blank" rel="external">java手册</a>的说明：</p><blockquote><p>When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a bridge method, as part of the type erasure process. You normally don’t need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.</p><p>如果一个类继承了一个范型类或者实现了一个范型接口, 那么编译器在编译这个类的时候就会生成一个叫做桥接方法的混合方法(混合方法简单的说就是由编译器生成的方法, 方法上有synthetic修饰符), 这个方法用于范型的类型安全处理,用户一般不需要关心桥接方法</p></blockquote><p>其实是java为了泛型的向下兼容的一种手段。我们看下另一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">private</span> T data;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Node.setData"</span>);</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"MyNode.setData"</span>);</div><div class="line">            <span class="keyword">super</span>.setData(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个类在泛型擦除后，变成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> Object data;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Node.setData"</span>);</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"MyNode.setData"</span>);</div><div class="line">            <span class="keyword">super</span>.setData(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>子类的<code>setData</code>方法签名和父类的已经不一致了。因此，<code>MyNode.setData</code>方法其实已经不再重写（override）父类<code>Node.setData</code>方法了。</p><p>为了解决这个问题，并且<strong>维持泛型类在泛型擦除后的多态性，java编译器会生成一个bridge方法</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前开发x-apm的时候，自定义增强一个spring bean的时候，出现了一个奇怪的异常 – 找不到无参构造方法，导致bean初始化失败。原来是bytebuddy这个类库在增强类的时候，会自动增加一个synthetic的构造方法，导致spring无法找打正确的构造方法初始化。这里记录下synthetic方法和bridge方法。&lt;/p&gt;
&lt;h2 id=&quot;synthetic方法&quot;&gt;&lt;a href=&quot;#synthetic方法&quot; class=&quot;headerlink&quot; title=&quot;synthetic方法&quot;&gt;&lt;/a&gt;synthetic方法&lt;/h2&gt;&lt;p&gt;synthetic方法是什么呢？先来看个实际例子：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SyntheticTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setI&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.i = i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; j + i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setJ&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.j = j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        SyntheticTest syntheticTest = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SyntheticTest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        A a = syntheticTest.new A();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        a.setJ(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;sum=&quot;&lt;/span&gt; + a.sum());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="synthetic" scheme="https://zacard.net/tags/synthetic/"/>
    
      <category term="bridge" scheme="https://zacard.net/tags/bridge/"/>
    
      <category term="method" scheme="https://zacard.net/tags/method/"/>
    
  </entry>
  
  <entry>
    <title>Service Mesh - 服务网格</title>
    <link href="https://zacard.net/2018/02/12/service-mesh/"/>
    <id>https://zacard.net/2018/02/12/service-mesh/</id>
    <published>2018-02-12T12:39:22.000Z</published>
    <updated>2018-02-12T12:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是service-mesh"><a href="#什么是service-mesh" class="headerlink" title="什么是service mesh"></a>什么是service mesh</h2><blockquote><p>服务网格是一个<strong>基础设施层</strong>，功能在于处理服务间通信，职责是负责<strong>实现请求的可靠传递</strong>。在实践中，服务网格通常实现为<strong>轻量级网络代理</strong>，通常与应用程序部署在一起，但是<strong>对应用程序透明</strong></p></blockquote><p>可以将它比作是<strong>微服务</strong>间的TCP/IP，负责服务之间的网络调用、限流、熔断、监控等功能。对于编写应用程序来说一般无须关心TCP/IP这一层（比如通过HTTP协议的RESTful应用），同样使用service mesh也就无须关心服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如spring cloud，现在只要交给service mesh就可以了</p><p>另一方面，service mesh更强调由这些代理连接而形成的网络，而不仅仅是一个网络代理(sidecar)。</p><h2 id="为什么要有service-mesh"><a href="#为什么要有service-mesh" class="headerlink" title="为什么要有service mesh"></a>为什么要有service mesh</h2><p>因为，基于框架或者类库实现的<strong>网络代理</strong>存在诸多弊端</p><a id="more"></a><h3 id="内容多，门槛高"><a href="#内容多，门槛高" class="headerlink" title="内容多，门槛高"></a>内容多，门槛高</h3><p>例如spring cloud：</p><ul><li>spring-cloud-common</li><li>spring-cloud-netflix</li><li>spring-cloud-sleuth</li><li>spring-cloud-gateway</li><li>spring-cloud-bus</li><li>spring-cloud-consul</li><li>spring-cloud-config</li><li>spring-cloud-security</li><li>spring-cloud-zookeeper</li><li>spring-cloud-aws</li><li>spring-cloud-cloudfoundry</li><li>…</li></ul><p>团队成员学习并吃透这些东西，需要大量时间与精力。然而这些技术是实现微服务化的手段，真正的目标是实现业务。时间人力可能远远不足。</p><p>微服务化我们有更艰巨的挑战：微服务拆分、边界设定、设计良好的api等</p><h3 id="服务治理功能不够完善"><a href="#服务治理功能不够完善" class="headerlink" title="服务治理功能不够完善"></a>服务治理功能不够完善</h3><p>服务治理常见的功能如下：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/service-mesh-1.png" alt=""></p><p>Spring Cloud直接提供的功能是远远不够的。很多功能都需要你在Spring Cloud的基础上自己解决</p><h3 id="无法跨语言"><a href="#无法跨语言" class="headerlink" title="无法跨语言"></a>无法跨语言</h3><p>微服务一个重要的特性：就是不同的微服务可以采用最适合的编程语言来编写</p><p>然而我们的框架类库，需要提供多少语言的SDK呢？</p><h3 id="如何升级"><a href="#如何升级" class="headerlink" title="如何升级"></a>如何升级</h3><p>框架不可能一开始就完美无缺，所有功能都齐备，没有任何BUG，分发出去之后就再也不需要改动，这种理想状态不存在的。必然是1.0、2.0、3.0慢慢升级，功能逐渐增加，BUG逐渐被修复</p><p>然而使用者并不能都马上跟进升级，一旦客户端和服务器端版本不一致，就要非常小心维护兼容性</p><p>版本兼容性有多复杂？服务端数以百计起，客户端数以千计起，每个的版本都有可能不同。这是一个笛卡尔乘积。但是别忘了，还有一个前面说的编程语言的问题，你还得再乘个N！这种情况下，兼容性测试需要写多少个Case，这几乎是不可能的</p><h2 id="service-mesh演进"><a href="#service-mesh演进" class="headerlink" title="service mesh演进"></a>service mesh演进</h2><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/service-mesh-2.png" alt=""></p><p>ps:sidecar就是框架或者类库的方式</p><p>service mesh演进是一个技术栈下移的过程。形成一个独立进程，代理服务所有流量，可单独升级，对应用程序透明</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这部分基于本人对service mesh初步认知，属于个人不成熟的想法，欢迎各位大牛斧正！</p><h3 id="service-mesh有什么缺点？"><a href="#service-mesh有什么缺点？" class="headerlink" title="service mesh有什么缺点？"></a>service mesh有什么缺点？</h3><p>个人觉得，相比较框架或者类库的形式，service mesh还是有部分不好实现的功能：</p><ol><li><p>熔断后的回落：<br> 例如，service mesh熔断后的回落操作就比较局限。对于service mesh来说，服务故障的真实原因是隐蔽的，服务调用端可能只能捕获调用异常和约定来处理。而基于框架或者类库，我们有更多可选择的优雅降级方式：返回缓存值、返回缺省值甚至去调用其他不同的服务</p></li><li><p>分布式追踪系统(APM)不能精细控制到本地方法级</p></li></ol><h3 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h3><p>语言兼容与代码级精细控制，本身就是一个矛盾点。相比service mesh提供的便利，其缺点可以忽略不计</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://dockone.io/article/2801" target="_blank" rel="external">Service Mesh：下一代微服务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是service-mesh&quot;&gt;&lt;a href=&quot;#什么是service-mesh&quot; class=&quot;headerlink&quot; title=&quot;什么是service mesh&quot;&gt;&lt;/a&gt;什么是service mesh&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;服务网格是一个&lt;strong&gt;基础设施层&lt;/strong&gt;，功能在于处理服务间通信，职责是负责&lt;strong&gt;实现请求的可靠传递&lt;/strong&gt;。在实践中，服务网格通常实现为&lt;strong&gt;轻量级网络代理&lt;/strong&gt;，通常与应用程序部署在一起，但是&lt;strong&gt;对应用程序透明&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以将它比作是&lt;strong&gt;微服务&lt;/strong&gt;间的TCP/IP，负责服务之间的网络调用、限流、熔断、监控等功能。对于编写应用程序来说一般无须关心TCP/IP这一层（比如通过HTTP协议的RESTful应用），同样使用service mesh也就无须关心服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如spring cloud，现在只要交给service mesh就可以了&lt;/p&gt;
&lt;p&gt;另一方面，service mesh更强调由这些代理连接而形成的网络，而不仅仅是一个网络代理(sidecar)。&lt;/p&gt;
&lt;h2 id=&quot;为什么要有service-mesh&quot;&gt;&lt;a href=&quot;#为什么要有service-mesh&quot; class=&quot;headerlink&quot; title=&quot;为什么要有service mesh&quot;&gt;&lt;/a&gt;为什么要有service mesh&lt;/h2&gt;&lt;p&gt;因为，基于框架或者类库实现的&lt;strong&gt;网络代理&lt;/strong&gt;存在诸多弊端&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="service mesh" scheme="https://zacard.net/tags/service-mesh/"/>
    
  </entry>
  
  <entry>
    <title>分布式追踪系统x-apm开发拾遗之javaagent</title>
    <link href="https://zacard.net/2018/02/09/apm-lost-1/"/>
    <id>https://zacard.net/2018/02/09/apm-lost-1/</id>
    <published>2018-02-09T13:52:22.000Z</published>
    <updated>2018-02-09T13:52:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>x-apm开发周期比较短，开发过程中用到的一些知识点没有深入理解，这里记录下apm用到的入口知识点 – <code>javaagent</code></p><h2 id="什么是javaagent"><a href="#什么是javaagent" class="headerlink" title="什么是javaagent"></a>什么是javaagent</h2><p>javaagent是Java中用来增强JVM上的应用的一种方式，这样的agent有机会修改目标应用或者应用所运行的环境。它可通过访问Java Instrumentation API来修改目标应用程序的class字节码</p><h2 id="为什么要有javaagent"><a href="#为什么要有javaagent" class="headerlink" title="为什么要有javaagent"></a>为什么要有javaagent</h2><ol><li>暴露一些特定功能。比如运行时<strong>获得所有已加载类的字节码</strong></li><li>对于特定类做低侵入甚至无侵入的增强。比如对某个类的某个方法插入特定逻辑</li></ol><p>所以，javaagent的主要功能其实类似aop，但是其原理是<strong>加载class文件之前做拦截，直接修改字节码，或者运行时动态修改字节码</strong>；而aop是生成一个新的代理类</p><a id="more"></a><h2 id="如何编写javaagent"><a href="#如何编写javaagent" class="headerlink" title="如何编写javaagent"></a>如何编写javaagent</h2><p>核心api：<code>java.lang.instrument.Instrumentation</code></p><p><code>Instrumentation</code>其中一个优点就是能够让我们注册ClassFileTransformers。一个已注册的<code>ClassFileTransformer</code>将拦截所有应用程序类的加载，并能够访问他们的字节码。同时，也可以修改类的字节码</p><p>入口是一个premain方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaAgentTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</div><div class="line">        <span class="comment">// 仅仅只是保存了字节码到本地文件</span></div><div class="line">        instrumentation.addTransformer((loader, className, classBeingRedefined, protectionDomain, classfileBuffer) -&gt; &#123;</div><div class="line">            Path path = Paths.get(<span class="string">"classes/"</span> + className + <span class="string">".class"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Files.write(path, classfileBuffer);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> classfileBuffer;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>启动：<code>java -javaagent:/path/to/agent.jar -jar app.jar</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;x-apm开发周期比较短，开发过程中用到的一些知识点没有深入理解，这里记录下apm用到的入口知识点 – &lt;code&gt;javaagent&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是javaagent&quot;&gt;&lt;a href=&quot;#什么是javaagent&quot; class=&quot;headerlink&quot; title=&quot;什么是javaagent&quot;&gt;&lt;/a&gt;什么是javaagent&lt;/h2&gt;&lt;p&gt;javaagent是Java中用来增强JVM上的应用的一种方式，这样的agent有机会修改目标应用或者应用所运行的环境。它可通过访问Java Instrumentation API来修改目标应用程序的class字节码&lt;/p&gt;
&lt;h2 id=&quot;为什么要有javaagent&quot;&gt;&lt;a href=&quot;#为什么要有javaagent&quot; class=&quot;headerlink&quot; title=&quot;为什么要有javaagent&quot;&gt;&lt;/a&gt;为什么要有javaagent&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;暴露一些特定功能。比如运行时&lt;strong&gt;获得所有已加载类的字节码&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于特定类做低侵入甚至无侵入的增强。比如对某个类的某个方法插入特定逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，javaagent的主要功能其实类似aop，但是其原理是&lt;strong&gt;加载class文件之前做拦截，直接修改字节码，或者运行时动态修改字节码&lt;/strong&gt;；而aop是生成一个新的代理类&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="apm" scheme="https://zacard.net/tags/apm/"/>
    
      <category term="javaagent" scheme="https://zacard.net/tags/javaagent/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础 - 熵&amp;交叉熵&amp;相对熵</title>
    <link href="https://zacard.net/2018/01/28/machelearning-1-entropy/"/>
    <id>https://zacard.net/2018/01/28/machelearning-1-entropy/</id>
    <published>2018-01-28T08:36:17.000Z</published>
    <updated>2018-01-28T09:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘录自知乎：<a href="https://www.zhihu.com/question/41252833/answer/195901726" target="_blank" rel="external">https://www.zhihu.com/question/41252833/answer/195901726</a></p></blockquote><p>讨论这个问题需要从香农的信息熵开始。小明在学校玩王者荣耀被发现了，爸爸被叫去开家长会，心里悲屈的很，就想法子惩罚小明。到家后，爸爸跟小明说：既然你犯错了，就要接受惩罚，但惩罚的程度就看你聪不聪明了。这样吧，我们俩玩猜球游戏，我拿一个球，你猜球的颜色，你每猜一次，不管对错，你就一个星期不能玩王者荣耀，当然，猜对，游戏停止，否则继续猜。<strong>当然，当答案只剩下两种选择时，此次猜测结束后，无论猜对猜错都能100%确定答案，无需再猜一次，此时游戏停止（因为好多人对策略１的结果有疑问，所以请注意这个条件）。</strong></p><p>题目1：爸爸拿来一个箱子，跟小明说：里面有橙、紫、蓝及青四种颜色的小球任意个，各颜色小球的占比不清楚，现在我从中拿出一个小球，你猜我手中的小球是什么颜色？为了使被罚时间最短，小明发挥出最强王者的智商，瞬间就想到了以最小的代价猜出答案，简称策略1，小明的想法是这样的。</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-001.jpg" alt=""></p><p>在这种情况下，小明什么信息都不知道，只能认为四种颜色的小球出现的概率是一样的。所以，根据策略1，1/4概率是橙色球，小明需要猜两次，1/4是紫色球，小明需要猜两次，其余的小球类似，所以小明预期的猜球次数为：<code>H = 1/4 * 2 + 1/4 * 2 + 1/4 * 2 + 1/4 * 2 = 2</code></p><a id="more"></a><p>题目2：爸爸还是拿来一个箱子，跟小明说：箱子里面有小球任意个，但其中1/2是橙色球，1/4是紫色球，1/8是蓝色球及1/8是青色球。我从中拿出一个球，你猜我手中的球是什么颜色的？小明毕竟是最强王者，仍然很快得想到了答案，简称策略2，他的答案是这样的。</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-002.jpg" alt=""></p><p>在这种情况下，小明知道了每种颜色小球的比例，比如橙色占比二分之一，如果我猜橙色，很有可能第一次就猜中了。所以，根据策略2，1/2的概率是橙色球，小明需要猜一次，1/4的概率是紫色球，小明需要猜两次，1/8的概率是蓝色球，小明需要猜三次，1/8的概率是青色球，小明需要猜三次，所以小明预期的猜题次数为：<code>H = 1/2 * 1 + 1/4 * 2 + 1/8 * 3 + 1/8 * 3=  1.75</code></p><p>题目3：其实，爸爸只想让小明意识到自己的错误，并不是真的想罚他，所以拿来一个箱子，跟小明说：里面的球都是橙色，现在我从中拿出一个，你猜我手中的球是什么颜色？最强王者怎么可能不知道，肯定是橙色，小明需要猜0次。上面三个题目表现出这样一种现象：针对特定概率为p的小球，需要猜球的次数 =  ，例如题目2中，1/4是紫色球，   = 2 次，1/8是蓝色球，   = 3次。那么，针对整个整体，预期的猜题次数为：  ，这就是信息熵，上面三个题目的预期猜球次数都是由这个公式计算而来，第一题的信息熵为2，第二题的信息熵为1.75，最三题的信息熵为<code>1 *  = 0</code> 。</p><blockquote><p>那么信息熵代表着什么含义呢？<strong>信息熵代表的是随机变量或整个系统的不确定性，熵越大，随机变量或系统的不确定性就越大</strong>。</p></blockquote><p>题目1的熵 &gt; 题目2的熵 &gt; 题目3的熵。在题目1中，小明对整个系统一无所知，只能假设所有的情况出现的概率都是均等的，此时的熵是最大的。</p><p>题目2中，小明知道了橙色小球出现的概率是1/2及其他小球各自出现的概率，说明小明对这个系统有一定的了解，所以系统的不确定性自然会降低，所以熵小于2。</p><p>题目3中，小明已经知道箱子中肯定是橙色球，爸爸手中的球肯定是橙色的，因而整个系统的不确定性为0，也就是熵为0。</p><p>所以，在什么都不知道的情况下，熵会最大，针对上面的题目1~~题目3，这个最大值是2，除此之外，其余的任何一种情况，熵都会比2小。所以，每一个系统都会有一个真实的概率分布，也叫真实分布，题目1的真实分布为（1/4，1/4，1/4，1/4），题目2的真实分布为（1/2，1/4，1/8，1/8），<strong>而根据真实分布，我们能够找到一个最优策略，以最小的代价消除系统的不确定性，而这个代价大小就是信息熵，记住，信息熵衡量了系统的不确定性，而我们要消除这个不确定性，所要付出的【最小努力】（猜题次数、编码长度等）的大小就是信息熵</strong>。</p><p>具体来讲，题目1只需要猜两次就能确定任何一个小球的颜色，题目2只需要猜测1.75次就能确定任何一个小球的颜色。现在回到题目2，假设小明只是钻石段位而已，智商没王者那么高，他使用了策略1，即</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-004.jpg" alt=""></p><p>爸爸已经告诉小明这些小球的真实分布是（1/2，1/4, 1/8，1/8），但小明所选择的策略却认为所有的小球出现的概率相同，相当于忽略了爸爸告诉小明关于箱子中各小球的真实分布，而仍旧认为所有小球出现的概率是一样的，认为小球的分布为（1/4，1/4，1/4，1/4），这个分布就是非真实分布。此时，小明猜中任何一种颜色的小球都需要猜两次，即<code>1/2 * 2 + 1/4 * 2 + 1/8 * 2 + 1/8 * 2 = 2</code>。很明显，针对题目2，使用策略1是一个坏的选择，因为需要猜题的次数增加了，从1.75变成了2，小明少玩了1.75的王者荣耀呢。因此，当我们知道根据系统的真实分布制定最优策略去消除系统的不确定性时，我们所付出的努力是最小的，但并不是每个人都和最强王者一样聪明，我们也许会使用其他的策略（非真实分布）去消除系统的不确定性，就好比如我将策略1用于题目2（原来这就是我在白银的原因）.</p><p><strong>那么，当我们使用非最优策略消除系统的不确定性，所需要付出的努力的大小我们该如何去衡量呢？</strong>这就需要引入交叉熵，其用来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力的大小。正式的讲，交叉熵的公式为：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-1.png" alt=""></p><p> ，其中<code>p_k</code>表示真实分布，<code>q_k</code>表示非真实分布。例如上面所讲的将策略1用于题目2，真实分布:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-2.png" alt=""></p><p>非真实分布:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-3.png" alt=""></p><p>交叉熵为:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-4.png" alt=""></p><p>比最优策略的1.75来得大。<strong>因此，交叉熵越低，这个策略就越好，最低的交叉熵也就是使用了真实分布所计算出来的信息熵</strong>，因为此时 <code>p_k=q_k</code> ，交叉熵 = 信息熵。</p><p><strong>这也是为什么在机器学习中的分类算法中，我们总是最小化交叉熵，因为交叉熵越低，就证明由算法所产生的策略最接近最优策略，也间接证明我们算法所算出的非真实分布越接近真实分布</strong>。</p><p>最后，我们如何去衡量不同策略之间的差异呢？这就需要用到<strong>相对熵</strong>，其用来衡量两个取值为正的函数或概率分布之间的差异，即：KL(f(x) || g(x)) = 现在，假设我们想知道某个策略和最优策略之间的差异，我们就可以用相对熵来衡量这两者之间的差异。即，相对熵 = 某个策略的交叉熵 - 信息熵（根据系统真实分布计算而得的信息熵，为最优策略），公式如下：</p><p><code>KL（p || q） = H（p，q） - H（p)</code> = <img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-5.png" alt=""></p><p>所以将策略1用于题目2，所产生的相对熵为<code>2 - 1.75 = 0.25</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘录自知乎：&lt;a href=&quot;https://www.zhihu.com/question/41252833/answer/195901726&quot;&gt;https://www.zhihu.com/question/41252833/answer/195901726&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讨论这个问题需要从香农的信息熵开始。小明在学校玩王者荣耀被发现了，爸爸被叫去开家长会，心里悲屈的很，就想法子惩罚小明。到家后，爸爸跟小明说：既然你犯错了，就要接受惩罚，但惩罚的程度就看你聪不聪明了。这样吧，我们俩玩猜球游戏，我拿一个球，你猜球的颜色，你每猜一次，不管对错，你就一个星期不能玩王者荣耀，当然，猜对，游戏停止，否则继续猜。&lt;strong&gt;当然，当答案只剩下两种选择时，此次猜测结束后，无论猜对猜错都能100%确定答案，无需再猜一次，此时游戏停止（因为好多人对策略１的结果有疑问，所以请注意这个条件）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目1：爸爸拿来一个箱子，跟小明说：里面有橙、紫、蓝及青四种颜色的小球任意个，各颜色小球的占比不清楚，现在我从中拿出一个小球，你猜我手中的小球是什么颜色？为了使被罚时间最短，小明发挥出最强王者的智商，瞬间就想到了以最小的代价猜出答案，简称策略1，小明的想法是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/shang-001.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下，小明什么信息都不知道，只能认为四种颜色的小球出现的概率是一样的。所以，根据策略1，1/4概率是橙色球，小明需要猜两次，1/4是紫色球，小明需要猜两次，其余的小球类似，所以小明预期的猜球次数为：&lt;code&gt;H = 1/4 * 2 + 1/4 * 2 + 1/4 * 2 + 1/4 * 2 = 2&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="entropy" scheme="https://zacard.net/tags/entropy/"/>
    
      <category term="machine learning" scheme="https://zacard.net/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>深度学习(deep learning)记录 - 初步概念</title>
    <link href="https://zacard.net/2018/01/12/deeplearning-1/"/>
    <id>https://zacard.net/2018/01/12/deeplearning-1/</id>
    <published>2018-01-12T12:59:17.000Z</published>
    <updated>2018-01-19T08:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/dl-1.png" alt=""></p><p>仅以此图，催眠我学习deep learning的动力！</p><blockquote><p>深度学习的实质无非如此：根据模型产生的误差调整模型中的诸多权重，直到误差不能再减少为止</p></blockquote><h2 id="Bias（偏差）-amp-Variance（方差）-amp-Error-误差-的区别"><a href="#Bias（偏差）-amp-Variance（方差）-amp-Error-误差-的区别" class="headerlink" title="Bias（偏差）&amp;Variance（方差）&amp;Error(误差)的区别"></a>Bias（偏差）&amp;Variance（方差）&amp;Error(误差)的区别</h2><p>首先<code>Error = Bias + Variance</code></p><ul><li><code>Error</code>反映的是整个模型的准确度</li><li><code>Bias</code>反映的是模型在样本上的输出与真实值之间的误差，即模型本身的<strong>精准度</strong></li><li><code>Variance</code>反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的<strong>精确性</strong></li></ul><a id="more"></a><p>在一个实际系统中，<strong>Bias与Variance往往是不能兼得的</strong>。如果要降低模型的Bias，就一定程度上会提高模型的Variance，反之亦然。造成这种现象的根本原因是，<strong>我们总是希望试图用有限训练样本去估计无限的真实数据</strong>。当我们更加相信这些数据的真实性，而忽视对模型的先验知识，就会尽量保证模型在训练样本上的准确度，这样可以减少模型的Bias。但是，这样学习到的模型，很可能会失去一定的泛化能力，从而造成<strong>过拟合</strong>，降低模型在真实数据上的表现，增加模型的不确定性。相反，如果更加相信我们对于模型的先验知识，在学习模型的过程中对模型增加更多的限制，就可以降低模型的variance，提高模型的稳定性，但也会使模型的Bias增大。<strong>Bias与Variance两者之间的trade-off(权衡)是机器学习的基本主题之一</strong>。</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/dnn-bias-variance.jpg" alt=""></p><ul><li>准：bias描述的是根据样本拟合出的模型的输出预测结果的期望与样本真实结果的差距，简单讲，就是在样本上拟合的好不好。要想在bias上表现好，low bias，就得复杂化模型，增加模型的参数，但这样容易过拟合 (overfitting)，过拟合对应上图是high variance，点很分散。low bias对应就是点都打在靶心附近，所以瞄的是准的，但手不一定稳。</li><li>确：varience描述的是样本上训练出来的模型在测试集上的表现，要想在variance上表现好，low varience，就要简化模型，减少模型的参数，但这样容易欠拟合(unfitting)，欠拟合对应上图是high bias，点偏离中心。low variance对应就是点都打的很集中，但不一定是靶心附近，手很稳，但是瞄的不准。</li></ul><h2 id="什么是欠拟合-unfitting-amp-过拟合-overfitting"><a href="#什么是欠拟合-unfitting-amp-过拟合-overfitting" class="headerlink" title="什么是欠拟合(unfitting)&amp;过拟合(overfitting)"></a>什么是欠拟合(unfitting)&amp;过拟合(overfitting)</h2><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/dnn-fit.png" alt=""></p><ul><li>欠拟合就是模型能力不足，偏差大。(图1：higt bias)</li><li>过拟合就是模型对于训练数据拟合过于完美，方差大。(图3：high variance)</li></ul><h3 id="如何解决欠拟合"><a href="#如何解决欠拟合" class="headerlink" title="如何解决欠拟合"></a>如何解决欠拟合</h3><p>调整模型参数，增加样本数量</p><h3 id="如何解决过拟合"><a href="#如何解决过拟合" class="headerlink" title="如何解决过拟合"></a>如何解决过拟合</h3><p>减少特征数量，手动选择一些需要保留的特征，<strong>正则化(regularization)</strong>。常见正则化有<strong>L2正则(常用)</strong>，L1正则</p><p>ps:<strong>所以正则化就是为了解决过拟合</strong>，why？</p><h2 id="模型参数-amp-超参数"><a href="#模型参数-amp-超参数" class="headerlink" title="模型参数&amp;超参数"></a>模型参数&amp;超参数</h2><ul><li><strong>模型参数</strong>就是模型内部的配置变量，可以用数据估计它的值</li><li><strong>模型超参数</strong>是模型外部的配置，其值不能从数据估计得到</li></ul><p>模型参数的一些例子包括：</p><ul><li><strong>神经网络中的权重</strong></li><li>支持向量机中的支持向量</li><li>线性回归或逻辑回归中的系数</li></ul><blockquote><p>参数用来处理输入数据的系数，神经网络在学习过程中不断调整参数，直至能准确预测――此时就得到了一个比较准确的模型</p></blockquote><p>模型超参数的一些例子包括：</p><ul><li><strong>训练神经网络的学习速率(learning rate)</strong></li><li>支持向量机的C和sigma超参数</li><li>k邻域中的k</li></ul><blockquote><p>每一项超参数就如同一道菜里的一种食材：取决于食材好坏，这道菜也许非常可口，也可能十分难吃……</p></blockquote><h2 id="神经网络的激活函数"><a href="#神经网络的激活函数" class="headerlink" title="神经网络的激活函数"></a>神经网络的激活函数</h2><p>为什么要有激活函数？加入激活函数是用来加入非线性因素的，解决线性模型所不能解决或者很难解决的问题。<a href="https://www.zhihu.com/question/22334626" target="_blank" rel="external">参考link</a></p><blockquote><p>输出层的激活函数相当于逻辑回归函数，例如softmax。该层函数的选择具体取决于你更能容忍哪一类的错误：选择标准过低会增加取伪错误的数量，标准过高会增加弃真错误的数量</p></blockquote><h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><p>归一化方法：把数变为（0，1）之间的小数。主要是为了数据处理方便提出来的，把数据映射到0～1范围之内处理，更加便捷快速。加快收敛，把各个特征的尺度控制在相同的范围内,加快<strong>梯度下降</strong></p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>常见的为随机梯度下降(Stochastic Gradient Descent，SGD).<strong>是一种用于优化代价函数的常见方法</strong>. – 参考Andrew Ng的机器学习课程第2节</p><h2 id="学习速率（learning-rate）"><a href="#学习速率（learning-rate）" class="headerlink" title="学习速率（learning rate）"></a>学习速率（learning rate）</h2><p>即每次迭代时对于权重的调整幅度，亦称步幅。学习速率越高，神经网络“翻越”整个误差曲面的速度就越快，但也更容易错过误差极小点。学习速率较低时，网络更有可能找到极小值，但速度会变得非常慢，因为每次权重调整的幅度都比较小.</p><blockquote><p>其实就是梯度下降每次下降的步幅</p></blockquote><h2 id="动量（Momentum）"><a href="#动量（Momentum）" class="headerlink" title="动量（Momentum）"></a>动量（Momentum）</h2><p>动量是另一项决定优化算法向最优值收敛的速度的因素。</p><p>如果您想要加快定型速度，可以提高动量。但定型速度加快可能会降低模型的准确率。</p><p>更深入来看，动量是一个范围在0～1之间的变量，是矩阵变化速率的导数的因数。它会影响权重随时间变化的速率。</p><p>训练网络时，通常先对网络的初始权值按照某种分布进行初始化，如：高斯分布。初始化权值操作对最终网络的性能影响比较大，合适的网络初始权值能够使得损失函数在训练过程中的收敛速度更快，从而获得更好的优化结果。但是按照某类分布随机初始化网络权值时，存在一些不确定因素，并不能保证每一次初始化操作都能使得网络的初始权值处在一个合适的状态。不恰当的初始权值可<br>能使得网络的损失函数在训练过程中陷入局部最小值，达不到全局最优的状态。因此，如何消除这种不确定性，是训练深度网络是必须解决的一个问题。 </p><p>momentum 动量能够在一定程度上解决这个问题。momentum 动量是依据物理学的势能与动能之间能量转换原理提出来的。当 momentum 动量越大时，其转换为势能的能量也就越大，就越有可能摆脱局部凹域的束缚，进入全局凹域。momentum 动量主要用在权重更新的时候。</p><p>一般，神经网络在更新权值时，采用如下公式: <code>w = w - learning_rate * dw</code>,引入momentum后，采用如下公式：</p><p><code>v = mu * v - learning_rate * dw</code></p><p><code>w = w + v</code></p><p>其中，v初始化为0，mu是设定的一个超变量，最常见的设定值是0.9。可以这样理解上式：如果上次的momentum(v)与这次的负梯度方向是相同的，那这次下降的幅度就会加大，从而加速收敛。</p><h2 id="什么是隐层-hidden-layer"><a href="#什么是隐层-hidden-layer" class="headerlink" title="什么是隐层(hidden layer)"></a>什么是隐层(hidden layer)</h2><p>隐藏层中的每个节点表示数据集中数据的一项特征。模型的系数按照重要性大小为这些特征赋予权重，随后在每个隐藏层中重新相加，帮助预测。节点的层数更多，网络就能处理更复杂的因素，捕捉更多细节，进而做出更准确的预测。</p><p>之所以将中间的层称为“隐藏”层，是因为<strong>人们可以看到数据输入神经网络、判定结果输出，但网络内部的数据处理方式和原理并非一目了然</strong>。神经网络模型的参数其实就是包含许多数字、计算机可以读取的长向量</p><h2 id="如何选择神经网络"><a href="#如何选择神经网络" class="headerlink" title="如何选择神经网络"></a>如何选择神经网络</h2><p>下表列出了各种不同的问题和每种问题最适用的神经网络：</p><table><thead><tr><th>数据类型</th><th>应用案例</th><th>输入</th><th>变换</th><th>神经网络</th></tr></thead><tbody><tr><td>文本</td><td>情感分析</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文本</td><td>命名实体识别</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文本</td><td>词性标注</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文本</td><td>词性标注</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文本</td><td>语义角色标记</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文档</td><td>主题建模/语义哈希（无监督）</td><td>词频概率</td><td>可为二进制</td><td>深度自动编码器（包装一个DBN或SDA）</td></tr><tr><td>文档</td><td>文档分类（有监督）</td><td>TF-IDF（或词频概率）</td><td>二进制</td><td>深度置信网络、堆叠式降噪自动编码器</td></tr><tr><td>图像</td><td>图像识别</td><td>二进制</td><td>二进制（可见及隐藏层）</td><td>深度置信网络</td></tr><tr><td>图像</td><td>图像识别</td><td>连续</td><td>高斯修正</td><td>深度置信网络</td></tr><tr><td>图像</td><td>多对象识别</td><td>N/A</td><td>高斯修正</td><td>卷积网络、RNTN（图像向量化）</td></tr><tr><td>图像</td><td>图像搜索/语义哈希</td><td>N/A</td><td>高斯修正</td><td>深度自动编码器（包装一个DBN）</td></tr><tr><td>声音</td><td>语音识别</td><td>N/A</td><td>高斯修正</td><td>循环网络</td></tr><tr><td>声音</td><td>语音识别</td><td>N/A</td><td>高斯修正</td><td>移动窗口，DBN或卷积网络</td></tr><tr><td>时间序列</td><td>预测分析</td><td>N/A</td><td>高斯修正</td><td>循环网络</td></tr><tr><td>时间序列</td><td>预测分析</td><td>N/A</td><td>高斯修正</td><td>移动窗口，DBN或卷积网络</td></tr></tbody></table><p><strong>注</strong>：高斯修正 = Gaussian Rectified | 语义哈希 = Semantic Hashing</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/dl-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;仅以此图，催眠我学习deep learning的动力！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度学习的实质无非如此：根据模型产生的误差调整模型中的诸多权重，直到误差不能再减少为止&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Bias（偏差）-amp-Variance（方差）-amp-Error-误差-的区别&quot;&gt;&lt;a href=&quot;#Bias（偏差）-amp-Variance（方差）-amp-Error-误差-的区别&quot; class=&quot;headerlink&quot; title=&quot;Bias（偏差）&amp;amp;Variance（方差）&amp;amp;Error(误差)的区别&quot;&gt;&lt;/a&gt;Bias（偏差）&amp;amp;Variance（方差）&amp;amp;Error(误差)的区别&lt;/h2&gt;&lt;p&gt;首先&lt;code&gt;Error = Bias + Variance&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Error&lt;/code&gt;反映的是整个模型的准确度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bias&lt;/code&gt;反映的是模型在样本上的输出与真实值之间的误差，即模型本身的&lt;strong&gt;精准度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Variance&lt;/code&gt;反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的&lt;strong&gt;精确性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="machine learning" scheme="https://zacard.net/tags/machine-learning/"/>
    
      <category term="deep learning" scheme="https://zacard.net/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch官网文档阅读记录</title>
    <link href="https://zacard.net/2017/12/12/elasticsearch-query/"/>
    <id>https://zacard.net/2017/12/12/elasticsearch-query/</id>
    <published>2017-12-12T13:23:23.000Z</published>
    <updated>2018-01-12T13:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据官网文档及对公司日志平台es升级调优经验分享，如有错误，欢迎斧正。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul><li>环境调优 - 磨刀不误砍柴工</li><li>概念普及 - 步调一致</li><li>如何合理高效查询 - 查询说明</li><li>如果合理高效的写入（另外写）</li></ul><p>环境调优是先决条件，应对查询和写入都有帮助。重点分享查询，因为目前业务没有高频写入的场景</p><h2 id="环境调优"><a href="#环境调优" class="headerlink" title="环境调优"></a>环境调优</h2><p><strong>注意：配置只针对centos，其他系统未做测试</strong>。</p><h3 id="设置elasticsearch的jvm内存"><a href="#设置elasticsearch的jvm内存" class="headerlink" title="设置elasticsearch的jvm内存"></a>设置elasticsearch的jvm内存</h3><p>编辑<code>jvm.options</code>，添加一下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">-</span>Xms8g </div><div class="line"><span class="bullet">-</span>Xmx8g</div></pre></td></tr></table></figure><p><strong>注意：具体大小应当&lt;=系统内存的一半，建议直接设置为系统内存的一半</strong></p><h3 id="禁用swap交换空间"><a href="#禁用swap交换空间" class="headerlink" title="禁用swap交换空间"></a>禁用swap交换空间</h3><blockquote><p>大多数操作系统试图尽可能多地为文件系统缓存使用内存，并急切地交换掉未使用的应用程序内存。这可能会导致JVM堆的部分甚至将其可执行页被交换到磁盘。</p><p>交换对于性能、节点稳定性是非常不利的，应该不惜一切代价避免。它可能导致垃圾收集持续数分钟而不是毫秒，并可能导致节点响应缓慢，甚至可能断开与群集的连接。</p></blockquote><a id="more"></a><p>禁用虚拟内存,并让jvm锁定内存：</p><ol><li>swapoff -a</li><li>编辑文件<code>/etc/fstab</code>，注释掉所有包含<code>swap</code>的行</li><li>编辑文件<code>elasticsearch.yml</code>，添加配置<code>bootstrap.memory_lock: true</code></li></ol><p>验证是否锁定内存成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://121.41.84.118:9210/_nodes?filter_path=**.mlockall&amp;pretty&apos;</div></pre></td></tr></table></figure><h3 id="调整文件句柄数量"><a href="#调整文件句柄数量" class="headerlink" title="调整文件句柄数量"></a>调整文件句柄数量</h3><blockquote><p>Lucene 使用了 大量的 文件。 同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字（注：sockets）。所有这一切都需要足够的文件描述符</p></blockquote><p>先临时设置允许的文件句柄数量：</p><ol><li>sudo su</li><li>ulimit -n 65536</li><li>su elasticsearch</li></ol><p>以上确保在当前session生效，再永久设置：</p><p>编辑<code>/etc/security/limits.conf</code>，添加一行，内容为<code>elasticsearch  -  nofile  65536</code></p><p>验证是否设置成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://121.41.84.118:9210/_nodes/stats/process?filter_path=**.max_file_descriptors&amp;pretty&apos;</div></pre></td></tr></table></figure><h3 id="调整文件映射数量"><a href="#调整文件映射数量" class="headerlink" title="调整文件映射数量"></a>调整文件映射数量</h3><blockquote><p>Elasticsearch 对各种文件混合使用了 NioFs（ 注：非阻塞文件系统）和 MMapFs （ 注：内存映射文件系统）。请确保你配置的最大映射数量，以便有足够的虚拟内存可用于 mmapped 文件</p></blockquote><p>先临时设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -w vm.max_map_count=262144</div></pre></td></tr></table></figure><p>再永久修改：</p><p>编辑<code>/etc/sysctl.conf</code>，添加<code>vm.max_map_count=262144</code></p><h3 id="调整允许的线程数量"><a href="#调整允许的线程数量" class="headerlink" title="调整允许的线程数量"></a>调整允许的线程数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -u 4096</div></pre></td></tr></table></figure><h2 id="概念普及"><a href="#概念普及" class="headerlink" title="概念普及"></a>概念普及</h2><p>index(名词)：索引 ≈ mysql中的库（database）<br>type：类型 ≈ mysql中的表<br>document：文档 ≈ mysql中的一行数据<br>share：分片 ≈ mysql中的数据分表<br>replicas：副本，即数据分片备份</p><p>index(动词)：为文档创建索引</p><h3 id="分片与副本"><a href="#分片与副本" class="headerlink" title="分片与副本"></a>分片与副本</h3><p>一个索引应设置几个分片，几个副本才合理？</p><h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>分片副本用来应对不断攀升的吞吐量以及确保数据的安全性.副本可以动态改变，默认为1份副本，比较合理。</p><p>当查询吞吐量跟不上时，可以考虑增加副本数量。</p><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>分片无法动态指定，只能在创建index的时候指定。（why？）<br>但是默认设置5个分片，这通常来说属于过度分配，这是作者考虑到数据迁移成本的权衡。</p><p>原则就是最小分片。多个分片对于查询和写入都有额外消耗。</p><p>什么时候该违反这个原则？</p><ul><li>由于单个分片有数量上限（Integer.MAX_VALUE=2147483647）</li><li>单机资源限制，如单个分片所占用磁盘过大</li><li><strong>为了吞吐量和单机热点</strong>，大数量写入被分到不同集群中的不同分片中，避免频繁写入占用过多系统资源，从这点看，也能加快查询吞吐量</li></ul><p><strong>所以，根据“经验法则”，小集群时合理的分片数量==节点数量</strong></p><h2 id="如何合理高效查询"><a href="#如何合理高效查询" class="headerlink" title="如何合理高效查询"></a>如何合理高效查询</h2><p>elasticsearch的查询可以在主分片和副本分片查询</p><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><p>根据_id查询流程图：</p><p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0403.png" alt=""></p><p>以下是从主分片或者副本分片检索文档的步骤顺序：</p><ol><li>客户端向<code>Node 1</code>发送获取请求</li><li>节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到<code>Node 2</code></li><li><code>Node 2</code>将文档返回给<code>Node 1</code>，然后将文档返回给客户端</li></ol><p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡</p><p>如果查询有全文检索和聚合操作（例如排序），elasticsearch需要每个分片都执行查询，并把结果返回给协调节点，由协调节点进行聚合操作后再返回被客户端。</p><h4 id="如何路由一个文档到一个分片"><a href="#如何路由一个文档到一个分片" class="headerlink" title="如何路由一个文档到一个分片"></a>如何路由一个文档到一个分片</h4><p>根据以下公式：</p><p><code>shard = hash(routing) % number_of_primary_shards</code></p><blockquote><p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数</p></blockquote><p>这也是为何副本数量能够动态修改，而分片数量需要创建索引时就确定好 – <strong>因为如果分片数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了</strong></p><h3 id="查询原理"><a href="#查询原理" class="headerlink" title="查询原理"></a>查询原理</h3><ul><li>倒排索引</li><li>精确值 &amp; 全文域</li><li>query查询 &amp; filter查询</li></ul><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p><img src="http://hcsem.com/wp-content/uploads/2011/11/image061.jpg" alt=""></p><p>倒排索引为何叫倒排索引？</p><p>一个普通的数据库中，一般是以文档ID作为索引，以文档内容作为记录。<br>而倒排索引指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。刚好倒过来。</p><blockquote><p>思考：有没有更好快的数据结构？如果有，为何不用？</p></blockquote><h4 id="精确值-amp-全文域"><a href="#精确值-amp-全文域" class="headerlink" title="精确值 &amp; 全文域"></a>精确值 &amp; 全文域</h4><p>elasticsearch中数据类型大致可以分为2类：精确值和全文域</p><blockquote><p><strong>精确值</strong>如它们听起来那样精确。例如日期或者用户ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，Foo和foo是不同的，2014和2014-09-15也是不同的</p></blockquote><p>精确值很容易查询。结果是明确的：要么匹配查询，要么不匹配</p><blockquote><p>全文通常是指非结构化的数据，但这里有一个误解：自然语言是高度结构化的。问题在于自然语言的规则是复杂的，导致计算机难以正确解析</p></blockquote><p>查询全文数据要微妙的多。我们问的不只是“这个文档匹配查询吗”，而是“该文档匹配查询的程度有多大？”换句话说，该文档与给定查询的相关性如何？</p><p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的意图：</p><ul><li>搜索 UK ，会返回包含 United Kindom 的文档。</li><li>搜索 jump ，会匹配 jumped ， jumps ， jumping ，甚至是 leap 。</li><li>搜索 johnny walker 会匹配 Johnnie Walker ， johnnie depp 应该匹配 Johnny Depp</li><li>fox news hunting 应该返回福克斯新闻（ Foxs News ）中关于狩猎的故事，同时，fox hunting news 应该返回关于猎狐的故事</li></ul><p>举例：西红柿&amp;番茄、芝士 &amp; 奶酪</p><h3 id="分页原理"><a href="#分页原理" class="headerlink" title="分页原理"></a>分页原理</h3><p>Elasticsearch 接受 from 和 size 参数：</p><p>size<br>显示应该返回的结果数量，默认是 10<br>from<br>显示应该跳过的初始结果数量，默认是 0</p><blockquote><p>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行<strong>集中排序</strong>以保证整体顺序是正确的</p></blockquote><p>注意：谨慎使用深度分页</p><blockquote><p>理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p><p>现在假设我们请求第 1000 页–结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p><p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因</p></blockquote><p>elasticsearch默认限制最多分页10000条数据，可以用<code>index.max_result_window</code>参数覆盖配置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据官网文档及对公司日志平台es升级调优经验分享，如有错误，欢迎斧正。&lt;/p&gt;
&lt;h2 id=&quot;主题&quot;&gt;&lt;a href=&quot;#主题&quot; class=&quot;headerlink&quot; title=&quot;主题&quot;&gt;&lt;/a&gt;主题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;环境调优 - 磨刀不误砍柴工&lt;/li&gt;
&lt;li&gt;概念普及 - 步调一致&lt;/li&gt;
&lt;li&gt;如何合理高效查询 - 查询说明&lt;/li&gt;
&lt;li&gt;如果合理高效的写入（另外写）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境调优是先决条件，应对查询和写入都有帮助。重点分享查询，因为目前业务没有高频写入的场景&lt;/p&gt;
&lt;h2 id=&quot;环境调优&quot;&gt;&lt;a href=&quot;#环境调优&quot; class=&quot;headerlink&quot; title=&quot;环境调优&quot;&gt;&lt;/a&gt;环境调优&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注意：配置只针对centos，其他系统未做测试&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;设置elasticsearch的jvm内存&quot;&gt;&lt;a href=&quot;#设置elasticsearch的jvm内存&quot; class=&quot;headerlink&quot; title=&quot;设置elasticsearch的jvm内存&quot;&gt;&lt;/a&gt;设置elasticsearch的jvm内存&lt;/h3&gt;&lt;p&gt;编辑&lt;code&gt;jvm.options&lt;/code&gt;，添加一下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt;Xms8g &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt;Xmx8g&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：具体大小应当&amp;lt;=系统内存的一半，建议直接设置为系统内存的一半&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;禁用swap交换空间&quot;&gt;&lt;a href=&quot;#禁用swap交换空间&quot; class=&quot;headerlink&quot; title=&quot;禁用swap交换空间&quot;&gt;&lt;/a&gt;禁用swap交换空间&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;大多数操作系统试图尽可能多地为文件系统缓存使用内存，并急切地交换掉未使用的应用程序内存。这可能会导致JVM堆的部分甚至将其可执行页被交换到磁盘。&lt;/p&gt;
&lt;p&gt;交换对于性能、节点稳定性是非常不利的，应该不惜一切代价避免。它可能导致垃圾收集持续数分钟而不是毫秒，并可能导致节点响应缓慢，甚至可能断开与群集的连接。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="elasticsearch" scheme="https://zacard.net/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>分布式追踪系统x-apm开发经历分享</title>
    <link href="https://zacard.net/2017/11/06/apm-share/"/>
    <id>https://zacard.net/2017/11/06/apm-share/</id>
    <published>2017-11-06T13:45:22.000Z</published>
    <updated>2017-11-07T08:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>感谢<a href="https://www.dingdangss.com/" target="_blank" rel="external">@dingdang</a>对开发的强力支持。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在公司微服务化转型后，系统被拆分为多个由不同开发团队维护的分布式微服务。随着业务的发展，分布式服务越来越多，其关系越来越复杂。我们亟需一个工具能够梳理内部服务之间的关系，感知上下游服务的形态，快速定位冗长服务调用间的问题。</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/mtrace1.png" alt=""></p><p>需要解决的核心问题：</p><ul><li>一次请求的完整调用链</li><li>一次请求出现异常，能快速定位那个节点出现问题</li><li>一次请求经历的服务的详细信息</li><li>一次请求的瓶颈节点，并对节点资源分配提供数据支持</li><li>一次请求中出现异常、超时自动报警</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了解决以上问题，自研了一个分布式追踪系统X-APM(APM = Application Performance Management，应用性能管理).其核心就是调用链：通过一个全局的ID将分布在各个服务节点上的同一次请求串联起来，还原原有的调用关系、追踪系统问题、分析调用数据、统计系统指标。<br>在阅读google 《dapper》的思想，<a href="https://wu-sheng.gitbooks.io/opentracing-io/content/" target="_blank" rel="external">open traceing</a>的理念后,实现参考了<a href="https://github.com/OpenSkywalking/skywalking" target="_blank" rel="external">skywalking</a></p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li>低损耗: 对微服务的影响越低越好，包括cpu、内存、tps、响应时间等指标</li><li>低侵入: 作为非业务组件，应当尽可能少侵入或者无侵入其他业务系统，对于使用方透明，减少开发人员的负担</li><li>低延迟: 从数据的产生和收集，到数据计算和处理，再到最终展现，都要求尽可能快</li><li>可配置: 可以通过配置决定所收集数据的范围和粒度</li><li>可视化: 能够以图表方式展示调用链路等信息</li><li>可预警: 分析跟踪到的调用链数据，当出现调用耗时时间过长、调用异常、重复调用等情况，及时警告</li><li>决策支持: 这些数据最好能在决策支持层面发挥作用</li></ul><a id="more"></a><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/tarce-jg.png" alt=""></p><p>各业务系统使用x-apm的agent探针来处理调用链路信息的采集，当采集的信息达到一定量或每隔一段特定的时间时，agent将会把这些信息传送到Flume，通过flume的channel缓冲区流向到指定的sink。目前项目一期已支持将数据保存至ES，并通过UI项目读取ES数据，方便大家在页面上以图表的形式查看各业务系统的调用链路信息。</p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>对于理解分布式追踪系统的领域模型，我强烈建议先阅读<a href="https://wu-sheng.gitbooks.io/opentracing-io/content/" target="_blank" rel="external">open traceing</a>，能够理解在分布式追踪系统中，Trace、Span、Tag等基本概念。</p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>一个trace代表一个潜在的，分布式的，存在并行数据或并行执行轨迹（潜在的分布式、并行）的系统。一个trace可以认为是多个span的有向无环图（DAG）。</p><h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p>一个span代表系统中具有开始时间和执行时长的逻辑运行单元。span之间通过嵌套或者顺序排列建立逻辑因果关系。</p><h3 id="trace与span的关系"><a href="#trace与span的关系" class="headerlink" title="trace与span的关系"></a>trace与span的关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">一个tracer过程中，各span的关系</div><div class="line"></div><div class="line"></div><div class="line">        [Span A]  ←←←(the root span)</div><div class="line">            |</div><div class="line">     +------+------+</div><div class="line">     |             |</div><div class="line"> [Span B]      [Span C] ←←←(Span C 是 Span A 的孩子节点, ChildOf)</div><div class="line">     |             |</div><div class="line"> [Span D]      +---+-------+</div><div class="line">               |           |</div><div class="line">           [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]</div><div class="line">                                       ↑</div><div class="line">                                       ↑</div><div class="line">                                       ↑</div><div class="line">                         (Span G 在 Span F 后被调用, FollowsFrom)</div><div class="line"></div><div class="line">上述tracer与span的时间轴关系</div><div class="line"></div><div class="line"></div><div class="line">––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time</div><div class="line"></div><div class="line"> [Span A···················································]</div><div class="line">   [Span B··············································]</div><div class="line">      [Span D··········································]</div><div class="line">    [Span C········································]</div><div class="line">         [Span E·······]        [Span F··] [Span G··] [Span H··]</div></pre></td></tr></table></figure><h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/TraceSegment.png" alt=""></p><p>简单解释：</p><ul><li>TraceSegment: 一次分布式Trace中可能会经历多个微服务系统，每个系统都是一个TraceSegment(追踪链的一部分)，所有经过的微服务TraceSegment组合在一起，才是一次完整的Trace</li><li>Span: 正如open traceing中的概念，记录调用链中某个功能、某个组件的详细信息</li><li>TraceSegmentRef: 各个微服务系统的TraceSegment之间的关系(调用顺序)</li><li>DistributedTraceIds: 记录各个微服务系统的追踪id</li><li>DistributedTraceId: 分布式追踪id，全局唯一</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这里只讲agent端的原理。因为后面的数据收集使用flume，数据存储使用elasticsearch，实时流分析使用spark，就不细说了</p><h3 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h3><p>为了无侵入，数据埋点采用<a href="https://en.wikipedia.org/wiki/Java_Agent_Development_Framework" target="_blank" rel="external">javaagent</a>配合<a href="https://github.com/raphw/byte-buddy" target="_blank" rel="external">bytebuddy</a>完成。</p><ul><li>javaagent: 主要利用<strong>instrument agent</strong>,其可以在加载class文件之前做拦截，对字节码做修改</li><li>bytebuddy: 修改字节码</li></ul><p>对所有中间件、框架、类库、本地方法的数据埋点，都采用<strong>Plugin</strong>的形式实现，做到自动化、可插拔、可配置、低耦合。</p><p><strong>延伸：javaagent的what、how、why</strong></p><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>由于埋点是动态织入到字节码的功能增强，如何快速高效的收集而不阻塞正常业务系统的流程是个关键。</p><p>具体设计考虑：</p><ol><li>如何收集数据: 收集的数据在发送前怎么存，收集的速度大于发送的速度的时候，又该怎么办？</li><li>如何发送数据: 异步发送数据到flume，但又不能开启太多线程，以免抢占业务系统线程资源，这个线程数设定多大合适呢？</li><li>如何保证数据完整性: 高并发，大数据量下，如何保证数据的完整性？</li></ol><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>方案注意点：</p><ul><li>埋点数据无需落盘，直接发送到flume.在业务系统节点落盘追踪数据毫无意义，徒耗节点系统资源</li><li>埋点数据不能一收到就发送，得批量发送</li></ul><p>最终实现：</p><p>以数组为基础，实现一个<strong>环形结构的无锁数据缓冲区</strong>，批量发送埋点数据。数据结构如下：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/TraceSegmentCollector.png" alt=""></p><ul><li>buffer: 缓存区</li><li>bufferSize: 缓存区大小</li><li>everySendSize: 每次批量发送的数量</li><li>currentIndex: 缓存区当前位置索引</li></ul><p>实现细节：</p><ol><li>对于追踪系统而言，<strong>当收集速度大于发送速度，应该果断丢弃数据</strong>。因为埋点的数据是可重复的且不能影响业务系统，而且本身很多追踪系统是有采样率的，即不是每次的埋点数据都会收集。当丢弃数据达到一定程度的时候会输出一条警告日志，spark中的日志实时分析会对该日志预警</li><li>对于保证数据的完整性，我们采用<strong>宁可丢弃数据，也不能有重复数据</strong>。因为重复的数据将对后续调用链分析，预警，数据统计，流量分析造成比较大的影响</li><li><p>如何实现环形的缓存区，只需要让缓存区的位置索引<code>currentIndex</code>始终在<code>1~bufferSize</code>内原子变动即可，请看以下示例代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用cas操作，获取buffer位置索引</span></div><div class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">   <span class="keyword">int</span> current = currentIndex.get();</div><div class="line">       <span class="keyword">int</span> next = current &gt;= bufferSize ? <span class="number">1</span> : current + <span class="number">1</span>;</div><div class="line">       <span class="keyword">if</span> (currentIndex.compareAndSet(current, next)) &#123;</div><div class="line">       <span class="keyword">return</span> next;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li><li><p>如何实现无锁，核心还是cas操作，请看以下代码示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只有数组中index位置上为null的才设置新值</span></div><div class="line">   <span class="keyword">if</span> (!casObject(index, <span class="keyword">null</span>, traceSegment)) &#123;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 判断是否需要发送数据</span></div><div class="line">   <span class="comment">// a % b == a &amp; (b - 1)</span></div><div class="line">   <span class="keyword">if</span> ((nextIndex &amp; (everySendSize - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 收集缓冲区数据发送</span></div><div class="line">   collectBufferToSend(index, everySendSize);</div></pre></td></tr></table></figure></li></ol><p>ps: 这里有个强制约定，bufferSize和everySendSize的大小必须为2^n.因为计算是否需要批量发送的时候要用到<code>%</code>操作，<code>%</code>操作是个相对比较昂贵的操作。所以这里我们有个取巧，当计算<code>a%b</code>,且<code>b=2^n</code>的时候，<code>a%b==a&amp;(b-1)</code>,位移操作将高效的多。</p><h4 id="方案benchmark"><a href="#方案benchmark" class="headerlink" title="方案benchmark"></a>方案benchmark</h4><p>为了检验环形数据结构的性能，我们专门写了benchmark，使用openjdk.jmh测试，benchmark代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Threads</span>(value = Threads.MAX)</div><div class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">1</span>, time = <span class="number">10</span>, timeUnit = TimeUnit.MILLISECONDS)</div><div class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">1</span>, time = <span class="number">10</span>, timeUnit = TimeUnit.MILLISECONDS)</div><div class="line"><span class="meta">@Fork</span>(value = <span class="number">1</span>)</div><div class="line"><span class="meta">@Benchmark</span></div><div class="line"><span class="meta">@BenchmarkMode</span>(value = Mode.Throughput)</div><div class="line"><span class="meta">@OutputTimeUnit</span>(value = TimeUnit.MILLISECONDS)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchMarkCollector</span><span class="params">()</span> </span>&#123;</div><div class="line">    collector(mockData.getAndIncrement());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><ol><li>flume挂了怎么办？</li><li>agent出异常了怎么办？</li><li>agent如何升级？</li></ol><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>flume是个集群，单点故障可以无视，有重试机制。当全部flume都挂了的时候，agent端的数据将全部丢失，并且agent端将进入每隔30s的无限重连flume操作</li><li>agent的异常被全局catch，输出到日志，后面spark日志实时流分析预警。</li><li>agent的升级比较简单，由于项目使用docker部署，所以升级的时候，只要替换docker仓库中的基础镜像中的agent包即可。</li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/trace-zy-1.png" alt=""></p><p>cpu额外消耗保持在7%以内，内存基本无变化</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/trace-zy-2.png" alt=""></p><p>tps和响应时间基本无变化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢&lt;a href=&quot;https://www.dingdangss.com/&quot;&gt;@dingdang&lt;/a&gt;对开发的强力支持。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在公司微服务化转型后，系统被拆分为多个由不同开发团队维护的分布式微服务。随着业务的发展，分布式服务越来越多，其关系越来越复杂。我们亟需一个工具能够梳理内部服务之间的关系，感知上下游服务的形态，快速定位冗长服务调用间的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/mtrace1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要解决的核心问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次请求的完整调用链&lt;/li&gt;
&lt;li&gt;一次请求出现异常，能快速定位那个节点出现问题&lt;/li&gt;
&lt;li&gt;一次请求经历的服务的详细信息&lt;/li&gt;
&lt;li&gt;一次请求的瓶颈节点，并对节点资源分配提供数据支持&lt;/li&gt;
&lt;li&gt;一次请求中出现异常、超时自动报警&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;为了解决以上问题，自研了一个分布式追踪系统X-APM(APM = Application Performance Management，应用性能管理).其核心就是调用链：通过一个全局的ID将分布在各个服务节点上的同一次请求串联起来，还原原有的调用关系、追踪系统问题、分析调用数据、统计系统指标。&lt;br&gt;在阅读google 《dapper》的思想，&lt;a href=&quot;https://wu-sheng.gitbooks.io/opentracing-io/content/&quot;&gt;open traceing&lt;/a&gt;的理念后,实现参考了&lt;a href=&quot;https://github.com/OpenSkywalking/skywalking&quot;&gt;skywalking&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;设计目标&quot;&gt;&lt;a href=&quot;#设计目标&quot; class=&quot;headerlink&quot; title=&quot;设计目标&quot;&gt;&lt;/a&gt;设计目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;低损耗: 对微服务的影响越低越好，包括cpu、内存、tps、响应时间等指标&lt;/li&gt;
&lt;li&gt;低侵入: 作为非业务组件，应当尽可能少侵入或者无侵入其他业务系统，对于使用方透明，减少开发人员的负担&lt;/li&gt;
&lt;li&gt;低延迟: 从数据的产生和收集，到数据计算和处理，再到最终展现，都要求尽可能快&lt;/li&gt;
&lt;li&gt;可配置: 可以通过配置决定所收集数据的范围和粒度&lt;/li&gt;
&lt;li&gt;可视化: 能够以图表方式展示调用链路等信息&lt;/li&gt;
&lt;li&gt;可预警: 分析跟踪到的调用链数据，当出现调用耗时时间过长、调用异常、重复调用等情况，及时警告&lt;/li&gt;
&lt;li&gt;决策支持: 这些数据最好能在决策支持层面发挥作用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="apm" scheme="https://zacard.net/tags/apm/"/>
    
      <category term="javaagent" scheme="https://zacard.net/tags/javaagent/"/>
    
  </entry>
  
  <entry>
    <title>如何处理InterruptedException</title>
    <link href="https://zacard.net/2017/09/20/howto-handle-InterruptedException/"/>
    <id>https://zacard.net/2017/09/20/howto-handle-InterruptedException/</id>
    <published>2017-09-20T11:15:03.000Z</published>
    <updated>2017-09-21T14:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一直对于如何合理的处理InterruptedException不是很清晰.</p><p>参考以下链接内容理解：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank" rel="external">传送门</a></p><h2 id="什么是InterruptedException"><a href="#什么是InterruptedException" class="headerlink" title="什么是InterruptedException"></a>什么是InterruptedException</h2><p>先来看看InterruptedException的java doc说明：</p><blockquote><p>Thrown when a thread is waiting, sleeping, or otherwise occupied,<br> and the thread is interrupted, either before or during the activity.<br> Occasionally a method may wish to test whether the current<br> thread has been interrupted, and if so, to immediately throw<br> this exception.  The following code can be used to achieve<br> this effect:<br> <pre><br>  if (Thread.interrupted())  // Clears interrupted status!<br>      throw new InterruptedException();<br> </pre></p></blockquote><p>就是说只有在线程处于<code>Object.wait()</code>、<code>Thread.sleep()</code>或者被occupied(应该是指类似<code>LockSupport.park()</code>),并且线程被中断时会抛出InterruptedException异常。</p><p>如果有某个方法希望测试当前线程是否被中断，如果中断就抛出异常，有个推荐的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Thread.interrupted())  <span class="comment">// Clears interrupted status!</span></div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div></pre></td></tr></table></figure><a id="more"></a><h2 id="阻塞方法"><a href="#阻塞方法" class="headerlink" title="阻塞方法"></a>阻塞方法</h2><p>当一个方法抛出InterruptedException时，它不仅告诉您它可以抛出一个特定的检查异常，而且还告诉您其他一些事情。例如，它告诉您它是一个阻塞（blocking）方法，如果您响应得当的话，它将尝试消除阻塞并尽早返回。</p><p>阻塞方法不同于一般的要运行较长时间的方法。一般方法的完成只取决于它所要做的事情，以及是否有足够多可用的计算资源（CPU周期和内存）。而阻塞方法的完成还取决于一些外部的事件，例如计时器到期，I/O 完成，或者另一个线程的动作（释放一个锁，设置一个标志，或者将一个任务放在一个工作队列中）。一般方法在它们的工作做完后即可结束，而阻塞方法较难于预测，因为它们取决于外部事件。阻塞方法可能影响响应能力，因为难于预测它们何时会结束。</p><p><strong>阻塞方法可能因为等不到所等的事件而无法终止，因此令阻塞方法可取消就非常有用（如果长时间运行的非阻塞方法是可取消的，那么通常也非常有用）</strong>。可取消操作是指能从外部使之在正常完成之前终止的操作。由Thread提供并受Thread.sleep()和Object.wait()支持的中断机制就是一种取消机制；它允许一个线程请求另一个线程停止它正在做的事情。<strong>当一个方法抛出 InterruptedException时，它是在告诉您，如果执行该方法的线程被中断，它将尝试停止它正在做的事情而提前返回，并通过抛出InterruptedException表明它提前返回</strong>。 行为良好的阻塞库方法应该能对中断作出响应并抛出InterruptedException，以便能够用于可取消活动中，而不至于影响响应。</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>每个线程都有一个与之相关联的 Boolean 属性，用于表示线程的中断状态（interrupted status）。中断状态初始时为 false；当另一个线程通过调用 Thread.interrupt() 中断一个线程时，会出现以下两种情况之一。如果那个线程在执行一个低级可中断阻塞方法，例如 Thread.sleep()、 Thread.join() 或 Object.wait()，那么它将取消阻塞并抛出 InterruptedException。否则， interrupt() 只是设置线程的中断状态。 在被中断线程中运行的代码以后可以轮询中断状态，看看它是否被请求停止正在做的事情。中断状态可以通过 Thread.isInterrupted() 来读取，并且可以通过一个名为 Thread.interrupted() 的操作读取和清除。</p><p>中断是一种协作机制。当一个线程中断另一个线程时，被中断的线程不一定要立即停止正在做的事情。相反，中断是礼貌地请求另一个线程在它愿意并且方便的时候停止它正在做的事情。有些方法，例如 Thread.sleep()，很认真地对待这样的请求，但每个方法不是一定要对中断作出响应。对于中断请求，不阻塞但是仍然要花较长时间执行的方法可以轮询中断状态，并在被中断的时候提前返回。 您可以随意忽略中断请求，但是这样做的话会影响响应。</p><p>中断的协作特性所带来的一个好处是，它为安全地构造可取消活动提供更大的灵活性。我们很少希望一个活动立即停止；如果活动在正在进行更新的时候被取消，那么程序数据结构可能处于不一致状态。中断允许一个可取消活动来清理正在进行的工作，恢复不变量，通知其他活动它要被取消，然后才终止。</p><h2 id="处理InterruptedException"><a href="#处理InterruptedException" class="headerlink" title="处理InterruptedException"></a>处理InterruptedException</h2><p>如果抛出 InterruptedException 意味着一个方法是阻塞方法，那么调用一个阻塞方法则意味着您的方法也是一个阻塞方法，而且您应该有某种策略来处理 InterruptedException。通常最容易的策略是自己抛出 InterruptedException，如清单 1 中 putTask() 和 getTask() 方法中的代码所示。 这样做可以使方法对中断作出响应，并且只需将 InterruptedException 添加到 throws 子句。</p><p>清单 1. 不捕捉 InterruptedException，将它传播给调用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TASKS = <span class="number">1000</span>;</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue </div><div class="line">        = <span class="keyword">new</span> LinkedBlockingQueue&lt;Task&gt;(MAX_TASKS);</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putTask</span><span class="params">(Task r)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </div><div class="line">        queue.put(r);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </div><div class="line">        <span class="keyword">return</span> queue.take();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有时候需要在传播异常之前进行一些清理工作。在这种情况下，可以捕捉InterruptedException，执行清理，然后抛出异常。清单 2 演示了这种技术，该代码是用于匹配在线游戏服务中的玩家的一种机制。 matchPlayers() 方法等待两个玩家到来，然后开始一个新游戏。如果在一个玩家已到来，但是另一个玩家仍未到来之际该方法被中断，那么它会将那个玩家放回队列中，然后重新抛出 InterruptedException，这样那个玩家对游戏的请求就不至于丢失。<br>清单 2. 在重新抛出 InterruptedException 之前执行特定于任务的清理工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerMatcher</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> PlayerSource players;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlayerMatcher</span><span class="params">(PlayerSource players)</span> </span>&#123; </div><div class="line">        <span class="keyword">this</span>.players = players; </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchPlayers</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">             Player playerOne, playerTwo;</div><div class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                 playerOne = playerTwo = <span class="keyword">null</span>;</div><div class="line">                 <span class="comment">// Wait for two players to arrive and start a new game</span></div><div class="line">                 playerOne = players.waitForPlayer(); <span class="comment">// could throw IE</span></div><div class="line">                 playerTwo = players.waitForPlayer(); <span class="comment">// could throw IE</span></div><div class="line">                 startNewGame(playerOne, playerTwo);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">             <span class="comment">// If we got one player and were interrupted, put that player back</span></div><div class="line">             <span class="keyword">if</span> (playerOne != <span class="keyword">null</span>)</div><div class="line">                 players.addFirst(playerOne);</div><div class="line">             <span class="comment">// Then propagate the exception</span></div><div class="line">             <span class="keyword">throw</span> e;</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="不要生吞中断"><a href="#不要生吞中断" class="headerlink" title="不要生吞中断"></a>不要生吞中断</h3><p>有时候抛出 InterruptedException 并不合适，例如当由 Runnable 定义的任务调用一个可中断的方法时，就是如此。在这种情况下，不能重新抛出 InterruptedException，但是您也不想什么都不做。当一个阻塞方法检测到中断并抛出 InterruptedException 时，它清除中断状态。如果捕捉到 InterruptedException 但是不能重新抛出它，那么应该保留中断发生的证据，以便调用栈中更高层的代码能知道中断，并对中断作出响应。该任务可以通过调用 interrupt() 以 “重新中断” 当前线程来完成，如清单 3 所示。至少，每当捕捉到 InterruptedException 并且不重新抛出它时，就在返回之前重新中断当前线程。</p><p>清单 3. 捕捉 InterruptedException 后恢复中断状态:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123; </div><div class="line">        <span class="keyword">this</span>.queue = queue; </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                 Task task = queue.take(<span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">                 task.execute();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">catch</span> (InterruptedException e) &#123; </div><div class="line">             <span class="comment">// Restore the interrupted status</span></div><div class="line">             Thread.currentThread().interrupt();</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>处理 InterruptedException 时采取的最糟糕的做法是生吞它 —— 捕捉它，然后既不重新抛出它，也不重新断言线程的中断状态。对于不知如何处理的异常，最标准的处理方法是捕捉它，然后记录下它，但是这种方法仍然无异于生吞中断，因为调用栈中更高层的代码还是无法获得关于该异常的信息。（仅仅记录 InterruptedException 也不是明智的做法，因为等到人来读取日志的时候，再来对它作出处理就为时已晚了。） 清单 4 展示了一种使用得很广泛的模式，这也是生吞中断的一种模式：</p><p>清单 4. 生吞中断 —— 不要这么做:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Don't do this </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123; </div><div class="line">        <span class="keyword">this</span>.queue = queue; </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                 Task task = queue.take(<span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">                 task.execute();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">catch</span> (InterruptedException swallowed) &#123; </div><div class="line">             <span class="comment">/* DON'T DO THIS - RESTORE THE INTERRUPTED STATUS INSTEAD */</span></div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>如果不能重新抛出 InterruptedException，不管您是否计划处理中断请求，仍然需要重新中断当前线程，因为一个中断请求可能有多个 “接收者”</strong>。标准线程池 （ThreadPoolExecutor）worker 线程实现负责中断，因此中断一个运行在线程池中的任务可以起到双重效果，一是取消任务，二是通知执行线程线程池正要关闭。如果任务生吞中断请求，则 worker 线程将不知道有一个被请求的中断，从而耽误应用程序或服务的关闭。</p><h2 id="实现可取消任务"><a href="#实现可取消任务" class="headerlink" title="实现可取消任务"></a>实现可取消任务</h2><p>语言规范中并没有为中断提供特定的语义，但是在较大的程序中，难于维护除取消外的任何中断语义。取决于是什么活动，用户可以通过一个 GUI 或通过网络机制，例如 JMX 或 Web 服务来请求取消。程序逻辑也可以请求取消。例如，一个 Web 爬行器（crawler）如果检测到磁盘已满，它会自动关闭自己，否则一个并行算法会启动多个线程来搜索解决方案空间的不同区域，一旦其中一个线程找到一个解决方案，就取消那些线程。</p><p>仅仅因为一个任务是可取消的，并不意味着需要立即 对中断请求作出响应。对于执行一个循环中的代码的任务，通常只需为每一个循环迭代检查一次中断。取决于循环执行的时间有多长，任何代码可能要花一些时间才能注意到线程已经被中断（或者是通过调用 Thread.isInterrupted() 方法轮询中断状态，或者是调用一个阻塞方法）。 如果任务需要提高响应能力，那么它可以更频繁地轮询中断状态。阻塞方法通常在入口就立即轮询中断状态，并且，如果它被设置来改善响应能力，那么还会抛出 InterruptedException。</p><p>惟一可以生吞中断的时候是您知道线程正要退出。只有当调用可中断方法的类是 Thread 的一部分，而不是 Runnable 或通用库代码的情况下，才会发生这样的场景，清单 5 演示了这种情况。清单 5 创建一个线程，该线程列举素数，直到被中断，这里还允许该线程在被中断时退出。用于搜索素数的循环在两个地方检查是否有中断：一处是在 while 循环的头部轮询 isInterrupted() 方法，另一处是调用阻塞方法 BlockingQueue.put()。</p><p>清单 5. 如果知道线程正要退出的话，则可以生吞中断:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line"> </div><div class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BigInteger p = BigInteger.ONE;</div><div class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())</div><div class="line">                queue.put(p = p.nextProbablePrime());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</div><div class="line">            <span class="comment">/* Allow thread to exit */</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; interrupt(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="不可中断的阻塞方法"><a href="#不可中断的阻塞方法" class="headerlink" title="不可中断的阻塞方法"></a>不可中断的阻塞方法</h3><p>并非所有的阻塞方法都抛出 InterruptedException。输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会提前返回。然而，对于套接字 I/O，如果一个线程关闭套接字，则那个套接字上的阻塞 I/O 操作将提前结束，并抛出一个 SocketException。java.nio 中的非阻塞 I/O 类也不支持可中断 I/O，但是同样可以通过关闭通道或者请求 Selector 上的唤醒来取消阻塞操作。类似地，尝试获取一个内部锁的操作（进入一个 synchronized 块）是不能被中断的，但是 ReentrantLock 支持可中断的获取模式。</p><h3 id="不可取消的任务"><a href="#不可取消的任务" class="headerlink" title="不可取消的任务"></a>不可取消的任务</h3><p>有些任务拒绝被中断，这使得它们是不可取消的。但是，即使是不可取消的任务也应该尝试保留中断状态，以防在不可取消的任务结束之后，调用栈上更高层的代码需要对中断进行处理。清单 6 展示了一个方法，该方法等待一个阻塞队列，直到队列中出现一个可用项目，而不管它是否被中断。为了方便他人，它在结束后在一个 finally 块中恢复中断状态，以免剥夺中断请求的调用者的权利。（它不能在更早的时候恢复中断状态，因为那将导致无限循环 —— BlockingQueue.take() 将在入口处立即轮询中断状态，并且，如果发现中断状态集，就会抛出 InterruptedException。）</p><p>清单 6. 在返回前恢复中断状态的不可取消任务:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> queue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// fall through and retry</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (interrupted)</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一直对于如何合理的处理InterruptedException不是很清晰.&lt;/p&gt;
&lt;p&gt;参考以下链接内容理解：&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-jtp05236.html&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是InterruptedException&quot;&gt;&lt;a href=&quot;#什么是InterruptedException&quot; class=&quot;headerlink&quot; title=&quot;什么是InterruptedException&quot;&gt;&lt;/a&gt;什么是InterruptedException&lt;/h2&gt;&lt;p&gt;先来看看InterruptedException的java doc说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thrown when a thread is waiting, sleeping, or otherwise occupied,&lt;br&gt; and the thread is interrupted, either before or during the activity.&lt;br&gt; Occasionally a method may wish to test whether the current&lt;br&gt; thread has been interrupted, and if so, to immediately throw&lt;br&gt; this exception.  The following code can be used to achieve&lt;br&gt; this effect:&lt;br&gt; &lt;pre&gt;&lt;br&gt;  if (Thread.interrupted())  // Clears interrupted status!&lt;br&gt;      throw new InterruptedException();&lt;br&gt; &lt;/pre&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是说只有在线程处于&lt;code&gt;Object.wait()&lt;/code&gt;、&lt;code&gt;Thread.sleep()&lt;/code&gt;或者被occupied(应该是指类似&lt;code&gt;LockSupport.park()&lt;/code&gt;),并且线程被中断时会抛出InterruptedException异常。&lt;/p&gt;
&lt;p&gt;如果有某个方法希望测试当前线程是否被中断，如果中断就抛出异常，有个推荐的用法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Thread.interrupted())  &lt;span class=&quot;comment&quot;&gt;// Clears interrupted status!&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InterruptedException();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="InterruptedException" scheme="https://zacard.net/tags/InterruptedException/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper迁移(扩容/缩容)实践</title>
    <link href="https://zacard.net/2017/08/29/howto-zookeeper-move/"/>
    <id>https://zacard.net/2017/08/29/howto-zookeeper-move/</id>
    <published>2017-08-29T10:22:11.000Z</published>
    <updated>2017-09-18T06:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于一些历史原因，目前zookeeper集群（3个节点）和elasticsearch、hadoop部署在一起，导致几个组件相互影响，性能也逐渐下降。甚至出现某个组件异常（例如oom）导致了其他组件不可用。</p><p>由于大量项目使用dubbo且依赖zookeeper作为注册中心，zookeeper的不稳定可能是致命的，所以计划先将zookeeper迁出到3台独立的节点，在此记录下迁移方案。</p><h2 id="zookeeper选举原理"><a href="#zookeeper选举原理" class="headerlink" title="zookeeper选举原理"></a>zookeeper选举原理</h2><p>在迁移前有必要了解zookeeper的选举原理，以便更科学的迁移。</p><h3 id="快速选举FastLeaderElection"><a href="#快速选举FastLeaderElection" class="headerlink" title="快速选举FastLeaderElection"></a>快速选举FastLeaderElection</h3><p>zookeeper默认使用快速选举，在此重点了解快速选举：</p><ol><li>向集群中的其他zookeeper建立连接，<strong>并且只有myid比对方大的连接才会被接受（也就是每2台只会有1个连接，避免连接浪费）</strong></li><li>每台zookeeper默认先投自己，然后向集群广播自己的选票</li><li>收到对方的选票时，依次比较epoch（选举轮数）、zxid（事务id）、myid，较大者胜出，更新选票并广播</li><li>如果收到的选票中有某个节点超过集群半数，则胜出当选为leader，其他节点为follower</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>zookeeper集群的数量应为奇数：</p><p>  <strong>因为根据paxos理论，只有集群中超过半数的节点还存活才能保证集群的一致性</strong>。假如目前集群有5个节点，我们最多允许2个节点不可用，因为3&gt;5\2。当集群扩容到6个节点的时候，我们仍然只能最多允许2个节点不可用，到3个节点不可用时，将不满足paxos理论，因为3&gt;6\2不成立。也就是说当集群节点数n为偶数时，其可用性与n-1是一样的，那我们何必多浪费一台机器呢？</p></li><li><p>由于zookeeper只允许mid大的节点连接到mid小的节点，我们启动zookeeper的顺序应该按照myid小的到myid大的，最后再启动leader节点！ </p></li></ul><a id="more"></a><h2 id="迁移目标"><a href="#迁移目标" class="headerlink" title="迁移目标"></a>迁移目标</h2><p>迁移过程中要保证原zookeeper集群还是能提供服务，新zookeeper集群同步老集群的数据，将zookeeper url指向新集群的3个节点，停掉老zookeeper集群。</p><p>相当于先扩容zookeeper,然后缩容zookeeper…</p><h2 id="迁移步骤"><a href="#迁移步骤" class="headerlink" title="迁移步骤"></a>迁移步骤</h2><p>原有zookeeper集群(server1、server2、server3)zoo.cfg配置如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div></pre></td></tr></table></figure><p>使用命令：<code>echo srvr | nc node{?} 2181</code>检查谁是leader({?}依次替换为1、2、3)</p><p>ps：也可以用<code>echo stat | nc node{?} 2181</code>显示更详细信息</p><p><strong>这里假设leader为node2.</strong>（按照正常情况，leader也理应是node2）</p><h3 id="步骤1：新增节点4"><a href="#步骤1：新增节点4" class="headerlink" title="步骤1：新增节点4"></a>步骤1：新增节点4</h3><ol><li>在<code>/data</code>目录创建mid文件，内容为4</li><li><p>配置zoo.cfg,内容如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div></pre></td></tr></table></figure></li><li><p>启动zookeeper：<code>{zookeeperDir}/bin/zkServer.sh start</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader，例如以下命令:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">Zookeeper version: <span class="number">3.4</span>.5-cdh5.7.0--<span class="number">1</span>, built on <span class="number">03</span>/<span class="number">23</span>/<span class="number">2016</span> <span class="number">18</span>:<span class="number">30</span> GMT</div><div class="line">Latency min/avg/max: <span class="number">0</span>/<span class="number">6</span>/<span class="number">190</span></div><div class="line">Received: <span class="number">16002</span></div><div class="line">Sent: <span class="number">19874</span></div><div class="line">Connections: <span class="number">1</span></div><div class="line">Outstanding: <span class="number">0</span></div><div class="line">Zxid: <span class="number">0x3b00004872</span></div><div class="line">Mode: leader</div><div class="line">Node count: <span class="number">334</span></div></pre></td></tr></table></figure></li></ol><p>可以看到Mode表示该节点的角色为leader。依次检查每一个节点,如果没有响应，或者出现多个leader，需要还原整个集群！</p><h3 id="步骤2：新增节点5"><a href="#步骤2：新增节点5" class="headerlink" title="步骤2：新增节点5"></a>步骤2：新增节点5</h3><ol><li>在<code>/data</code>目录创建mid文件，内容为5</li><li><p>配置zoo.cfg,内容如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div></pre></td></tr></table></figure></li><li><p>启动zookeeper：<code>{zookeeperDir}/bin/zkServer.sh start</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node2 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node3 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node4 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node5 <span class="number">2181</span></div><div class="line">...</div></pre></td></tr></table></figure></li></ol><h3 id="步骤3：新增节点6"><a href="#步骤3：新增节点6" class="headerlink" title="步骤3：新增节点6"></a>步骤3：新增节点6</h3><ol><li>在<code>/data</code>目录创建mid文件，内容为6</li><li><p>配置zoo.cfg,内容如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure></li><li><p>启动zookeeper：<code>{zookeeperDir}/bin/zkServer.sh start</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node2 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node3 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node4 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node5 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node6 <span class="number">2181</span></div><div class="line">...</div></pre></td></tr></table></figure></li></ol><h3 id="步骤4：更新节点4"><a href="#步骤4：更新节点4" class="headerlink" title="步骤4：更新节点4"></a>步骤4：更新节点4</h3><ol><li><p>修改节点4的配置如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure></li><li><p>重启节点4的zookeeper：<code>{zookeeperDir}/bin/zkServer.sh restart</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node2 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node3 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node4 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node5 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node6 <span class="number">2181</span></div><div class="line">...</div></pre></td></tr></table></figure></li></ol><h3 id="步骤5：更新节点5"><a href="#步骤5：更新节点5" class="headerlink" title="步骤5：更新节点5"></a>步骤5：更新节点5</h3><p>同步骤4</p><h3 id="步骤6：更新老集群节点1"><a href="#步骤6：更新老集群节点1" class="headerlink" title="步骤6：更新老集群节点1"></a>步骤6：更新老集群节点1</h3><ol><li><p>修改节点1的配置如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure></li><li><p>重启节点4的zookeeper：<code>{zookeeperDir}/bin/zkServer.sh restart</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node2 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node3 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node4 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node5 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node6 <span class="number">2181</span></div><div class="line">...</div></pre></td></tr></table></figure></li></ol><h3 id="步骤7：更新老集群节点3"><a href="#步骤7：更新老集群节点3" class="headerlink" title="步骤7：更新老集群节点3"></a>步骤7：更新老集群节点3</h3><p>同步骤6</p><h3 id="步骤8：更新老集群节点2"><a href="#步骤8：更新老集群节点2" class="headerlink" title="步骤8：更新老集群节点2"></a>步骤8：更新老集群节点2</h3><p><strong>最后更新leader节点：node2</strong>，同步骤6</p><p>ps:这时候如果没有读写zookeeper操作，集群的leader将变为节点6（因为节点6的myid最大）</p><h3 id="步骤9：将原有zookeeper的url指向新的节点"><a href="#步骤9：将原有zookeeper的url指向新的节点" class="headerlink" title="步骤9：将原有zookeeper的url指向新的节点"></a>步骤9：将原有zookeeper的url指向新的节点</h3><p>运维修改nginx配置，zookeeper url（例如pro1.zookeeper.so、pro2.zookeeper.so、pro3.zookeeper.so）指向node4，node5，node6</p><p>相关业务系统重启（避免cdh缓存）</p><h3 id="步骤10：老zookeeper集群下线"><a href="#步骤10：老zookeeper集群下线" class="headerlink" title="步骤10：老zookeeper集群下线"></a>步骤10：老zookeeper集群下线</h3><p><strong>这一步需要等待所有的业务系统都重启之后。</strong></p><p>这时候还是得一台一台关闭（下线），因为假如同时关闭node1和node2，那当重启node3的时候集群将不可用（没有超过集群半数的节点存活）</p><h4 id="步骤10-1：下线zookeeper老集群中的节点1"><a href="#步骤10-1：下线zookeeper老集群中的节点1" class="headerlink" title="步骤10.1：下线zookeeper老集群中的节点1"></a>步骤10.1：下线zookeeper老集群中的节点1</h4><p>关闭node1: <code>{zookeeperDir}/bin/zkServer.sh stop</code></p><p>依次修改node2，3，4，5，6的配置，并且重启，配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure><p>重启后检查所有节点是否提供服务，且集群中只有一个leader。</p><p>ps:这时候如果没有读写zookeeper操作，leader将变成node5，因为node6节点重启的时候，集群重新选举，node5的myid最大</p><h4 id="步骤10-2：下线zookeeper老集群中的节点2"><a href="#步骤10-2：下线zookeeper老集群中的节点2" class="headerlink" title="步骤10.2：下线zookeeper老集群中的节点2"></a>步骤10.2：下线zookeeper老集群中的节点2</h4><p>关闭node2: <code>{zookeeperDir}/bin/zkServer.sh stop</code></p><p>依次修改node3，4，5，6的配置，并且重启，配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure><p>重启后检查所有节点是否提供服务，且集群中只有一个leader。</p><p>ps:这时候如果没有读写zookeeper操作，leader将重新变成node6</p><h4 id="步骤10-3：下线zookeeper老集群中的节点3"><a href="#步骤10-3：下线zookeeper老集群中的节点3" class="headerlink" title="步骤10.3：下线zookeeper老集群中的节点3"></a>步骤10.3：下线zookeeper老集群中的节点3</h4><p>关闭node3: <code>{zookeeperDir}/bin/zkServer.sh stop</code></p><p>依次修改node4，5，6的配置，并且重启，配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure><p>重启后检查所有节点是否提供服务，且集群中只有一个leader。</p><p>ps:这时候如果没有读写zookeeper操作，node5将成为最终的leader</p><p>结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;由于一些历史原因，目前zookeeper集群（3个节点）和elasticsearch、hadoop部署在一起，导致几个组件相互影响，性能也逐渐下降。甚至出现某个组件异常（例如oom）导致了其他组件不可用。&lt;/p&gt;
&lt;p&gt;由于大量项目使用dubbo且依赖zookeeper作为注册中心，zookeeper的不稳定可能是致命的，所以计划先将zookeeper迁出到3台独立的节点，在此记录下迁移方案。&lt;/p&gt;
&lt;h2 id=&quot;zookeeper选举原理&quot;&gt;&lt;a href=&quot;#zookeeper选举原理&quot; class=&quot;headerlink&quot; title=&quot;zookeeper选举原理&quot;&gt;&lt;/a&gt;zookeeper选举原理&lt;/h2&gt;&lt;p&gt;在迁移前有必要了解zookeeper的选举原理，以便更科学的迁移。&lt;/p&gt;
&lt;h3 id=&quot;快速选举FastLeaderElection&quot;&gt;&lt;a href=&quot;#快速选举FastLeaderElection&quot; class=&quot;headerlink&quot; title=&quot;快速选举FastLeaderElection&quot;&gt;&lt;/a&gt;快速选举FastLeaderElection&lt;/h3&gt;&lt;p&gt;zookeeper默认使用快速选举，在此重点了解快速选举：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向集群中的其他zookeeper建立连接，&lt;strong&gt;并且只有myid比对方大的连接才会被接受（也就是每2台只会有1个连接，避免连接浪费）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每台zookeeper默认先投自己，然后向集群广播自己的选票&lt;/li&gt;
&lt;li&gt;收到对方的选票时，依次比较epoch（选举轮数）、zxid（事务id）、myid，较大者胜出，更新选票并广播&lt;/li&gt;
&lt;li&gt;如果收到的选票中有某个节点超过集群半数，则胜出当选为leader，其他节点为follower&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;zookeeper集群的数量应为奇数：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;因为根据paxos理论，只有集群中超过半数的节点还存活才能保证集群的一致性&lt;/strong&gt;。假如目前集群有5个节点，我们最多允许2个节点不可用，因为3&amp;gt;5\2。当集群扩容到6个节点的时候，我们仍然只能最多允许2个节点不可用，到3个节点不可用时，将不满足paxos理论，因为3&amp;gt;6\2不成立。也就是说当集群节点数n为偶数时，其可用性与n-1是一样的，那我们何必多浪费一台机器呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由于zookeeper只允许mid大的节点连接到mid小的节点，我们启动zookeeper的顺序应该按照myid小的到myid大的，最后再启动leader节点！ &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="zookeeper" scheme="https://zacard.net/tags/zookeeper/"/>
    
  </entry>
  
</feed>
