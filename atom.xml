<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zacard&#39;s Notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zacard.net/"/>
  <updated>2018-03-20T14:41:28.000Z</updated>
  <id>https://zacard.net/</id>
  
  <author>
    <name>zacard</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里中间件6轮面试被砍的血泪总结</title>
    <link href="https://zacard.net/2018/03/20/alibaba-middleware-interview/"/>
    <id>https://zacard.net/2018/03/20/alibaba-middleware-interview/</id>
    <published>2018-03-20T14:13:02.000Z</published>
    <updated>2018-03-20T14:41:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>年前在v2ex遇到阿里中间件的哥们，内推面试。从2018.02.01开始到今天2018.03.20，一场浩浩荡荡，跨年，持续了1个半月时间的残酷面试终于尘埃落定。遗憾的未能加入阿里中间件部门这个大家庭，让我深感痛惜。</p><p>最终未能如愿的原因是“名额有限，有更适合的同学”。这也可能是内推大哥为了顾及我的感受的说辞，可能是最后一面面的不好。</p><p>这里凭借隐约的记忆，总结下面试经过。让我自己<strong>引以为戒，奋发自强，继续前行</strong></p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>主要问一些java基础。包括集合、多线程、ClassLoader、锁、juc类库等都要知道大致的<strong>原理、使用规范、约定</strong>等</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>根据项目，深入探讨。你需要清楚你所做项目的关键细节、优化、特点、原理。所用第三方库&amp;中间件等的原理，<strong>即使不知道，也要有自己的想法能够说出如何代替实现</strong>！而且需要一定的<strong>技术知识的广度</strong>，对于如何选型，为何这么选型能够说出自己的理由</p><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>个人感觉着重<strong>技术深度</strong>。</p><p>从ConcurrentHashMap一路问到锁&amp;锁优化-&gt;LongAdder-&gt;伪共享-&gt;缓存行填充-&gt;cas等诸多技术细节；</p><p>从hystrix一路问到原理-&gt;自己如何实现-&gt;如何优化-&gt;响应流编程(reactive streams);</p><p>从简单的生产者消费者模式设计到如何高效健壮实现；</p><p>等等。</p><h2 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h2><p>纯coding。</p><blockquote><p>如何倒序输出单向链表？</p></blockquote><p>个人直接想法是用栈先进后出的特点，把链表数据读到栈里然后输出。</p><blockquote><p>有更好的实现方式吗？</p></blockquote><p>仔细一想，确实不够优雅，还好之前刷过一阵子的leetcode，一般能用<strong>栈解决的都能用递归搞定</strong>。换了一种递归实现：</p><p>具体看本人的<a href="https://github.com/mmaxiaolei/algorithm/blob/master/src/main/java/com/zacard/algorithm/test/Test.java" target="_blank" rel="external">github传送门</a></p><h2 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h2><p>hr面，唯一一次现场面，一直以为是最后一面呢。</p><p>给大家抛出几大深坑问题：</p><ul><li>个人的职业规划是什么</li><li>你遇到的最大问题或者是困难是什么</li><li>你如何看待阿里</li><li>你能为阿里带来什么</li><li>你的优缺点是什么</li></ul><p>这几个问题，大家深思啊，不多说。</p><h2 id="六面"><a href="#六面" class="headerlink" title="六面"></a>六面</h2><p>大概晚上20:00的时候接的电面。那会刚刚游泳游了大概2，300百米，然后又没有吃饭，肚子咕咕叫。忍着接听。</p><p>主要问项目情况，然后根据一个项目，问如果量级扩大1000倍，你会怎么做？有哪些优化措施？高性能&amp;高可用措施？</p><p>后面有点饿的眩晕，不知道怎么结束的。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉阿里更偏重<strong>扎实的基础和解决问题的创意与能力</strong>。个人感觉自己缺乏大并发、大流量下面对各种复杂问题的处理经验与解决方案，继续沉淀学习吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;年前在v2ex遇到阿里中间件的哥们，内推面试。从2018.02.01开始到今天2018.03.20，一场浩浩荡荡，跨年，持续了1个半月时间的
      
    
    </summary>
    
      <category term="面试" scheme="https://zacard.net/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://zacard.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="阿里" scheme="https://zacard.net/tags/%E9%98%BF%E9%87%8C/"/>
    
      <category term="中间件" scheme="https://zacard.net/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁研究</title>
    <link href="https://zacard.net/2018/03/20/distributed-lock/"/>
    <id>https://zacard.net/2018/03/20/distributed-lock/</id>
    <published>2018-03-20T11:30:27.000Z</published>
    <updated>2018-03-20T12:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>公司使用基于redis setNX的分布式锁偶现失效，对此深入研究一番</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>大体来说，分布式锁的场景有两种：</p><ol><li>为了效率：相当于去重，避免各个系统做重复的事情。比如重复发送一封email</li><li>为了正确性：不允许出现任何的失效，不然就可能造成数据不一致</li></ol><h2 id="基于单节点的redis实现"><a href="#基于单节点的redis实现" class="headerlink" title="基于单节点的redis实现"></a>基于单节点的redis实现</h2><blockquote><p>为什么强调单节点？因为我们就一个redis主从，没有redis集群。而且redis有官方的分布式锁redlock是基于redis集群的，这个对我们不适用，而且感觉有点过重。</p></blockquote><p>我们一开始的方案是基于setNX(key,value,timeout)。后来发现原来这是jedis的封装，这其实是2个redis命令<code>：setnx+expire</code>。也就是说<strong>这不是个原子操作，很可能setnx成功，但是设置过期时间失败导致锁永远无法释放</strong></p><p>翻看redlock的套路才知道，应该这样操作：</p><ol><li><p>获取锁：<code>set key randomValue NX PX 3000</code></p><blockquote><p>redis的set操作有NX(if not exist)选项和PX(过期时间)选项，可以实现原子操作</p></blockquote></li><li><p>释放锁：需要使用LUA脚本实现复合操作的原子性：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(1) get key</div><div class="line">(2) 比较random value</div><div class="line">(3) random value一致即删除key</div></pre></td></tr></table></figure></li></ol><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一些疑问：</p><ol><li><p>必须要设置过期时间吗？</p><blockquote><p>必须要。因为假如获取锁的程序阻塞/崩溃/与redis网络异常等情况，锁将永远不能被释放</p></blockquote></li><li><p>必须要设置一个随机值吗？</p><blockquote><p>必须要。考虑以下执行序列：</p></blockquote><p> (1) 程序1获取了锁</p><p> (2) 程序1假死导致锁超时被释放</p><p> (3) 程序2获取了锁</p><p> (4) 程序1从假死中恢复，直接释放了锁（没有比较随机值，相当于把程序2的锁给释放了）</p><p> (5) 程序2的执行将得不到锁的保护</p></li><li><p>必须使用lua脚本来释放锁吗？</p><blockquote><p>必须要。因为释放锁需要3步（<code>get-&gt;比较random value-&gt;del</code>）,需要保证3个复合操作的原子性。也不能用redis的事务消息，因为redis没有比较和if else这样命令啊…redis要是有类似cas这种操作就好了，compare and delete一步就能搞定</p></blockquote></li></ol><p>这样处理的redis锁已经是万无一失了吗？其实还存在2个主要问题：</p><ol><li>过期时间设置多久合适？如果设置太短，锁就可能在程序完成对共享资源的操作之前失效，从而得不到保护；如果设置的太长，一旦某个获取锁的程序释放锁失败(比如与redis网络异常)，那么就可能导致其他系统长时间无法获取锁而无法正常工作</li><li>如果程序假死(例如长时间的GC pause)将导致锁过期失效，这时候共享资源其实已经失去了保护(可能这时候有另一个程序获取了锁，而假死的程序恢复过来后同时在操作共享资源)</li></ol><blockquote><p>另外redlock还存在另一个问题就是强依赖于几个节点之间的系统时钟，一旦发生时钟跳跃，redlock很可能就失效</p></blockquote><p>很多人说可以用更可靠的zookeeper来解决，那基于zookeeper的分布式锁真的万无一失吗？先来看看zookeeper分布式锁的套路</p><h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p>具体参考官网文档：<a href="http://zookeeper.apache.org/doc/r3.4.9/recipes.html#sc_recipes_Locks" target="_blank" rel="external">传送门</a></p><ol><li><p>获取锁：</p><p> (1) 客户端调用create()在/lock下创建临时的且有序的子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推</p><p> (2) 客户端调用getChildren()获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得了锁，获取锁流程结束</p><p> (3) 否则在前一个节点调用exists()并设置watch监听节点删除消息</p><p> (4) 如果exists()返回false，重试第(2)步；否则等待节点删除通知再重试第(2)步直到获取锁</p></li><li><p>删除锁：删除创建的节点即可</p></li></ol><p>这样设计有以下优点：</p><ul><li>删除节点即释放锁时，只会导致最多一个客户端被唤醒，避免了“惊群效应（herd effect）”</li><li>不存在轮询或者超时</li><li>临时节点，会在客户端奔溃/假死等情况自动释放锁</li><li>能够直观的知道竞争锁的数量，甚至能退出锁，debug锁问题等</li></ul><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>zookeeper实现的分布式锁相对于redis确实更完善，功能也更丰富。没有redis过期时间的问题，而且能在需要的时候让锁自动释放。然而redis存在的问题中第2点，zookeeper也依然存在。假设有以下执行序列：</p><p>(1) 客户端1创建了节点/lock/lock-0000000000并且获取到了锁</p><p>(2)    客户端1进入长时间的GC pause</p><p>(3)    客户端1与zookeeper的session过期(心跳检测失败)，lock-0000000000被自动删除</p><p>(4)    客户端2创建了/lock/lock-0000000001并获得了锁</p><p>(5)    客户端1从GC pause中恢复，依然认为自己持有锁</p><p>(6) 客户端1和2都认为自己持有锁，就产生了冲突</p><p><strong>类似这种假死造成的锁失效问题，redis和zookeeper目前貌似没有完美的解决方案</strong></p><p>这里肯定有人会说google的Chubby可以做到完美，那就来看下Chubby对这个问题的解决方案</p><h2 id="Chubby分布式锁"><a href="#Chubby分布式锁" class="headerlink" title="Chubby分布式锁"></a>Chubby分布式锁</h2><p>Chubby分布式锁有2种实现，主要是针对之前提到问题的<strong>解决和缓解</strong></p><h3 id="完美实现："><a href="#完美实现：" class="headerlink" title="完美实现："></a>完美实现：</h3><p>获取Chubby锁的时候，锁包含了一个sequencer，里面有个单调递增的数字，要求<strong>资源服务器</strong>在对资源做修改的时候需要检查这个sequencer</p><p>Chubby提供了2种检查方式：</p><ul><li>调用Chubby提供的API，CheckSequencer()，将整个sequencer传进去进行检查。这个检查是为了保证客户端持有的锁在进行资源访问的时候仍然有效</li><li>将客户端传来的sequencer与资源服务器当前观察到的最新的sequencer进行对比检查</li></ul><p><strong>这种实现方式类似乐观锁，有个版本号作为控制</strong>。但是要求有个“资源服务器”能在共享资源做修改的时候检查当前的sequencer。也就是说很可能需要修改“资源服务器（比如数据库）”对共享资源的操作方式。我觉得，绝大多数的“资源服务器”都不能做这个修改，这个完美方案<strong>不太普适</strong></p><h3 id="缓解实现"><a href="#缓解实现" class="headerlink" title="缓解实现"></a>缓解实现</h3><p>获取锁的时候，同时会设置一个lock-deploy(默认一分钟)。当Chubby服务端发现客户端被动失效后，并不是立即释放锁，而是会在lock-delay指定的时间内阻止其它客户端获得这个锁。但是正常的Release操作释放的锁可以立刻被再次获取</p><p><strong>这种方式相当于牺牲了一定的可用性换来更普适的使用场景</strong></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>google Chubby的做法貌似更加优雅一点，提供了足够的方案，把选择权留给了使用者。使用者可以根据特定的场景选择特定的解决方案。</p><p>但是Chubby没有开源，非常可惜。我们只能借鉴其思想。</p><blockquote><p>个人觉得zookeeper完全可以借鉴Chubby的做法，获取锁的时候同样设置lock-deloy或者使用节点序列号作为Chubby中的sequencer，对共享资源的操作可以原子的比较sequencer</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>基于场景1的分布式锁（即为了效率），使用单点的redis已经足够了，简单高效。</li><li>基于场景2的分布式锁（即为了正确性），基于zookeeper已经比较适合，能够满足比redis有更好的正确性，但也无法做到绝对的正确。</li><li>基于场景2的分布式锁（即为了正确性），并且需要绝对的正确，需要定制zookeeper与“资源服务器”</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;公司使用基于redis setNX的分布式锁偶现失效，对此深入研究一番&lt;/p&gt;
&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;大体来说，分布式锁的场景有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了效率：相当于去重，避免各个系统做重复的事情。比如重复发送一封email&lt;/li&gt;
&lt;li&gt;为了正确性：不允许出现任何的失效，不然就可能造成数据不一致&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;基于单节点的redis实现&quot;&gt;&lt;a href=&quot;#基于单节点的redis实现&quot; class=&quot;headerlink&quot; title=&quot;基于单节点的redis实现&quot;&gt;&lt;/a&gt;基于单节点的redis实现&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为什么强调单节点？因为我们就一个redis主从，没有redis集群。而且redis有官方的分布式锁redlock是基于redis集群的，这个对我们不适用，而且感觉有点过重。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们一开始的方案是基于setNX(key,value,timeout)。后来发现原来这是jedis的封装，这其实是2个redis命令&lt;code&gt;：setnx+expire&lt;/code&gt;。也就是说&lt;strong&gt;这不是个原子操作，很可能setnx成功，但是设置过期时间失败导致锁永远无法释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;翻看redlock的套路才知道，应该这样操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取锁：&lt;code&gt;set key randomValue NX PX 3000&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redis的set操作有NX(if not exist)选项和PX(过期时间)选项，可以实现原子操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;释放锁：需要使用LUA脚本实现复合操作的原子性：&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(1) get key&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(2) 比较random value&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(3) random value一致即删除key&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="distributed lock" scheme="https://zacard.net/tags/distributed-lock/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq源码阅读之message发送</title>
    <link href="https://zacard.net/2018/03/18/rocketmq-1-send-message/"/>
    <id>https://zacard.net/2018/03/18/rocketmq-1-send-message/</id>
    <published>2018-03-18T07:43:31.000Z</published>
    <updated>2018-03-18T10:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>基于rocketmq 4.2.0</strong></p><blockquote><p>先不关注顺序消息和事务消息，后面独立看。</p></blockquote><h2 id="发送消息入口"><a href="#发送消息入口" class="headerlink" title="发送消息入口"></a>发送消息入口</h2><p><code>DefaultMQProducer#send(Message)</code></p><p>默认的是同步发送。最终调用的是<code>DefaultMQProducerImpl#sendDefaultImpl</code>，直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(</span></span></div><div class="line">    Message msg,</div><div class="line">    <span class="keyword">final</span> CommunicationMode communicationMode,</div><div class="line">    <span class="keyword">final</span> SendCallback sendCallback,</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> timeout</div><div class="line">) <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 确保producer已经启动</span></div><div class="line">    <span class="keyword">this</span>.makeSureStateOK();</div><div class="line">    <span class="comment">// 校验message，例如topic不能为空</span></div><div class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</div><div class="line"></div><div class="line">    <span class="comment">// 目前来看，仅在日志输出时标示此次调用</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> invokeID = random.nextLong();</div><div class="line">    <span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</div><div class="line">    <span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</div><div class="line">    <span class="keyword">long</span> endTimestamp = beginTimestampFirst;</div><div class="line"></div><div class="line">    <span class="comment">// 获取topic发布路由信息 -- 会先尝试缓存中获取，其次从namesrv中获取</span></div><div class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</div><div class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</div><div class="line">        MessageQueue mq = <span class="keyword">null</span>;</div><div class="line">        Exception exception = <span class="keyword">null</span>;</div><div class="line">        SendResult sendResult = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 同步发送默认重试3次</span></div><div class="line">        <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</div><div class="line">        String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</div><div class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</div><div class="line">            String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName();</div><div class="line">            <span class="comment">/*</span></div><div class="line">                * 选择一个消息队列</div><div class="line">                * 规则：1）默认情况，不开启发送的延迟容错策略时，RoundRobin形式的选择一个不属于上一次发送的broker队列</div><div class="line">                *      2）开启延迟容错策略时：</div><div class="line">                *          2.1）优先从上一次的发送的broker中RoundRobin形式选择一个可用队列</div><div class="line">                *          2.2）其次按照可用性排名（是否可用&gt;延迟时间&gt;开始时间）从前半数中RoundRobin选</div><div class="line">                *          2.3）最次，啥都不管，RoundRobin选</div><div class="line">                */</div><div class="line">            MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</div><div class="line">            <span class="keyword">if</span> (mqSelected != <span class="keyword">null</span>) &#123;</div><div class="line">                mq = mqSelected;</div><div class="line">                brokersSent[times] = mq.getBrokerName();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    beginTimestampPrev = System.currentTimeMillis();</div><div class="line">                    <span class="comment">// 核心消息投递方法</span></div><div class="line">                    sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</div><div class="line">                    endTimestamp = System.currentTimeMillis();</div><div class="line">                    <span class="comment">// 更新延迟容错信息</span></div><div class="line">                    <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">switch</span> (communicationMode) &#123;</div><div class="line">                        <span class="keyword">case</span> ASYNC:</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">case</span> ONEWAY:</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">case</span> SYNC:</div><div class="line">                            <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</div><div class="line">                                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</div><div class="line">                                    <span class="keyword">continue</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="keyword">return</span> sendResult;</div><div class="line">                        <span class="keyword">default</span>:</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</div><div class="line">                    <span class="comment">// ...省略部分代码</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// ...省略部分代码</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol><li><p><code>final long invokeID = random.nextLong();</code></p><p> 这个invokeID仅在日志输出时标示此次调用，却可能造成性能问题。共享的random虽然是线程安全的，但是每次调用都需要循环cas操作来替换每次的随机种子，高并发下，可能造成线程饥饿</p><p> 这里建议JDK7及以上使用<code>ThreadLocalRandom</code>代替。（不过RocketMQ可能是因为要兼容jdk6才没有用，不过我仍然觉得即使jdk6没有现成的类，也应该自己设计一个类似的类，追求性能的路上没有终点~）</p></li></ol><h2 id="如何选择一个消息队列"><a href="#如何选择一个消息队列" class="headerlink" title="如何选择一个消息队列"></a>如何选择一个消息队列</h2><p>最终由<code>MQFaultStrategy#selectOneMessageQueue</code>处理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 优先从上一次的发送的broker中RoundRobin形式选择一个可用队列</span></div><div class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</div><div class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</div><div class="line">                    pos = <span class="number">0</span>;</div><div class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</div><div class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</div><div class="line">                        <span class="keyword">return</span> mq;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 其次按照可用性排名（是否可用&gt;延迟时间&gt;开始时间）从前半数中RoundRobin选</span></div><div class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</div><div class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</div><div class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</div><div class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</div><div class="line">                    mq.setBrokerName(notBestBroker);</div><div class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> mq;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                latencyFaultTolerance.remove(notBestBroker);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 最次，啥都不管，直接RoundRobin选</span></div><div class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 默认情况，不开启发送的延迟容错策略时，RoundRobin形式的选择一个不属于上一次发送的broker队列</span></div><div class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结选择规则"><a href="#总结选择规则" class="headerlink" title="总结选择规则"></a>总结选择规则</h3><ol><li>默认情况，不开启发送的延迟容错策略时，RoundRobin形式的选择一个不属于上一次发送的broker队列</li><li>开启延迟容错策略时：<ol><li>优先从上一次的发送的broker中RoundRobin形式选择一个可用队列</li><li>其次按照可用性排名（是否可用&gt;延迟时间&gt;开始时间）从前半数中RoundRobin选</li><li>最次，啥都不管，直接RoundRobin选</li></ol></li></ol><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>个人感觉这块代码不够整洁。先看以下代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class="line">    <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</div><div class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</div><div class="line">        pos = <span class="number">0</span>;</div><div class="line"><span class="comment">// 省略其他代码</span></div></pre></td></tr></table></figure><p>同时看下tpInfo.getSendWhichQueue().getAndIncrement()具体的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</div><div class="line">    Integer index = <span class="keyword">this</span>.threadLocalIndex.get();</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == index) &#123;</div><div class="line">        index = Math.abs(random.nextInt());</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</div><div class="line">            index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.threadLocalIndex.set(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    index = Math.abs(index + <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</div><div class="line">        index = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.threadLocalIndex.set(index);</div><div class="line">    <span class="keyword">return</span> index;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有2个问题：</p><ul><li><code>Math.abs(index++)</code>这操作绝大多数情况下没有必要的，因为<code>getAndIncrement()</code>保证了其为正数。只有当在循环体内，且index取值为<code>[Integer.MAX_VALUE-tpInfo.getMessageQueueList().size(),Integer.MAX_VALUE]</code>才可能需要，同时后面的<code>if (pos &lt; 0)</code>也是如此。</li><li>pos没有回设到Threadlocal中，导致会有那么几次选择的是同一个消息队列，不过这个倒是影响不大。RocketMQ可能是为了性能考虑。</li></ul><p>个人觉得这段直接使用getAndIncrement会更简洁明确一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class="line">    <span class="keyword">int</span> pos = tpInfo.getSendWhichQueue().getAndIncrement() % tpInfo.getMessageQueueList().size();</div><div class="line">    MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</div><div class="line">    <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName)) &#123;</div><div class="line">            <span class="keyword">return</span> mq;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 剩余代码省略</span></div></pre></td></tr></table></figure><p>可以看到，精简之后，出现了对同一个对象连续调用了其实例方法，感觉有点混乱。其实这里本质就是从上一个发送成功的broker选择队列，为何要独立到<code>MQFaultStrategy</code>中呢？可以仍然由TopicPublishInfo直接出一个方法<code>selectMessageQueueWithBroker</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueueWithBroker</span><span class="params">(String lastBrokerName)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = messageQueueList.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">int</span> pos = sendWhichQueue.getAndIncrement() % size;</div><div class="line">        MessageQueue mq = messageQueueList.get(pos);</div><div class="line">        <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span> || mq.getBrokerName().equals(lastBrokerName)) &#123;</div><div class="line">            <span class="keyword">return</span> mq;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>进一步思考，选择一个消息队列的时候，由一个延迟容错的策略类(<code>MQFaultStrategy</code>)代理，然后基本所有的选择逻辑又都在topic路由类(<code>TopicPublishInfo</code>)中。总感觉有点奇怪。</p><blockquote><p>个人想法: <code>MQFaultStrategy</code>应该设计为由<code>MessageQueueSelector</code>和<code>SendMessageHook</code>组合实现，这样就能和<code>DefaultMQProducerImpl#send(Message msg, MessageQueueSelector selector, Object arg)</code>统一，流程一致。</p><p>目前是<code>MQFaultStrategy</code>强耦合到了默认的消息发送流程中，一方面这个策略类难以被替换，另一方面，和其他重载的的消息发送方法流程不太一致</p></blockquote><h2 id="核心消息发送方法"><a href="#核心消息发送方法" class="headerlink" title="核心消息发送方法"></a>核心消息发送方法</h2><p>调用的是<code>DefaultMQProducerImpl#sendKernelImpl</code>，直接看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></div><div class="line">    <span class="keyword">final</span> MessageQueue mq,</div><div class="line">    <span class="keyword">final</span> CommunicationMode communicationMode,</div><div class="line">    <span class="keyword">final</span> SendCallback sendCallback,</div><div class="line">    <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> timeout) <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 获取broker地址</span></div><div class="line">    String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</div><div class="line">        tryToFindTopicPublishInfo(mq.getTopic());</div><div class="line">        brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SendMessageContext context = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 是否使用broker vip通道,broker会开启两个端口对外服务</span></div><div class="line">        brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] prevBody = msg.getBody();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 设置消息唯一id</span></div><div class="line">            <span class="comment">//for MessageBatch,ID has been set in the generating process</span></div><div class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</div><div class="line">                <span class="comment">// 唯一id生成逻辑：pid+ip+ClassLoader.hashCode+(当前时间-开始时间)+递增数</span></div><div class="line">                MessageClientIDSetter.setUniqID(msg);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 消息压缩</span></div><div class="line">            <span class="keyword">int</span> sysFlag = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</div><div class="line">                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 事务消息</span></div><div class="line">            <span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class="line">            <span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</div><div class="line">                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 钩子：检查是否允许发送消息的扩展点</span></div><div class="line">            <span class="keyword">if</span> (hasCheckForbiddenHook()) &#123;</div><div class="line">                CheckForbiddenContext checkForbiddenContext = <span class="keyword">new</span> CheckForbiddenContext();</div><div class="line">                checkForbiddenContext.setNameSrvAddr(<span class="keyword">this</span>.defaultMQProducer.getNamesrvAddr());</div><div class="line">                checkForbiddenContext.setGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</div><div class="line">                checkForbiddenContext.setCommunicationMode(communicationMode);</div><div class="line">                checkForbiddenContext.setBrokerAddr(brokerAddr);</div><div class="line">                checkForbiddenContext.setMessage(msg);</div><div class="line">                checkForbiddenContext.setMq(mq);</div><div class="line">                checkForbiddenContext.setUnitMode(<span class="keyword">this</span>.isUnitMode());</div><div class="line">                <span class="keyword">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 钩子：发送消息前的扩展点</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context = <span class="keyword">new</span> SendMessageContext();</div><div class="line">                context.setProducer(<span class="keyword">this</span>);</div><div class="line">                context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</div><div class="line">                context.setCommunicationMode(communicationMode);</div><div class="line">                context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</div><div class="line">                context.setBrokerAddr(brokerAddr);</div><div class="line">                context.setMessage(msg);</div><div class="line">                context.setMq(mq);</div><div class="line">                String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class="line">                <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</div><div class="line">                    context.setMsgType(MessageType.Trans_Msg_Half);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</div><div class="line">                    context.setMsgType(MessageType.Delay_Msg);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookBefore(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 构建发送消息请求</span></div><div class="line">            SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</div><div class="line">            requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</div><div class="line">            requestHeader.setTopic(msg.getTopic());</div><div class="line">            requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</div><div class="line">            requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</div><div class="line">            requestHeader.setQueueId(mq.getQueueId());</div><div class="line">            requestHeader.setSysFlag(sysFlag);</div><div class="line">            requestHeader.setBornTimestamp(System.currentTimeMillis());</div><div class="line">            requestHeader.setFlag(msg.getFlag());</div><div class="line">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class="line">            requestHeader.setReconsumeTimes(<span class="number">0</span>);</div><div class="line">            requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</div><div class="line">            requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</div><div class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class="line">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</div><div class="line">                <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</div><div class="line">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</div><div class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</div><div class="line">                <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</div><div class="line">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</div><div class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 发送消息，这里真正要调用网络层发送消息</span></div><div class="line">            SendResult sendResult = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</div><div class="line">                <span class="keyword">case</span> ASYNC:</div><div class="line">                    <span class="comment">// 整整12个入参...</span></div><div class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</div><div class="line">                        brokerAddr,</div><div class="line">                        mq.getBrokerName(),</div><div class="line">                        msg,</div><div class="line">                        requestHeader,</div><div class="line">                        timeout,</div><div class="line">                        communicationMode,</div><div class="line">                        sendCallback,</div><div class="line">                        topicPublishInfo,</div><div class="line">                        <span class="keyword">this</span>.mQClientFactory,</div><div class="line">                        <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</div><div class="line">                        context,</div><div class="line">                        <span class="keyword">this</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> ONEWAY:</div><div class="line">                <span class="keyword">case</span> SYNC:</div><div class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</div><div class="line">                        brokerAddr,</div><div class="line">                        mq.getBrokerName(),</div><div class="line">                        msg,</div><div class="line">                        requestHeader,</div><div class="line">                        timeout,</div><div class="line">                        communicationMode,</div><div class="line">                        context,</div><div class="line">                        <span class="keyword">this</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 钩子：消息发送后的扩展点</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context.setSendResult(sendResult);</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> sendResult;</div><div class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context.setException(e);</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context.setException(e);</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</div><div class="line">                context.setException(e);</div><div class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            msg.setBody(prevBody);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// broker地址为空抛出异常</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The broker["</span> + mq.getBrokerName() + <span class="string">"] not exist"</span>, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="思考-2"><a href="#思考-2" class="headerlink" title="思考"></a>思考</h3><p>这里感觉最大的问题就是api和spi没有分离好。</p><ol><li><p>扩展点(hook)不一致：有<code>CheckForbiddenHook</code>和<code>SendMessageHook</code>这2个hook，目前看<code>CheckForbiddenHook</code>完全可以由<code>SendMessageHook#sendMessageBefore</code>实现</p><blockquote><p>可以定义一个发送消息的流程类SendMessageProcesser,定义消息发送的流程。然后定义一个一致的hook类，比如ProducerHook。然后出个注解定义hook类型(before或者after)，在流程类中对ProducerHook组装</p></blockquote></li><li><p>扩展点(hook)设置略显简陋：hook设置是通过<code>DefaultMQProducerImpl#registerXXXHook</code>方法add到一个ArrayList中的,这样一方面sdk使用者这法明确添加hook的执行顺序，一方面不能精细设置某个hook必须要在某个hook之前或之后调用</p><blockquote><p>可以出个注解定义顺序，然后使用类似TreeSet来排序</p></blockquote></li></ol><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><strong>里面的思考都是基于个人初步阅读源码这个前提的看法，欢迎各位大神斧正！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基于rocketmq 4.2.0&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先不关注顺序消息和事务消息，后面独立看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;发送消息入口&quot;&gt;&lt;a href=&quot;#发送消息入口&quot; class=&quot;headerlink&quot; title=&quot;发送消息入口&quot;&gt;&lt;/a&gt;发送消息入口&lt;/h2&gt;&lt;p&gt;&lt;code&gt;DefaultMQProducer#send(Message)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认的是同步发送。最终调用的是&lt;code&gt;DefaultMQProducerImpl#sendDefaultImpl&lt;/code&gt;，直接看代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; SendResult &lt;span class=&quot;title&quot;&gt;sendDefaultImpl&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Message msg,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; CommunicationMode communicationMode,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SendCallback sendCallback,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeout&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; MQClientException, RemotingException, MQBrokerException, InterruptedException &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 确保producer已经启动&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.makeSureStateOK();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 校验message，例如topic不能为空&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Validators.checkMessage(msg, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.defaultMQProducer);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 目前来看，仅在日志输出时标示此次调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; invokeID = random.nextLong();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; beginTimestampFirst = System.currentTimeMillis();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; beginTimestampPrev = beginTimestampFirst;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; endTimestamp = beginTimestampFirst;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取topic发布路由信息 -- 会先尝试缓存中获取，其次从namesrv中获取&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TopicPublishInfo topicPublishInfo = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tryToFindTopicPublishInfo(msg.getTopic());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (topicPublishInfo != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; topicPublishInfo.ok()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        MessageQueue mq = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Exception exception = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        SendResult sendResult = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 同步发送默认重试3次&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; timesTotal = communicationMode == CommunicationMode.SYNC ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.defaultMQProducer.getRetryTimesWhenSendFailed() : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; times = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        String[] brokersSent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[timesTotal];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (; times &amp;lt; timesTotal; times++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String lastBrokerName = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; == mq ? &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; : mq.getBrokerName();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;/*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                * 选择一个消息队列&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                * 规则：1）默认情况，不开启发送的延迟容错策略时，RoundRobin形式的选择一个不属于上一次发送的broker队列&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                *      2）开启延迟容错策略时：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                *          2.1）优先从上一次的发送的broker中RoundRobin形式选择一个可用队列&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                *          2.2）其次按照可用性排名（是否可用&amp;gt;延迟时间&amp;gt;开始时间）从前半数中RoundRobin选&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                *          2.3）最次，啥都不管，RoundRobin选&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            MessageQueue mqSelected = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.selectOneMessageQueue(topicPublishInfo, lastBrokerName);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mqSelected != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                mq = mqSelected;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                brokersSent[times] = mq.getBrokerName();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    beginTimestampPrev = System.currentTimeMillis();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 核心消息投递方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    sendResult = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    endTimestamp = System.currentTimeMillis();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 更新延迟容错信息&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (communicationMode) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ASYNC:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ONEWAY:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; SYNC:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sendResult.getSendStatus() != SendStatus.SEND_OK) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                    &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sendResult;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (RemotingException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// ...省略部分代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...省略部分代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...省略部分代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="rocketmq" scheme="https://zacard.net/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>分布式追踪系统x-apm拾遗之伪共享与缓存行填充</title>
    <link href="https://zacard.net/2018/02/26/false-share/"/>
    <id>https://zacard.net/2018/02/26/false-share/</id>
    <published>2018-02-26T12:03:18.000Z</published>
    <updated>2018-02-26T13:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前开发分布式追踪系统x-apm的时候，确认了2个目标：</p><ol><li>x-apm的异常绝不能影响业务系统</li><li>x-apm应该尽可能的少暂用系统资源的前提下，尽可能的快(实时)</li></ol><p>针对第2点，用来暂存追踪数据的数据结构碰到了伪共享的问题，导致收集发送的效率不够高，所以使用的缓存行填充。</p><p>这里记录下伪共享和缓存行填充的相关内容。</p><h2 id="基础简介"><a href="#基础简介" class="headerlink" title="基础简介"></a>基础简介</h2><h3 id="cpu-cache"><a href="#cpu-cache" class="headerlink" title="cpu cache"></a>cpu cache</h3><p>一个典型的cpu cache架构：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/cachelinepad-1.png" alt=""></p><p>访问速度：寄存器&lt;L1 cache&lt;L2 cache&lt;L3 cache&lt;主存</p><p>所以，充分利用它的结构和机制，可以有效的提高程序的性能</p><p><strong>这里需要注意：一个cpu中的多核共享L3 cache,而L1、L2 cache是每个核心各自拥有的;一个缓存行一般缓存64byte大小的数据</strong></p><a id="more"></a><h3 id="cpu缓存一致性协议-MESI"><a href="#cpu缓存一致性协议-MESI" class="headerlink" title="cpu缓存一致性协议 - MESI"></a>cpu缓存一致性协议 - MESI</h3><p>在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是： </p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>M(Modified)</td><td>这行数据有效，数据被修改了，和主存冲的数据不一致，数据只存在本Cache中</td></tr><tr><td>E(Exclusive)</td><td>这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中</td></tr><tr><td>S(Shard)</td><td>这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中</td></tr><tr><td>I(Invalid)</td><td>这行数据无效</td></tr></tbody></table><h4 id="MESI协议中的状态"><a href="#MESI协议中的状态" class="headerlink" title="MESI协议中的状态"></a>MESI协议中的状态</h4><ul><li><p>M: 被修改（Modified)</p><p>  该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。</p><p>  当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。</p></li><li><p>E: 独享的（Exclusive)</p><p>  该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。</p><p>  同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。</p></li><li><p>S: 共享的（Shared)</p><p>  该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，</p><p>  其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。</p></li><li><p>I: 无效的 (Invalid)</p><p>  该缓存行数据无效。</p></li></ul><p>M(Modified)和E(Exclusive)状态的Cache line，数据是独有的，不同点在于M状态的数据是dirty的(和内存的不一致)，E状态的数据是clean的(和内存的一致)。</p><p>S(Shared)状态的Cache line，数据和其他Core的Cache共享。只有clean的数据才能被多个Cache共享。</p><p>一个缓存除在Invalid状态外都可以满足cpu的读请求，一个invalid的缓存行必须从主存中读取（变成S或者E状态）来满足该CPU的读请求</p><h3 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h3><p>数据在缓存中不是以独立的项来存储的，如不是一个单独的变量，也不是一个单独的指针。缓存是由缓存行组成的，通常是64字节，并且它有效地引用主内存中的一块地址。一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。</p><p>当缓存行加载数据的时候，会同时加载其后连续的一部分数据。所以你可以非常快速的遍历在连续的内存块中分配的任意数据结构。因此如果你数据结构中的项在内存中不是彼此相邻的（比如链表），你将得不到免费缓存加载所带来的优势。并且在这些数据结构中的每一个项都可能会出现缓存未命中</p><h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><p>伪共享就是2个不同的数据恰好被加载到同一个缓存行中，不同cpu的核分别去修改该缓存行中的不同数据，却导致了相互竞争同一个缓存行。例如以下例子：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/cacheline-2.png" alt=""></p><p>数据X、Y、Z被加载到同一Cache Line中，线程A在Core1修改X，线程B在Core2上修改Y。根据MESI大法，假设是Core1是第一个发起操作的CPU核，Core1上的L1 Cache Line由S（共享）状态变成M（修改，脏数据）状态，然后告知其他的CPU核，图例则是Core2，引用同一地址的Cache Line已经无效了；当Core2发起写操作时，首先导致Core1将X写回主存，Cache Line状态由M变为I（无效），而后才是Core2从主存重新读取该地址内容，Cache Line状态由I变成E（独占），最后进行修改Y操作， Cache Line从E变成M。可见多个线程操作在同一Cache Line上的不同数据，相互竞争同一Cache Line，导致线程彼此牵制影响，变成了串行程序，降低了并发性。</p><h2 id="缓存行填充"><a href="#缓存行填充" class="headerlink" title="缓存行填充"></a>缓存行填充</h2><p>一般解决伪共享的方式就是缓存行填充，将频繁写的变量填充到64byte，不和其他变量加载到同一个缓存行即可。</p><p>例如以下代码：(参考Disruptor作者的博客改写而来)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharingTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WIRTER_NUMBER = <span class="number">800_000_000L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PaddedLong[] ARRAY = <span class="keyword">new</span> PaddedLong[<span class="number">4</span>];</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingLong</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6 = <span class="number">7L</span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 阻止jvm优化掉无用的字段</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">preventOptimisation</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> p1 + p2 + p3 + p4 + p5 + p6;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedLong</span> <span class="keyword">extends</span> <span class="title">PaddingLong</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                ARRAY[index] = <span class="keyword">new</span> PaddedLong();</div><div class="line">                <span class="keyword">long</span> count = WIRTER_NUMBER;</div><div class="line">                <span class="keyword">while</span> (count-- != <span class="number">0</span>) &#123;</div><div class="line">                    ARRAY[index].value = count;</div><div class="line">                &#125;</div><div class="line">                countDownLatch.countDown();</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        countDownLatch.await();</div><div class="line">        System.out.println(<span class="string">"耗时："</span> + (System.currentTimeMillis() - start));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>PaddedLong不继承PaddingLong的时候，即没有使用缓存行填充，程序执行时间甚至2倍于填充后</p><p>JDK8后更智能，可以直接使用@sun.misc.Contended来标注需要填充的字段或者类（标注类表示，类中的所有字段都需要填充）。注意，jvm需要添加参数-XX:-RestrictContended才能开启此功能</p><p>例如JDK8中的ConcurrentHashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// ConcurrentHashMap.java line:2506</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * A padded cell for distributing counts.  Adapted from LongAdder</div><div class="line">     * and Striped64.  See their internal docs for explanation.</div><div class="line">     */</div><div class="line">    <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</div><div class="line">        CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>@sun.misc.Contended虽然很智能，但是需要jvm开启特定参数。对于中间件产品来说可能手动填充更合适。请看以下常见填充方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingLong</span> </span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6 = <span class="number">7L</span>;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * 阻止jvm优化掉无用的字段</div><div class="line">      */</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">preventOptimisation</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> p1 + p2 + p3 + p4 + p5 + p6;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedLong</span> <span class="keyword">extends</span> <span class="title">PaddingLong</span> </span>&#123;</div><div class="line">     <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>以上是参考Disruptor作者的填充方式，也是很多开源产品的填充方式。</p><p>作者只填充了6个long变量，也就是PaddedLong实例对象的内存占用大小为：<code>16(对象头大小)+6*8(填充变量大小)+1*8(被填充变量大小)=72byte&gt;64byte</code></p><p>可以使用JOL工具(<a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="external">下载传送门</a>)查看对象内存布局来验证我们的预想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ java -jar ~/tools/jol-cli-0.9-full.jar internals -cp algorithm-1.0-SNAPSHOT.jar com.zacard.algorithm.test.falseshare.PaddedLong</div><div class="line"></div><div class="line">$ com.zacard.algorithm.test.falseshare.PaddedLong object internals:</div><div class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</div><div class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</div><div class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</div><div class="line">      8     4        (object header)                           44 08 02 f8 (01000100 00001000 00000010 11111000) (-134084540)</div><div class="line">     12     4        (alignment/padding gap)</div><div class="line">     16     8   long PaddingLong.p1                            0</div><div class="line">     24     8   long PaddingLong.p2                            0</div><div class="line">     32     8   long PaddingLong.p3                            0</div><div class="line">     40     8   long PaddingLong.p4                            0</div><div class="line">     48     8   long PaddingLong.p5                            0</div><div class="line">     56     8   long PaddingLong.p6                            7</div><div class="line">     64     8   long PaddedLong.value                          0</div><div class="line">Instance size: 72 bytes</div><div class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</div></pre></td></tr></table></figure><p>可以看到填充的对象确实占用了72byte。</p><p>看一下作者的解释（<a href="https://mechanical-sympathy.blogspot.jp/2011/08/false-sharing-java-7.html" target="_blank" rel="external">传送门</a>）：</p><blockquote><p>I do not want the mark word to be in the cache line which can be modified by taking out locks or the garbage collector ageing the object</p><p>我不希望在缓存行中的对象头中的“mark word”在设置锁标记或者垃圾回收器在老化对象的时候被修改</p></blockquote><p>这里修改对象头中的锁标记应该能理解，因为当synchronized一个对象的时候，确实会修改对象头中的锁标记，这个也很可能会造成伪共享的问题。</p><p>“garbage collector ageing the object”应该指的是对象挨过一次gc存活下来，需要修改对象头中的对象年龄。</p><p>对于作者的严谨，我服…</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前开发分布式追踪系统x-apm的时候，确认了2个目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x-apm的异常绝不能影响业务系统&lt;/li&gt;
&lt;li&gt;x-apm应该尽可能的少暂用系统资源的前提下，尽可能的快(实时)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对第2点，用来暂存追踪数据的数据结构碰到了伪共享的问题，导致收集发送的效率不够高，所以使用的缓存行填充。&lt;/p&gt;
&lt;p&gt;这里记录下伪共享和缓存行填充的相关内容。&lt;/p&gt;
&lt;h2 id=&quot;基础简介&quot;&gt;&lt;a href=&quot;#基础简介&quot; class=&quot;headerlink&quot; title=&quot;基础简介&quot;&gt;&lt;/a&gt;基础简介&lt;/h2&gt;&lt;h3 id=&quot;cpu-cache&quot;&gt;&lt;a href=&quot;#cpu-cache&quot; class=&quot;headerlink&quot; title=&quot;cpu cache&quot;&gt;&lt;/a&gt;cpu cache&lt;/h3&gt;&lt;p&gt;一个典型的cpu cache架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/cachelinepad-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;访问速度：寄存器&amp;lt;L1 cache&amp;lt;L2 cache&amp;lt;L3 cache&amp;lt;主存&lt;/p&gt;
&lt;p&gt;所以，充分利用它的结构和机制，可以有效的提高程序的性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意：一个cpu中的多核共享L3 cache,而L1、L2 cache是每个核心各自拥有的;一个缓存行一般缓存64byte大小的数据&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="false share" scheme="https://zacard.net/tags/false-share/"/>
    
      <category term="pad" scheme="https://zacard.net/tags/pad/"/>
    
  </entry>
  
  <entry>
    <title>分布式追踪系统x-apm开发拾遗之synthetic与bridge方法</title>
    <link href="https://zacard.net/2018/02/13/java-syntethic-and-bridge-methods/"/>
    <id>https://zacard.net/2018/02/13/java-syntethic-and-bridge-methods/</id>
    <published>2018-02-13T06:55:31.000Z</published>
    <updated>2018-02-21T15:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前开发x-apm的时候，自定义增强一个spring bean的时候，出现了一个奇怪的异常 – 找不到无参构造方法，导致bean初始化失败。原来是bytebuddy这个类库在增强类的时候，会自动增加一个synthetic的构造方法，导致spring无法找打正确的构造方法初始化。这里记录下synthetic方法和bridge方法。</p><h2 id="synthetic方法"><a href="#synthetic方法" class="headerlink" title="synthetic方法"></a>synthetic方法</h2><p>synthetic方法是什么呢？先来看个实际例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntheticTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> j + i;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJ</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.j = j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SyntheticTest syntheticTest = <span class="keyword">new</span> SyntheticTest();</div><div class="line">        A a = syntheticTest.new A();</div><div class="line">        a.setJ(<span class="number">1</span>);</div><div class="line">        System.out.println(<span class="string">"sum="</span> + a.sum());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>当你创建一个嵌套类（内部类）时，顶层类的私有属性和私有方法对内部类是可见的。然而jvm是如何处理这种情况的呢？jvm可不清楚什么是内部嵌套类，什么是顶层类。jvm对所有的类都一视同仁，它都认为是顶级类。所有类都会被编译成顶级类，而那些内部类编译完后会生成…$… class的类文件，如下javac编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ javac SyntheticTest.java</div><div class="line">$ ls</div><div class="line">SyntheticTest$A.class SyntheticTest.class   SyntheticTest.java</div></pre></td></tr></table></figure><p>当你创建内部类时，他会被编译成顶级类。那顶层类的私有属性和私有方法是如何被外部类访问的呢？</p><p>javac是这样解决这个问题的，对于任何private的字段，方法或者构造函数，如果它们也被其它顶层类所使用，就会生成一个<strong>synthetic方法</strong>。这些synthetic方法是用来访问最初的私有变量/方法/构造函数的。这些方法的生成也很智能：只有确实被外部类用到了，才会生成这样的方法</p><p>通过反编译SyntheticTest$A.class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntheticTest</span>$<span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> SyntheticTest$A(SyntheticTest var1) &#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.j + SyntheticTest.access$<span class="number">000</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJ</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.j = var1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有个奇怪的方法<code>SyntheticTest.access$000(this.this$0)</code>，这个就是java的synthetic方法。可以用java的反射再次验证这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Method method : SyntheticTest.class.getDeclaredMethods()) &#123;</div><div class="line">        System.out.println(method.getName() + <span class="string">" is synthetic method:"</span> + method.isSynthetic());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main is synthetic method:<span class="keyword">false</span></div><div class="line">access$<span class="number">000</span> is synthetic method:<span class="keyword">true</span></div><div class="line">setI is synthetic method:<span class="keyword">false</span></div></pre></td></tr></table></figure><p>可以看到<code>access$000</code>这个方法，确实是一个synthetic方法</p><blockquote><p><strong>synthetic方法就是java编译器(例如javac)为了实现特定需求增加的方法，不存在源码中的</strong></p></blockquote><h2 id="bridge方法"><a href="#bridge方法" class="headerlink" title="bridge方法"></a>bridge方法</h2><p>bridge方法又是什么呢？看个简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLink</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"my list "</span> + index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Method method : MyLink.class.getDeclaredMethods()) &#123;</div><div class="line">            System.out.println(method.toString() + <span class="string">" is bridge method:"</span> + method.isBridge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> java.lang.String com.zacard.algorithm.test.BridgeTest$MyLink.get(<span class="keyword">int</span>) is bridge method:<span class="keyword">false</span></div><div class="line"><span class="keyword">public</span> java.lang.Object com.zacard.algorithm.test.BridgeTest$MyLink.get(<span class="keyword">int</span>) is bridge method:<span class="keyword">true</span></div></pre></td></tr></table></figure><p>可以看到，多出来一个方法签名一致，返回类型为Object的bridge方法，这在java语言中是不合法的，不过在jvm中是允许的。那这个bridge方法到底作了什么呢？反编译看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javap -c BridgeTest\$MyLink</div></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class com.zacard.algorithm.test.BridgeTest$MyLink extends java.util.LinkedList &#123;</div><div class="line">  public com.zacard.algorithm.test.BridgeTest$MyLink();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/util/LinkedList."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public java.lang.String get(int);</div><div class="line">    Code:</div><div class="line">       0: new           #2                  // class java/lang/StringBuilder</div><div class="line">       3: dup</div><div class="line">       4: invokespecial #3                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</div><div class="line">       7: ldc           #4                  // String my list</div><div class="line">       9: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">      12: iload_1</div><div class="line">      13: invokevirtual #6                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</div><div class="line">      16: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">      19: areturn</div><div class="line"></div><div class="line">  public java.lang.Object get(int);</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: iload_1</div><div class="line">       2: invokevirtual #8                  // Method get:(I)Ljava/lang/String;</div><div class="line">       5: areturn</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，这个birdge不干别的，仅仅就是调用了原始的那个方法。所以这个方法到底有什么用,为什么需要bridge方法？看一下<a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html#bridgeMethods" target="_blank" rel="external">java手册</a>的说明：</p><blockquote><p>When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a bridge method, as part of the type erasure process. You normally don’t need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.</p><p>如果一个类继承了一个范型类或者实现了一个范型接口, 那么编译器在编译这个类的时候就会生成一个叫做桥接方法的混合方法(混合方法简单的说就是由编译器生成的方法, 方法上有synthetic修饰符), 这个方法用于范型的类型安全处理,用户一般不需要关心桥接方法</p></blockquote><p>其实是java为了泛型的向下兼容的一种手段。我们看下另一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">        <span class="keyword">private</span> T data;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Node.setData"</span>);</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"MyNode.setData"</span>);</div><div class="line">            <span class="keyword">super</span>.setData(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个类在泛型擦除后，变成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> Object data;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Node.setData"</span>);</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"MyNode.setData"</span>);</div><div class="line">            <span class="keyword">super</span>.setData(data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>子类的<code>setData</code>方法签名和父类的已经不一致了。因此，<code>MyNode.setData</code>方法其实已经不再重写（override）父类<code>Node.setData</code>方法了。</p><p>为了解决这个问题，并且<strong>维持泛型类在泛型擦除后的多态性，java编译器会生成一个bridge方法</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前开发x-apm的时候，自定义增强一个spring bean的时候，出现了一个奇怪的异常 – 找不到无参构造方法，导致bean初始化失败。原来是bytebuddy这个类库在增强类的时候，会自动增加一个synthetic的构造方法，导致spring无法找打正确的构造方法初始化。这里记录下synthetic方法和bridge方法。&lt;/p&gt;
&lt;h2 id=&quot;synthetic方法&quot;&gt;&lt;a href=&quot;#synthetic方法&quot; class=&quot;headerlink&quot; title=&quot;synthetic方法&quot;&gt;&lt;/a&gt;synthetic方法&lt;/h2&gt;&lt;p&gt;synthetic方法是什么呢？先来看个实际例子：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SyntheticTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setI&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.i = i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; j + i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setJ&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.j = j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        SyntheticTest syntheticTest = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SyntheticTest();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        A a = syntheticTest.new A();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        a.setJ(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;sum=&quot;&lt;/span&gt; + a.sum());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="synthetic" scheme="https://zacard.net/tags/synthetic/"/>
    
      <category term="bridge" scheme="https://zacard.net/tags/bridge/"/>
    
      <category term="method" scheme="https://zacard.net/tags/method/"/>
    
  </entry>
  
  <entry>
    <title>Service Mesh - 服务网格</title>
    <link href="https://zacard.net/2018/02/12/service-mesh/"/>
    <id>https://zacard.net/2018/02/12/service-mesh/</id>
    <published>2018-02-12T12:39:22.000Z</published>
    <updated>2018-02-12T12:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是service-mesh"><a href="#什么是service-mesh" class="headerlink" title="什么是service mesh"></a>什么是service mesh</h2><blockquote><p>服务网格是一个<strong>基础设施层</strong>，功能在于处理服务间通信，职责是负责<strong>实现请求的可靠传递</strong>。在实践中，服务网格通常实现为<strong>轻量级网络代理</strong>，通常与应用程序部署在一起，但是<strong>对应用程序透明</strong></p></blockquote><p>可以将它比作是<strong>微服务</strong>间的TCP/IP，负责服务之间的网络调用、限流、熔断、监控等功能。对于编写应用程序来说一般无须关心TCP/IP这一层（比如通过HTTP协议的RESTful应用），同样使用service mesh也就无须关心服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如spring cloud，现在只要交给service mesh就可以了</p><p>另一方面，service mesh更强调由这些代理连接而形成的网络，而不仅仅是一个网络代理(sidecar)。</p><h2 id="为什么要有service-mesh"><a href="#为什么要有service-mesh" class="headerlink" title="为什么要有service mesh"></a>为什么要有service mesh</h2><p>因为，基于框架或者类库实现的<strong>网络代理</strong>存在诸多弊端</p><a id="more"></a><h3 id="内容多，门槛高"><a href="#内容多，门槛高" class="headerlink" title="内容多，门槛高"></a>内容多，门槛高</h3><p>例如spring cloud：</p><ul><li>spring-cloud-common</li><li>spring-cloud-netflix</li><li>spring-cloud-sleuth</li><li>spring-cloud-gateway</li><li>spring-cloud-bus</li><li>spring-cloud-consul</li><li>spring-cloud-config</li><li>spring-cloud-security</li><li>spring-cloud-zookeeper</li><li>spring-cloud-aws</li><li>spring-cloud-cloudfoundry</li><li>…</li></ul><p>团队成员学习并吃透这些东西，需要大量时间与精力。然而这些技术是实现微服务化的手段，真正的目标是实现业务。时间人力可能远远不足。</p><p>微服务化我们有更艰巨的挑战：微服务拆分、边界设定、设计良好的api等</p><h3 id="服务治理功能不够完善"><a href="#服务治理功能不够完善" class="headerlink" title="服务治理功能不够完善"></a>服务治理功能不够完善</h3><p>服务治理常见的功能如下：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/service-mesh-1.png" alt=""></p><p>Spring Cloud直接提供的功能是远远不够的。很多功能都需要你在Spring Cloud的基础上自己解决</p><h3 id="无法跨语言"><a href="#无法跨语言" class="headerlink" title="无法跨语言"></a>无法跨语言</h3><p>微服务一个重要的特性：就是不同的微服务可以采用最适合的编程语言来编写</p><p>然而我们的框架类库，需要提供多少语言的SDK呢？</p><h3 id="如何升级"><a href="#如何升级" class="headerlink" title="如何升级"></a>如何升级</h3><p>框架不可能一开始就完美无缺，所有功能都齐备，没有任何BUG，分发出去之后就再也不需要改动，这种理想状态不存在的。必然是1.0、2.0、3.0慢慢升级，功能逐渐增加，BUG逐渐被修复</p><p>然而使用者并不能都马上跟进升级，一旦客户端和服务器端版本不一致，就要非常小心维护兼容性</p><p>版本兼容性有多复杂？服务端数以百计起，客户端数以千计起，每个的版本都有可能不同。这是一个笛卡尔乘积。但是别忘了，还有一个前面说的编程语言的问题，你还得再乘个N！这种情况下，兼容性测试需要写多少个Case，这几乎是不可能的</p><h2 id="service-mesh演进"><a href="#service-mesh演进" class="headerlink" title="service mesh演进"></a>service mesh演进</h2><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/service-mesh-2.png" alt=""></p><p>ps:sidecar就是框架或者类库的方式</p><p>service mesh演进是一个技术栈下移的过程。形成一个独立进程，代理服务所有流量，可单独升级，对应用程序透明</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这部分基于本人对service mesh初步认知，属于个人不成熟的想法，欢迎各位大牛斧正！</p><h3 id="service-mesh有什么缺点？"><a href="#service-mesh有什么缺点？" class="headerlink" title="service mesh有什么缺点？"></a>service mesh有什么缺点？</h3><p>个人觉得，相比较框架或者类库的形式，service mesh还是有部分不好实现的功能：</p><ol><li><p>熔断后的回落：<br> 例如，service mesh熔断后的回落操作就比较局限。对于service mesh来说，服务故障的真实原因是隐蔽的，服务调用端可能只能捕获调用异常和约定来处理。而基于框架或者类库，我们有更多可选择的优雅降级方式：返回缓存值、返回缺省值甚至去调用其他不同的服务</p></li><li><p>分布式追踪系统(APM)不能精细控制到本地方法级</p></li></ol><h3 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h3><p>语言兼容与代码级精细控制，本身就是一个矛盾点。相比service mesh提供的便利，其缺点可以忽略不计</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://dockone.io/article/2801" target="_blank" rel="external">Service Mesh：下一代微服务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是service-mesh&quot;&gt;&lt;a href=&quot;#什么是service-mesh&quot; class=&quot;headerlink&quot; title=&quot;什么是service mesh&quot;&gt;&lt;/a&gt;什么是service mesh&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;服务网格是一个&lt;strong&gt;基础设施层&lt;/strong&gt;，功能在于处理服务间通信，职责是负责&lt;strong&gt;实现请求的可靠传递&lt;/strong&gt;。在实践中，服务网格通常实现为&lt;strong&gt;轻量级网络代理&lt;/strong&gt;，通常与应用程序部署在一起，但是&lt;strong&gt;对应用程序透明&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以将它比作是&lt;strong&gt;微服务&lt;/strong&gt;间的TCP/IP，负责服务之间的网络调用、限流、熔断、监控等功能。对于编写应用程序来说一般无须关心TCP/IP这一层（比如通过HTTP协议的RESTful应用），同样使用service mesh也就无须关心服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如spring cloud，现在只要交给service mesh就可以了&lt;/p&gt;
&lt;p&gt;另一方面，service mesh更强调由这些代理连接而形成的网络，而不仅仅是一个网络代理(sidecar)。&lt;/p&gt;
&lt;h2 id=&quot;为什么要有service-mesh&quot;&gt;&lt;a href=&quot;#为什么要有service-mesh&quot; class=&quot;headerlink&quot; title=&quot;为什么要有service mesh&quot;&gt;&lt;/a&gt;为什么要有service mesh&lt;/h2&gt;&lt;p&gt;因为，基于框架或者类库实现的&lt;strong&gt;网络代理&lt;/strong&gt;存在诸多弊端&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="service mesh" scheme="https://zacard.net/tags/service-mesh/"/>
    
  </entry>
  
  <entry>
    <title>分布式追踪系统x-apm开发拾遗之javaagent</title>
    <link href="https://zacard.net/2018/02/09/apm-lost-1/"/>
    <id>https://zacard.net/2018/02/09/apm-lost-1/</id>
    <published>2018-02-09T13:52:22.000Z</published>
    <updated>2018-02-09T13:52:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>x-apm开发周期比较短，开发过程中用到的一些知识点没有深入理解，这里记录下apm用到的入口知识点 – <code>javaagent</code></p><h2 id="什么是javaagent"><a href="#什么是javaagent" class="headerlink" title="什么是javaagent"></a>什么是javaagent</h2><p>javaagent是Java中用来增强JVM上的应用的一种方式，这样的agent有机会修改目标应用或者应用所运行的环境。它可通过访问Java Instrumentation API来修改目标应用程序的class字节码</p><h2 id="为什么要有javaagent"><a href="#为什么要有javaagent" class="headerlink" title="为什么要有javaagent"></a>为什么要有javaagent</h2><ol><li>暴露一些特定功能。比如运行时<strong>获得所有已加载类的字节码</strong></li><li>对于特定类做低侵入甚至无侵入的增强。比如对某个类的某个方法插入特定逻辑</li></ol><p>所以，javaagent的主要功能其实类似aop，但是其原理是<strong>加载class文件之前做拦截，直接修改字节码，或者运行时动态修改字节码</strong>；而aop是生成一个新的代理类</p><a id="more"></a><h2 id="如何编写javaagent"><a href="#如何编写javaagent" class="headerlink" title="如何编写javaagent"></a>如何编写javaagent</h2><p>核心api：<code>java.lang.instrument.Instrumentation</code></p><p><code>Instrumentation</code>其中一个优点就是能够让我们注册ClassFileTransformers。一个已注册的<code>ClassFileTransformer</code>将拦截所有应用程序类的加载，并能够访问他们的字节码。同时，也可以修改类的字节码</p><p>入口是一个premain方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaAgentTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</div><div class="line">        <span class="comment">// 仅仅只是保存了字节码到本地文件</span></div><div class="line">        instrumentation.addTransformer((loader, className, classBeingRedefined, protectionDomain, classfileBuffer) -&gt; &#123;</div><div class="line">            Path path = Paths.get(<span class="string">"classes/"</span> + className + <span class="string">".class"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Files.write(path, classfileBuffer);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> classfileBuffer;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>启动：<code>java -javaagent:/path/to/agent.jar -jar app.jar</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;x-apm开发周期比较短，开发过程中用到的一些知识点没有深入理解，这里记录下apm用到的入口知识点 – &lt;code&gt;javaagent&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是javaagent&quot;&gt;&lt;a href=&quot;#什么是javaagent&quot; class=&quot;headerlink&quot; title=&quot;什么是javaagent&quot;&gt;&lt;/a&gt;什么是javaagent&lt;/h2&gt;&lt;p&gt;javaagent是Java中用来增强JVM上的应用的一种方式，这样的agent有机会修改目标应用或者应用所运行的环境。它可通过访问Java Instrumentation API来修改目标应用程序的class字节码&lt;/p&gt;
&lt;h2 id=&quot;为什么要有javaagent&quot;&gt;&lt;a href=&quot;#为什么要有javaagent&quot; class=&quot;headerlink&quot; title=&quot;为什么要有javaagent&quot;&gt;&lt;/a&gt;为什么要有javaagent&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;暴露一些特定功能。比如运行时&lt;strong&gt;获得所有已加载类的字节码&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于特定类做低侵入甚至无侵入的增强。比如对某个类的某个方法插入特定逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，javaagent的主要功能其实类似aop，但是其原理是&lt;strong&gt;加载class文件之前做拦截，直接修改字节码，或者运行时动态修改字节码&lt;/strong&gt;；而aop是生成一个新的代理类&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="apm" scheme="https://zacard.net/tags/apm/"/>
    
      <category term="javaagent" scheme="https://zacard.net/tags/javaagent/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础 - 熵&amp;交叉熵&amp;相对熵</title>
    <link href="https://zacard.net/2018/01/28/machelearning-1-entropy/"/>
    <id>https://zacard.net/2018/01/28/machelearning-1-entropy/</id>
    <published>2018-01-28T08:36:17.000Z</published>
    <updated>2018-01-28T09:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘录自知乎：<a href="https://www.zhihu.com/question/41252833/answer/195901726" target="_blank" rel="external">https://www.zhihu.com/question/41252833/answer/195901726</a></p></blockquote><p>讨论这个问题需要从香农的信息熵开始。小明在学校玩王者荣耀被发现了，爸爸被叫去开家长会，心里悲屈的很，就想法子惩罚小明。到家后，爸爸跟小明说：既然你犯错了，就要接受惩罚，但惩罚的程度就看你聪不聪明了。这样吧，我们俩玩猜球游戏，我拿一个球，你猜球的颜色，你每猜一次，不管对错，你就一个星期不能玩王者荣耀，当然，猜对，游戏停止，否则继续猜。<strong>当然，当答案只剩下两种选择时，此次猜测结束后，无论猜对猜错都能100%确定答案，无需再猜一次，此时游戏停止（因为好多人对策略１的结果有疑问，所以请注意这个条件）。</strong></p><p>题目1：爸爸拿来一个箱子，跟小明说：里面有橙、紫、蓝及青四种颜色的小球任意个，各颜色小球的占比不清楚，现在我从中拿出一个小球，你猜我手中的小球是什么颜色？为了使被罚时间最短，小明发挥出最强王者的智商，瞬间就想到了以最小的代价猜出答案，简称策略1，小明的想法是这样的。</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-001.jpg" alt=""></p><p>在这种情况下，小明什么信息都不知道，只能认为四种颜色的小球出现的概率是一样的。所以，根据策略1，1/4概率是橙色球，小明需要猜两次，1/4是紫色球，小明需要猜两次，其余的小球类似，所以小明预期的猜球次数为：<code>H = 1/4 * 2 + 1/4 * 2 + 1/4 * 2 + 1/4 * 2 = 2</code></p><a id="more"></a><p>题目2：爸爸还是拿来一个箱子，跟小明说：箱子里面有小球任意个，但其中1/2是橙色球，1/4是紫色球，1/8是蓝色球及1/8是青色球。我从中拿出一个球，你猜我手中的球是什么颜色的？小明毕竟是最强王者，仍然很快得想到了答案，简称策略2，他的答案是这样的。</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-002.jpg" alt=""></p><p>在这种情况下，小明知道了每种颜色小球的比例，比如橙色占比二分之一，如果我猜橙色，很有可能第一次就猜中了。所以，根据策略2，1/2的概率是橙色球，小明需要猜一次，1/4的概率是紫色球，小明需要猜两次，1/8的概率是蓝色球，小明需要猜三次，1/8的概率是青色球，小明需要猜三次，所以小明预期的猜题次数为：<code>H = 1/2 * 1 + 1/4 * 2 + 1/8 * 3 + 1/8 * 3=  1.75</code></p><p>题目3：其实，爸爸只想让小明意识到自己的错误，并不是真的想罚他，所以拿来一个箱子，跟小明说：里面的球都是橙色，现在我从中拿出一个，你猜我手中的球是什么颜色？最强王者怎么可能不知道，肯定是橙色，小明需要猜0次。上面三个题目表现出这样一种现象：针对特定概率为p的小球，需要猜球的次数 =  ，例如题目2中，1/4是紫色球，   = 2 次，1/8是蓝色球，   = 3次。那么，针对整个整体，预期的猜题次数为：  ，这就是信息熵，上面三个题目的预期猜球次数都是由这个公式计算而来，第一题的信息熵为2，第二题的信息熵为1.75，最三题的信息熵为<code>1 *  = 0</code> 。</p><blockquote><p>那么信息熵代表着什么含义呢？<strong>信息熵代表的是随机变量或整个系统的不确定性，熵越大，随机变量或系统的不确定性就越大</strong>。</p></blockquote><p>题目1的熵 &gt; 题目2的熵 &gt; 题目3的熵。在题目1中，小明对整个系统一无所知，只能假设所有的情况出现的概率都是均等的，此时的熵是最大的。</p><p>题目2中，小明知道了橙色小球出现的概率是1/2及其他小球各自出现的概率，说明小明对这个系统有一定的了解，所以系统的不确定性自然会降低，所以熵小于2。</p><p>题目3中，小明已经知道箱子中肯定是橙色球，爸爸手中的球肯定是橙色的，因而整个系统的不确定性为0，也就是熵为0。</p><p>所以，在什么都不知道的情况下，熵会最大，针对上面的题目1~~题目3，这个最大值是2，除此之外，其余的任何一种情况，熵都会比2小。所以，每一个系统都会有一个真实的概率分布，也叫真实分布，题目1的真实分布为（1/4，1/4，1/4，1/4），题目2的真实分布为（1/2，1/4，1/8，1/8），<strong>而根据真实分布，我们能够找到一个最优策略，以最小的代价消除系统的不确定性，而这个代价大小就是信息熵，记住，信息熵衡量了系统的不确定性，而我们要消除这个不确定性，所要付出的【最小努力】（猜题次数、编码长度等）的大小就是信息熵</strong>。</p><p>具体来讲，题目1只需要猜两次就能确定任何一个小球的颜色，题目2只需要猜测1.75次就能确定任何一个小球的颜色。现在回到题目2，假设小明只是钻石段位而已，智商没王者那么高，他使用了策略1，即</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-004.jpg" alt=""></p><p>爸爸已经告诉小明这些小球的真实分布是（1/2，1/4, 1/8，1/8），但小明所选择的策略却认为所有的小球出现的概率相同，相当于忽略了爸爸告诉小明关于箱子中各小球的真实分布，而仍旧认为所有小球出现的概率是一样的，认为小球的分布为（1/4，1/4，1/4，1/4），这个分布就是非真实分布。此时，小明猜中任何一种颜色的小球都需要猜两次，即<code>1/2 * 2 + 1/4 * 2 + 1/8 * 2 + 1/8 * 2 = 2</code>。很明显，针对题目2，使用策略1是一个坏的选择，因为需要猜题的次数增加了，从1.75变成了2，小明少玩了1.75的王者荣耀呢。因此，当我们知道根据系统的真实分布制定最优策略去消除系统的不确定性时，我们所付出的努力是最小的，但并不是每个人都和最强王者一样聪明，我们也许会使用其他的策略（非真实分布）去消除系统的不确定性，就好比如我将策略1用于题目2（原来这就是我在白银的原因）.</p><p><strong>那么，当我们使用非最优策略消除系统的不确定性，所需要付出的努力的大小我们该如何去衡量呢？</strong>这就需要引入交叉熵，其用来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力的大小。正式的讲，交叉熵的公式为：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-1.png" alt=""></p><p> ，其中<code>p_k</code>表示真实分布，<code>q_k</code>表示非真实分布。例如上面所讲的将策略1用于题目2，真实分布:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-2.png" alt=""></p><p>非真实分布:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-3.png" alt=""></p><p>交叉熵为:</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-4.png" alt=""></p><p>比最优策略的1.75来得大。<strong>因此，交叉熵越低，这个策略就越好，最低的交叉熵也就是使用了真实分布所计算出来的信息熵</strong>，因为此时 <code>p_k=q_k</code> ，交叉熵 = 信息熵。</p><p><strong>这也是为什么在机器学习中的分类算法中，我们总是最小化交叉熵，因为交叉熵越低，就证明由算法所产生的策略最接近最优策略，也间接证明我们算法所算出的非真实分布越接近真实分布</strong>。</p><p>最后，我们如何去衡量不同策略之间的差异呢？这就需要用到<strong>相对熵</strong>，其用来衡量两个取值为正的函数或概率分布之间的差异，即：KL(f(x) || g(x)) = 现在，假设我们想知道某个策略和最优策略之间的差异，我们就可以用相对熵来衡量这两者之间的差异。即，相对熵 = 某个策略的交叉熵 - 信息熵（根据系统真实分布计算而得的信息熵，为最优策略），公式如下：</p><p><code>KL（p || q） = H（p，q） - H（p)</code> = <img src="http://7xlnw9.com1.z0.glb.clouddn.com/shang-5.png" alt=""></p><p>所以将策略1用于题目2，所产生的相对熵为<code>2 - 1.75 = 0.25</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘录自知乎：&lt;a href=&quot;https://www.zhihu.com/question/41252833/answer/195901726&quot;&gt;https://www.zhihu.com/question/41252833/answer/195901726&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讨论这个问题需要从香农的信息熵开始。小明在学校玩王者荣耀被发现了，爸爸被叫去开家长会，心里悲屈的很，就想法子惩罚小明。到家后，爸爸跟小明说：既然你犯错了，就要接受惩罚，但惩罚的程度就看你聪不聪明了。这样吧，我们俩玩猜球游戏，我拿一个球，你猜球的颜色，你每猜一次，不管对错，你就一个星期不能玩王者荣耀，当然，猜对，游戏停止，否则继续猜。&lt;strong&gt;当然，当答案只剩下两种选择时，此次猜测结束后，无论猜对猜错都能100%确定答案，无需再猜一次，此时游戏停止（因为好多人对策略１的结果有疑问，所以请注意这个条件）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目1：爸爸拿来一个箱子，跟小明说：里面有橙、紫、蓝及青四种颜色的小球任意个，各颜色小球的占比不清楚，现在我从中拿出一个小球，你猜我手中的小球是什么颜色？为了使被罚时间最短，小明发挥出最强王者的智商，瞬间就想到了以最小的代价猜出答案，简称策略1，小明的想法是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/shang-001.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在这种情况下，小明什么信息都不知道，只能认为四种颜色的小球出现的概率是一样的。所以，根据策略1，1/4概率是橙色球，小明需要猜两次，1/4是紫色球，小明需要猜两次，其余的小球类似，所以小明预期的猜球次数为：&lt;code&gt;H = 1/4 * 2 + 1/4 * 2 + 1/4 * 2 + 1/4 * 2 = 2&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="machine learning" scheme="https://zacard.net/tags/machine-learning/"/>
    
      <category term="entropy" scheme="https://zacard.net/tags/entropy/"/>
    
  </entry>
  
  <entry>
    <title>深度学习(deep learning)记录 - 初步概念</title>
    <link href="https://zacard.net/2018/01/12/deeplearning-1/"/>
    <id>https://zacard.net/2018/01/12/deeplearning-1/</id>
    <published>2018-01-12T12:59:17.000Z</published>
    <updated>2018-01-19T08:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/dl-1.png" alt=""></p><p>仅以此图，催眠我学习deep learning的动力！</p><blockquote><p>深度学习的实质无非如此：根据模型产生的误差调整模型中的诸多权重，直到误差不能再减少为止</p></blockquote><h2 id="Bias（偏差）-amp-Variance（方差）-amp-Error-误差-的区别"><a href="#Bias（偏差）-amp-Variance（方差）-amp-Error-误差-的区别" class="headerlink" title="Bias（偏差）&amp;Variance（方差）&amp;Error(误差)的区别"></a>Bias（偏差）&amp;Variance（方差）&amp;Error(误差)的区别</h2><p>首先<code>Error = Bias + Variance</code></p><ul><li><code>Error</code>反映的是整个模型的准确度</li><li><code>Bias</code>反映的是模型在样本上的输出与真实值之间的误差，即模型本身的<strong>精准度</strong></li><li><code>Variance</code>反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的<strong>精确性</strong></li></ul><a id="more"></a><p>在一个实际系统中，<strong>Bias与Variance往往是不能兼得的</strong>。如果要降低模型的Bias，就一定程度上会提高模型的Variance，反之亦然。造成这种现象的根本原因是，<strong>我们总是希望试图用有限训练样本去估计无限的真实数据</strong>。当我们更加相信这些数据的真实性，而忽视对模型的先验知识，就会尽量保证模型在训练样本上的准确度，这样可以减少模型的Bias。但是，这样学习到的模型，很可能会失去一定的泛化能力，从而造成<strong>过拟合</strong>，降低模型在真实数据上的表现，增加模型的不确定性。相反，如果更加相信我们对于模型的先验知识，在学习模型的过程中对模型增加更多的限制，就可以降低模型的variance，提高模型的稳定性，但也会使模型的Bias增大。<strong>Bias与Variance两者之间的trade-off(权衡)是机器学习的基本主题之一</strong>。</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/dnn-bias-variance.jpg" alt=""></p><ul><li>准：bias描述的是根据样本拟合出的模型的输出预测结果的期望与样本真实结果的差距，简单讲，就是在样本上拟合的好不好。要想在bias上表现好，low bias，就得复杂化模型，增加模型的参数，但这样容易过拟合 (overfitting)，过拟合对应上图是high variance，点很分散。low bias对应就是点都打在靶心附近，所以瞄的是准的，但手不一定稳。</li><li>确：varience描述的是样本上训练出来的模型在测试集上的表现，要想在variance上表现好，low varience，就要简化模型，减少模型的参数，但这样容易欠拟合(unfitting)，欠拟合对应上图是high bias，点偏离中心。low variance对应就是点都打的很集中，但不一定是靶心附近，手很稳，但是瞄的不准。</li></ul><h2 id="什么是欠拟合-unfitting-amp-过拟合-overfitting"><a href="#什么是欠拟合-unfitting-amp-过拟合-overfitting" class="headerlink" title="什么是欠拟合(unfitting)&amp;过拟合(overfitting)"></a>什么是欠拟合(unfitting)&amp;过拟合(overfitting)</h2><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/dnn-fit.png" alt=""></p><ul><li>欠拟合就是模型能力不足，偏差大。(图1：higt bias)</li><li>过拟合就是模型对于训练数据拟合过于完美，方差大。(图3：high variance)</li></ul><h3 id="如何解决欠拟合"><a href="#如何解决欠拟合" class="headerlink" title="如何解决欠拟合"></a>如何解决欠拟合</h3><p>调整模型参数，增加样本数量</p><h3 id="如何解决过拟合"><a href="#如何解决过拟合" class="headerlink" title="如何解决过拟合"></a>如何解决过拟合</h3><p>减少特征数量，手动选择一些需要保留的特征，<strong>正则化(regularization)</strong>。常见正则化有<strong>L2正则(常用)</strong>，L1正则</p><p>ps:<strong>所以正则化就是为了解决过拟合</strong>，why？</p><h2 id="模型参数-amp-超参数"><a href="#模型参数-amp-超参数" class="headerlink" title="模型参数&amp;超参数"></a>模型参数&amp;超参数</h2><ul><li><strong>模型参数</strong>就是模型内部的配置变量，可以用数据估计它的值</li><li><strong>模型超参数</strong>是模型外部的配置，其值不能从数据估计得到</li></ul><p>模型参数的一些例子包括：</p><ul><li><strong>神经网络中的权重</strong></li><li>支持向量机中的支持向量</li><li>线性回归或逻辑回归中的系数</li></ul><blockquote><p>参数用来处理输入数据的系数，神经网络在学习过程中不断调整参数，直至能准确预测――此时就得到了一个比较准确的模型</p></blockquote><p>模型超参数的一些例子包括：</p><ul><li><strong>训练神经网络的学习速率(learning rate)</strong></li><li>支持向量机的C和sigma超参数</li><li>k邻域中的k</li></ul><blockquote><p>每一项超参数就如同一道菜里的一种食材：取决于食材好坏，这道菜也许非常可口，也可能十分难吃……</p></blockquote><h2 id="神经网络的激活函数"><a href="#神经网络的激活函数" class="headerlink" title="神经网络的激活函数"></a>神经网络的激活函数</h2><p>为什么要有激活函数？加入激活函数是用来加入非线性因素的，解决线性模型所不能解决或者很难解决的问题。<a href="https://www.zhihu.com/question/22334626" target="_blank" rel="external">参考link</a></p><blockquote><p>输出层的激活函数相当于逻辑回归函数，例如softmax。该层函数的选择具体取决于你更能容忍哪一类的错误：选择标准过低会增加取伪错误的数量，标准过高会增加弃真错误的数量</p></blockquote><h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><p>归一化方法：把数变为（0，1）之间的小数。主要是为了数据处理方便提出来的，把数据映射到0～1范围之内处理，更加便捷快速。加快收敛，把各个特征的尺度控制在相同的范围内,加快<strong>梯度下降</strong></p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>常见的为随机梯度下降(Stochastic Gradient Descent，SGD).<strong>是一种用于优化代价函数的常见方法</strong>. – 参考Andrew Ng的机器学习课程第2节</p><h2 id="学习速率（learning-rate）"><a href="#学习速率（learning-rate）" class="headerlink" title="学习速率（learning rate）"></a>学习速率（learning rate）</h2><p>即每次迭代时对于权重的调整幅度，亦称步幅。学习速率越高，神经网络“翻越”整个误差曲面的速度就越快，但也更容易错过误差极小点。学习速率较低时，网络更有可能找到极小值，但速度会变得非常慢，因为每次权重调整的幅度都比较小.</p><blockquote><p>其实就是梯度下降每次下降的步幅</p></blockquote><h2 id="动量（Momentum）"><a href="#动量（Momentum）" class="headerlink" title="动量（Momentum）"></a>动量（Momentum）</h2><p>动量是另一项决定优化算法向最优值收敛的速度的因素。</p><p>如果您想要加快定型速度，可以提高动量。但定型速度加快可能会降低模型的准确率。</p><p>更深入来看，动量是一个范围在0～1之间的变量，是矩阵变化速率的导数的因数。它会影响权重随时间变化的速率。</p><p>训练网络时，通常先对网络的初始权值按照某种分布进行初始化，如：高斯分布。初始化权值操作对最终网络的性能影响比较大，合适的网络初始权值能够使得损失函数在训练过程中的收敛速度更快，从而获得更好的优化结果。但是按照某类分布随机初始化网络权值时，存在一些不确定因素，并不能保证每一次初始化操作都能使得网络的初始权值处在一个合适的状态。不恰当的初始权值可<br>能使得网络的损失函数在训练过程中陷入局部最小值，达不到全局最优的状态。因此，如何消除这种不确定性，是训练深度网络是必须解决的一个问题。 </p><p>momentum 动量能够在一定程度上解决这个问题。momentum 动量是依据物理学的势能与动能之间能量转换原理提出来的。当 momentum 动量越大时，其转换为势能的能量也就越大，就越有可能摆脱局部凹域的束缚，进入全局凹域。momentum 动量主要用在权重更新的时候。</p><p>一般，神经网络在更新权值时，采用如下公式: <code>w = w - learning_rate * dw</code>,引入momentum后，采用如下公式：</p><p><code>v = mu * v - learning_rate * dw</code></p><p><code>w = w + v</code></p><p>其中，v初始化为0，mu是设定的一个超变量，最常见的设定值是0.9。可以这样理解上式：如果上次的momentum(v)与这次的负梯度方向是相同的，那这次下降的幅度就会加大，从而加速收敛。</p><h2 id="什么是隐层-hidden-layer"><a href="#什么是隐层-hidden-layer" class="headerlink" title="什么是隐层(hidden layer)"></a>什么是隐层(hidden layer)</h2><p>隐藏层中的每个节点表示数据集中数据的一项特征。模型的系数按照重要性大小为这些特征赋予权重，随后在每个隐藏层中重新相加，帮助预测。节点的层数更多，网络就能处理更复杂的因素，捕捉更多细节，进而做出更准确的预测。</p><p>之所以将中间的层称为“隐藏”层，是因为<strong>人们可以看到数据输入神经网络、判定结果输出，但网络内部的数据处理方式和原理并非一目了然</strong>。神经网络模型的参数其实就是包含许多数字、计算机可以读取的长向量</p><h2 id="如何选择神经网络"><a href="#如何选择神经网络" class="headerlink" title="如何选择神经网络"></a>如何选择神经网络</h2><p>下表列出了各种不同的问题和每种问题最适用的神经网络：</p><table><thead><tr><th>数据类型</th><th>应用案例</th><th>输入</th><th>变换</th><th>神经网络</th></tr></thead><tbody><tr><td>文本</td><td>情感分析</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文本</td><td>命名实体识别</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文本</td><td>词性标注</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文本</td><td>词性标注</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文本</td><td>语义角色标记</td><td>词向量</td><td>高斯修正</td><td>RNTN或DBN（采用移动窗口）</td></tr><tr><td>文档</td><td>主题建模/语义哈希（无监督）</td><td>词频概率</td><td>可为二进制</td><td>深度自动编码器（包装一个DBN或SDA）</td></tr><tr><td>文档</td><td>文档分类（有监督）</td><td>TF-IDF（或词频概率）</td><td>二进制</td><td>深度置信网络、堆叠式降噪自动编码器</td></tr><tr><td>图像</td><td>图像识别</td><td>二进制</td><td>二进制（可见及隐藏层）</td><td>深度置信网络</td></tr><tr><td>图像</td><td>图像识别</td><td>连续</td><td>高斯修正</td><td>深度置信网络</td></tr><tr><td>图像</td><td>多对象识别</td><td>N/A</td><td>高斯修正</td><td>卷积网络、RNTN（图像向量化）</td></tr><tr><td>图像</td><td>图像搜索/语义哈希</td><td>N/A</td><td>高斯修正</td><td>深度自动编码器（包装一个DBN）</td></tr><tr><td>声音</td><td>语音识别</td><td>N/A</td><td>高斯修正</td><td>循环网络</td></tr><tr><td>声音</td><td>语音识别</td><td>N/A</td><td>高斯修正</td><td>移动窗口，DBN或卷积网络</td></tr><tr><td>时间序列</td><td>预测分析</td><td>N/A</td><td>高斯修正</td><td>循环网络</td></tr><tr><td>时间序列</td><td>预测分析</td><td>N/A</td><td>高斯修正</td><td>移动窗口，DBN或卷积网络</td></tr></tbody></table><p><strong>注</strong>：高斯修正 = Gaussian Rectified | 语义哈希 = Semantic Hashing</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/dl-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;仅以此图，催眠我学习deep learning的动力！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深度学习的实质无非如此：根据模型产生的误差调整模型中的诸多权重，直到误差不能再减少为止&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Bias（偏差）-amp-Variance（方差）-amp-Error-误差-的区别&quot;&gt;&lt;a href=&quot;#Bias（偏差）-amp-Variance（方差）-amp-Error-误差-的区别&quot; class=&quot;headerlink&quot; title=&quot;Bias（偏差）&amp;amp;Variance（方差）&amp;amp;Error(误差)的区别&quot;&gt;&lt;/a&gt;Bias（偏差）&amp;amp;Variance（方差）&amp;amp;Error(误差)的区别&lt;/h2&gt;&lt;p&gt;首先&lt;code&gt;Error = Bias + Variance&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Error&lt;/code&gt;反映的是整个模型的准确度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bias&lt;/code&gt;反映的是模型在样本上的输出与真实值之间的误差，即模型本身的&lt;strong&gt;精准度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Variance&lt;/code&gt;反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的&lt;strong&gt;精确性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="deep learning" scheme="https://zacard.net/tags/deep-learning/"/>
    
      <category term="machine learning" scheme="https://zacard.net/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch官网文档阅读记录</title>
    <link href="https://zacard.net/2017/12/12/elasticsearch-query/"/>
    <id>https://zacard.net/2017/12/12/elasticsearch-query/</id>
    <published>2017-12-12T13:23:23.000Z</published>
    <updated>2018-01-12T13:33:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据官网文档及对公司日志平台es升级调优经验分享，如有错误，欢迎斧正。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul><li>环境调优 - 磨刀不误砍柴工</li><li>概念普及 - 步调一致</li><li>如何合理高效查询 - 查询说明</li><li>如果合理高效的写入（另外写）</li></ul><p>环境调优是先决条件，应对查询和写入都有帮助。重点分享查询，因为目前业务没有高频写入的场景</p><h2 id="环境调优"><a href="#环境调优" class="headerlink" title="环境调优"></a>环境调优</h2><p><strong>注意：配置只针对centos，其他系统未做测试</strong>。</p><h3 id="设置elasticsearch的jvm内存"><a href="#设置elasticsearch的jvm内存" class="headerlink" title="设置elasticsearch的jvm内存"></a>设置elasticsearch的jvm内存</h3><p>编辑<code>jvm.options</code>，添加一下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">-</span>Xms8g </div><div class="line"><span class="bullet">-</span>Xmx8g</div></pre></td></tr></table></figure><p><strong>注意：具体大小应当&lt;=系统内存的一半，建议直接设置为系统内存的一半</strong></p><h3 id="禁用swap交换空间"><a href="#禁用swap交换空间" class="headerlink" title="禁用swap交换空间"></a>禁用swap交换空间</h3><blockquote><p>大多数操作系统试图尽可能多地为文件系统缓存使用内存，并急切地交换掉未使用的应用程序内存。这可能会导致JVM堆的部分甚至将其可执行页被交换到磁盘。</p><p>交换对于性能、节点稳定性是非常不利的，应该不惜一切代价避免。它可能导致垃圾收集持续数分钟而不是毫秒，并可能导致节点响应缓慢，甚至可能断开与群集的连接。</p></blockquote><a id="more"></a><p>禁用虚拟内存,并让jvm锁定内存：</p><ol><li>swapoff -a</li><li>编辑文件<code>/etc/fstab</code>，注释掉所有包含<code>swap</code>的行</li><li>编辑文件<code>elasticsearch.yml</code>，添加配置<code>bootstrap.memory_lock: true</code></li></ol><p>验证是否锁定内存成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://121.41.84.118:9210/_nodes?filter_path=**.mlockall&amp;pretty&apos;</div></pre></td></tr></table></figure><h3 id="调整文件句柄数量"><a href="#调整文件句柄数量" class="headerlink" title="调整文件句柄数量"></a>调整文件句柄数量</h3><blockquote><p>Lucene 使用了 大量的 文件。 同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字（注：sockets）。所有这一切都需要足够的文件描述符</p></blockquote><p>先临时设置允许的文件句柄数量：</p><ol><li>sudo su</li><li>ulimit -n 65536</li><li>su elasticsearch</li></ol><p>以上确保在当前session生效，再永久设置：</p><p>编辑<code>/etc/security/limits.conf</code>，添加一行，内容为<code>elasticsearch  -  nofile  65536</code></p><p>验证是否设置成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -XGET &apos;http://121.41.84.118:9210/_nodes/stats/process?filter_path=**.max_file_descriptors&amp;pretty&apos;</div></pre></td></tr></table></figure><h3 id="调整文件映射数量"><a href="#调整文件映射数量" class="headerlink" title="调整文件映射数量"></a>调整文件映射数量</h3><blockquote><p>Elasticsearch 对各种文件混合使用了 NioFs（ 注：非阻塞文件系统）和 MMapFs （ 注：内存映射文件系统）。请确保你配置的最大映射数量，以便有足够的虚拟内存可用于 mmapped 文件</p></blockquote><p>先临时设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -w vm.max_map_count=262144</div></pre></td></tr></table></figure><p>再永久修改：</p><p>编辑<code>/etc/sysctl.conf</code>，添加<code>vm.max_map_count=262144</code></p><h3 id="调整允许的线程数量"><a href="#调整允许的线程数量" class="headerlink" title="调整允许的线程数量"></a>调整允许的线程数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -u 4096</div></pre></td></tr></table></figure><h2 id="概念普及"><a href="#概念普及" class="headerlink" title="概念普及"></a>概念普及</h2><p>index(名词)：索引 ≈ mysql中的库（database）<br>type：类型 ≈ mysql中的表<br>document：文档 ≈ mysql中的一行数据<br>share：分片 ≈ mysql中的数据分表<br>replicas：副本，即数据分片备份</p><p>index(动词)：为文档创建索引</p><h3 id="分片与副本"><a href="#分片与副本" class="headerlink" title="分片与副本"></a>分片与副本</h3><p>一个索引应设置几个分片，几个副本才合理？</p><h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>分片副本用来应对不断攀升的吞吐量以及确保数据的安全性.副本可以动态改变，默认为1份副本，比较合理。</p><p>当查询吞吐量跟不上时，可以考虑增加副本数量。</p><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>分片无法动态指定，只能在创建index的时候指定。（why？）<br>但是默认设置5个分片，这通常来说属于过度分配，这是作者考虑到数据迁移成本的权衡。</p><p>原则就是最小分片。多个分片对于查询和写入都有额外消耗。</p><p>什么时候该违反这个原则？</p><ul><li>由于单个分片有数量上限（Integer.MAX_VALUE=2147483647）</li><li>单机资源限制，如单个分片所占用磁盘过大</li><li><strong>为了吞吐量和单机热点</strong>，大数量写入被分到不同集群中的不同分片中，避免频繁写入占用过多系统资源，从这点看，也能加快查询吞吐量</li></ul><p><strong>所以，根据“经验法则”，小集群时合理的分片数量==节点数量</strong></p><h2 id="如何合理高效查询"><a href="#如何合理高效查询" class="headerlink" title="如何合理高效查询"></a>如何合理高效查询</h2><p>elasticsearch的查询可以在主分片和副本分片查询</p><h3 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h3><p>根据_id查询流程图：</p><p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0403.png" alt=""></p><p>以下是从主分片或者副本分片检索文档的步骤顺序：</p><ol><li>客户端向<code>Node 1</code>发送获取请求</li><li>节点使用文档的 _id 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到<code>Node 2</code></li><li><code>Node 2</code>将文档返回给<code>Node 1</code>，然后将文档返回给客户端</li></ol><p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡</p><p>如果查询有全文检索和聚合操作（例如排序），elasticsearch需要每个分片都执行查询，并把结果返回给协调节点，由协调节点进行聚合操作后再返回被客户端。</p><h4 id="如何路由一个文档到一个分片"><a href="#如何路由一个文档到一个分片" class="headerlink" title="如何路由一个文档到一个分片"></a>如何路由一个文档到一个分片</h4><p>根据以下公式：</p><p><code>shard = hash(routing) % number_of_primary_shards</code></p><blockquote><p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过 hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到 余数</p></blockquote><p>这也是为何副本数量能够动态修改，而分片数量需要创建索引时就确定好 – <strong>因为如果分片数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了</strong></p><h3 id="查询原理"><a href="#查询原理" class="headerlink" title="查询原理"></a>查询原理</h3><ul><li>倒排索引</li><li>精确值 &amp; 全文域</li><li>query查询 &amp; filter查询</li></ul><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p><img src="http://hcsem.com/wp-content/uploads/2011/11/image061.jpg" alt=""></p><p>倒排索引为何叫倒排索引？</p><p>一个普通的数据库中，一般是以文档ID作为索引，以文档内容作为记录。<br>而倒排索引指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。刚好倒过来。</p><blockquote><p>思考：有没有更好快的数据结构？如果有，为何不用？</p></blockquote><h4 id="精确值-amp-全文域"><a href="#精确值-amp-全文域" class="headerlink" title="精确值 &amp; 全文域"></a>精确值 &amp; 全文域</h4><p>elasticsearch中数据类型大致可以分为2类：精确值和全文域</p><blockquote><p><strong>精确值</strong>如它们听起来那样精确。例如日期或者用户ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，Foo和foo是不同的，2014和2014-09-15也是不同的</p></blockquote><p>精确值很容易查询。结果是明确的：要么匹配查询，要么不匹配</p><blockquote><p>全文通常是指非结构化的数据，但这里有一个误解：自然语言是高度结构化的。问题在于自然语言的规则是复杂的，导致计算机难以正确解析</p></blockquote><p>查询全文数据要微妙的多。我们问的不只是“这个文档匹配查询吗”，而是“该文档匹配查询的程度有多大？”换句话说，该文档与给定查询的相关性如何？</p><p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的意图：</p><ul><li>搜索 UK ，会返回包含 United Kindom 的文档。</li><li>搜索 jump ，会匹配 jumped ， jumps ， jumping ，甚至是 leap 。</li><li>搜索 johnny walker 会匹配 Johnnie Walker ， johnnie depp 应该匹配 Johnny Depp</li><li>fox news hunting 应该返回福克斯新闻（ Foxs News ）中关于狩猎的故事，同时，fox hunting news 应该返回关于猎狐的故事</li></ul><p>举例：西红柿&amp;番茄、芝士 &amp; 奶酪</p><h3 id="分页原理"><a href="#分页原理" class="headerlink" title="分页原理"></a>分页原理</h3><p>Elasticsearch 接受 from 和 size 参数：</p><p>size<br>显示应该返回的结果数量，默认是 10<br>from<br>显示应该跳过的初始结果数量，默认是 0</p><blockquote><p>考虑到分页过深以及一次请求太多结果的情况，结果集在返回之前先进行排序。 但请记住一个请求经常跨越多个分片，每个分片都产生自己的排序结果，这些结果需要进行<strong>集中排序</strong>以保证整体顺序是正确的</p></blockquote><p>注意：谨慎使用深度分页</p><blockquote><p>理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。</p><p>现在假设我们请求第 1000 页–结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。</p><p>可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因</p></blockquote><p>elasticsearch默认限制最多分页10000条数据，可以用<code>index.max_result_window</code>参数覆盖配置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据官网文档及对公司日志平台es升级调优经验分享，如有错误，欢迎斧正。&lt;/p&gt;
&lt;h2 id=&quot;主题&quot;&gt;&lt;a href=&quot;#主题&quot; class=&quot;headerlink&quot; title=&quot;主题&quot;&gt;&lt;/a&gt;主题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;环境调优 - 磨刀不误砍柴工&lt;/li&gt;
&lt;li&gt;概念普及 - 步调一致&lt;/li&gt;
&lt;li&gt;如何合理高效查询 - 查询说明&lt;/li&gt;
&lt;li&gt;如果合理高效的写入（另外写）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;环境调优是先决条件，应对查询和写入都有帮助。重点分享查询，因为目前业务没有高频写入的场景&lt;/p&gt;
&lt;h2 id=&quot;环境调优&quot;&gt;&lt;a href=&quot;#环境调优&quot; class=&quot;headerlink&quot; title=&quot;环境调优&quot;&gt;&lt;/a&gt;环境调优&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注意：配置只针对centos，其他系统未做测试&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;设置elasticsearch的jvm内存&quot;&gt;&lt;a href=&quot;#设置elasticsearch的jvm内存&quot; class=&quot;headerlink&quot; title=&quot;设置elasticsearch的jvm内存&quot;&gt;&lt;/a&gt;设置elasticsearch的jvm内存&lt;/h3&gt;&lt;p&gt;编辑&lt;code&gt;jvm.options&lt;/code&gt;，添加一下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt;Xms8g &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;bullet&quot;&gt;-&lt;/span&gt;Xmx8g&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：具体大小应当&amp;lt;=系统内存的一半，建议直接设置为系统内存的一半&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;禁用swap交换空间&quot;&gt;&lt;a href=&quot;#禁用swap交换空间&quot; class=&quot;headerlink&quot; title=&quot;禁用swap交换空间&quot;&gt;&lt;/a&gt;禁用swap交换空间&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;大多数操作系统试图尽可能多地为文件系统缓存使用内存，并急切地交换掉未使用的应用程序内存。这可能会导致JVM堆的部分甚至将其可执行页被交换到磁盘。&lt;/p&gt;
&lt;p&gt;交换对于性能、节点稳定性是非常不利的，应该不惜一切代价避免。它可能导致垃圾收集持续数分钟而不是毫秒，并可能导致节点响应缓慢，甚至可能断开与群集的连接。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="elasticsearch" scheme="https://zacard.net/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>分布式追踪系统x-apm开发经历分享</title>
    <link href="https://zacard.net/2017/11/06/apm-share/"/>
    <id>https://zacard.net/2017/11/06/apm-share/</id>
    <published>2017-11-06T13:45:22.000Z</published>
    <updated>2017-11-07T08:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>感谢<a href="https://www.dingdangss.com/" target="_blank" rel="external">@dingdang</a>对开发的强力支持。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在公司微服务化转型后，系统被拆分为多个由不同开发团队维护的分布式微服务。随着业务的发展，分布式服务越来越多，其关系越来越复杂。我们亟需一个工具能够梳理内部服务之间的关系，感知上下游服务的形态，快速定位冗长服务调用间的问题。</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/mtrace1.png" alt=""></p><p>需要解决的核心问题：</p><ul><li>一次请求的完整调用链</li><li>一次请求出现异常，能快速定位那个节点出现问题</li><li>一次请求经历的服务的详细信息</li><li>一次请求的瓶颈节点，并对节点资源分配提供数据支持</li><li>一次请求中出现异常、超时自动报警</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了解决以上问题，自研了一个分布式追踪系统X-APM(APM = Application Performance Management，应用性能管理).其核心就是调用链：通过一个全局的ID将分布在各个服务节点上的同一次请求串联起来，还原原有的调用关系、追踪系统问题、分析调用数据、统计系统指标。<br>在阅读google 《dapper》的思想，<a href="https://wu-sheng.gitbooks.io/opentracing-io/content/" target="_blank" rel="external">open traceing</a>的理念后,实现参考了<a href="https://github.com/OpenSkywalking/skywalking" target="_blank" rel="external">skywalking</a></p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><ul><li>低损耗: 对微服务的影响越低越好，包括cpu、内存、tps、响应时间等指标</li><li>低侵入: 作为非业务组件，应当尽可能少侵入或者无侵入其他业务系统，对于使用方透明，减少开发人员的负担</li><li>低延迟: 从数据的产生和收集，到数据计算和处理，再到最终展现，都要求尽可能快</li><li>可配置: 可以通过配置决定所收集数据的范围和粒度</li><li>可视化: 能够以图表方式展示调用链路等信息</li><li>可预警: 分析跟踪到的调用链数据，当出现调用耗时时间过长、调用异常、重复调用等情况，及时警告</li><li>决策支持: 这些数据最好能在决策支持层面发挥作用</li></ul><a id="more"></a><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/tarce-jg.png" alt=""></p><p>各业务系统使用x-apm的agent探针来处理调用链路信息的采集，当采集的信息达到一定量或每隔一段特定的时间时，agent将会把这些信息传送到Flume，通过flume的channel缓冲区流向到指定的sink。目前项目一期已支持将数据保存至ES，并通过UI项目读取ES数据，方便大家在页面上以图表的形式查看各业务系统的调用链路信息。</p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>对于理解分布式追踪系统的领域模型，我强烈建议先阅读<a href="https://wu-sheng.gitbooks.io/opentracing-io/content/" target="_blank" rel="external">open traceing</a>，能够理解在分布式追踪系统中，Trace、Span、Tag等基本概念。</p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>一个trace代表一个潜在的，分布式的，存在并行数据或并行执行轨迹（潜在的分布式、并行）的系统。一个trace可以认为是多个span的有向无环图（DAG）。</p><h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p>一个span代表系统中具有开始时间和执行时长的逻辑运行单元。span之间通过嵌套或者顺序排列建立逻辑因果关系。</p><h3 id="trace与span的关系"><a href="#trace与span的关系" class="headerlink" title="trace与span的关系"></a>trace与span的关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">一个tracer过程中，各span的关系</div><div class="line"></div><div class="line"></div><div class="line">        [Span A]  ←←←(the root span)</div><div class="line">            |</div><div class="line">     +------+------+</div><div class="line">     |             |</div><div class="line"> [Span B]      [Span C] ←←←(Span C 是 Span A 的孩子节点, ChildOf)</div><div class="line">     |             |</div><div class="line"> [Span D]      +---+-------+</div><div class="line">               |           |</div><div class="line">           [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]</div><div class="line">                                       ↑</div><div class="line">                                       ↑</div><div class="line">                                       ↑</div><div class="line">                         (Span G 在 Span F 后被调用, FollowsFrom)</div><div class="line"></div><div class="line">上述tracer与span的时间轴关系</div><div class="line"></div><div class="line"></div><div class="line">––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time</div><div class="line"></div><div class="line"> [Span A···················································]</div><div class="line">   [Span B··············································]</div><div class="line">      [Span D··········································]</div><div class="line">    [Span C········································]</div><div class="line">         [Span E·······]        [Span F··] [Span G··] [Span H··]</div></pre></td></tr></table></figure><h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/TraceSegment.png" alt=""></p><p>简单解释：</p><ul><li>TraceSegment: 一次分布式Trace中可能会经历多个微服务系统，每个系统都是一个TraceSegment(追踪链的一部分)，所有经过的微服务TraceSegment组合在一起，才是一次完整的Trace</li><li>Span: 正如open traceing中的概念，记录调用链中某个功能、某个组件的详细信息</li><li>TraceSegmentRef: 各个微服务系统的TraceSegment之间的关系(调用顺序)</li><li>DistributedTraceIds: 记录各个微服务系统的追踪id</li><li>DistributedTraceId: 分布式追踪id，全局唯一</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这里只讲agent端的原理。因为后面的数据收集使用flume，数据存储使用elasticsearch，实时流分析使用spark，就不细说了</p><h3 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h3><p>为了无侵入，数据埋点采用<a href="https://en.wikipedia.org/wiki/Java_Agent_Development_Framework" target="_blank" rel="external">javaagent</a>配合<a href="https://github.com/raphw/byte-buddy" target="_blank" rel="external">bytebuddy</a>完成。</p><ul><li>javaagent: 主要利用<strong>instrument agent</strong>,其可以在加载class文件之前做拦截，对字节码做修改</li><li>bytebuddy: 修改字节码</li></ul><p>对所有中间件、框架、类库、本地方法的数据埋点，都采用<strong>Plugin</strong>的形式实现，做到自动化、可插拔、可配置、低耦合。</p><p><strong>延伸：javaagent的what、how、why</strong></p><h3 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h3><p>由于埋点是动态织入到字节码的功能增强，如何快速高效的收集而不阻塞正常业务系统的流程是个关键。</p><p>具体设计考虑：</p><ol><li>如何收集数据: 收集的数据在发送前怎么存，收集的速度大于发送的速度的时候，又该怎么办？</li><li>如何发送数据: 异步发送数据到flume，但又不能开启太多线程，以免抢占业务系统线程资源，这个线程数设定多大合适呢？</li><li>如何保证数据完整性: 高并发，大数据量下，如何保证数据的完整性？</li></ol><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>方案注意点：</p><ul><li>埋点数据无需落盘，直接发送到flume.在业务系统节点落盘追踪数据毫无意义，徒耗节点系统资源</li><li>埋点数据不能一收到就发送，得批量发送</li></ul><p>最终实现：</p><p>以数组为基础，实现一个<strong>环形结构的无锁数据缓冲区</strong>，批量发送埋点数据。数据结构如下：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/TraceSegmentCollector.png" alt=""></p><ul><li>buffer: 缓存区</li><li>bufferSize: 缓存区大小</li><li>everySendSize: 每次批量发送的数量</li><li>currentIndex: 缓存区当前位置索引</li></ul><p>实现细节：</p><ol><li>对于追踪系统而言，<strong>当收集速度大于发送速度，应该果断丢弃数据</strong>。因为埋点的数据是可重复的且不能影响业务系统，而且本身很多追踪系统是有采样率的，即不是每次的埋点数据都会收集。当丢弃数据达到一定程度的时候会输出一条警告日志，spark中的日志实时分析会对该日志预警</li><li>对于保证数据的完整性，我们采用<strong>宁可丢弃数据，也不能有重复数据</strong>。因为重复的数据将对后续调用链分析，预警，数据统计，流量分析造成比较大的影响</li><li><p>如何实现环形的缓存区，只需要让缓存区的位置索引<code>currentIndex</code>始终在<code>1~bufferSize</code>内原子变动即可，请看以下示例代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用cas操作，获取buffer位置索引</span></div><div class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">   <span class="keyword">int</span> current = currentIndex.get();</div><div class="line">       <span class="keyword">int</span> next = current &gt;= bufferSize ? <span class="number">1</span> : current + <span class="number">1</span>;</div><div class="line">       <span class="keyword">if</span> (currentIndex.compareAndSet(current, next)) &#123;</div><div class="line">       <span class="keyword">return</span> next;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li><li><p>如何实现无锁，核心还是cas操作，请看以下代码示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只有数组中index位置上为null的才设置新值</span></div><div class="line">   <span class="keyword">if</span> (!casObject(index, <span class="keyword">null</span>, traceSegment)) &#123;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 判断是否需要发送数据</span></div><div class="line">   <span class="comment">// a % b == a &amp; (b - 1)</span></div><div class="line">   <span class="keyword">if</span> ((nextIndex &amp; (everySendSize - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 收集缓冲区数据发送</span></div><div class="line">   collectBufferToSend(index, everySendSize);</div></pre></td></tr></table></figure></li></ol><p>ps: 这里有个强制约定，bufferSize和everySendSize的大小必须为2^n.因为计算是否需要批量发送的时候要用到<code>%</code>操作，<code>%</code>操作是个相对比较昂贵的操作。所以这里我们有个取巧，当计算<code>a%b</code>,且<code>b=2^n</code>的时候，<code>a%b==a&amp;(b-1)</code>,位移操作将高效的多。</p><h4 id="方案benchmark"><a href="#方案benchmark" class="headerlink" title="方案benchmark"></a>方案benchmark</h4><p>为了检验环形数据结构的性能，我们专门写了benchmark，使用openjdk.jmh测试，benchmark代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Threads</span>(value = Threads.MAX)</div><div class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">1</span>, time = <span class="number">10</span>, timeUnit = TimeUnit.MILLISECONDS)</div><div class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">1</span>, time = <span class="number">10</span>, timeUnit = TimeUnit.MILLISECONDS)</div><div class="line"><span class="meta">@Fork</span>(value = <span class="number">1</span>)</div><div class="line"><span class="meta">@Benchmark</span></div><div class="line"><span class="meta">@BenchmarkMode</span>(value = Mode.Throughput)</div><div class="line"><span class="meta">@OutputTimeUnit</span>(value = TimeUnit.MILLISECONDS)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchMarkCollector</span><span class="params">()</span> </span>&#123;</div><div class="line">    collector(mockData.getAndIncrement());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><ol><li>flume挂了怎么办？</li><li>agent出异常了怎么办？</li><li>agent如何升级？</li></ol><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>flume是个集群，单点故障可以无视，有重试机制。当全部flume都挂了的时候，agent端的数据将全部丢失，并且agent端将进入每隔30s的无限重连flume操作</li><li>agent的异常被全局catch，输出到日志，后面spark日志实时流分析预警。</li><li>agent的升级比较简单，由于项目使用docker部署，所以升级的时候，只要替换docker仓库中的基础镜像中的agent包即可。</li></ul><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/trace-zy-1.png" alt=""></p><p>cpu额外消耗保持在7%以内，内存基本无变化</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/trace-zy-2.png" alt=""></p><p>tps和响应时间基本无变化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢&lt;a href=&quot;https://www.dingdangss.com/&quot;&gt;@dingdang&lt;/a&gt;对开发的强力支持。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在公司微服务化转型后，系统被拆分为多个由不同开发团队维护的分布式微服务。随着业务的发展，分布式服务越来越多，其关系越来越复杂。我们亟需一个工具能够梳理内部服务之间的关系，感知上下游服务的形态，快速定位冗长服务调用间的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/mtrace1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要解决的核心问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一次请求的完整调用链&lt;/li&gt;
&lt;li&gt;一次请求出现异常，能快速定位那个节点出现问题&lt;/li&gt;
&lt;li&gt;一次请求经历的服务的详细信息&lt;/li&gt;
&lt;li&gt;一次请求的瓶颈节点，并对节点资源分配提供数据支持&lt;/li&gt;
&lt;li&gt;一次请求中出现异常、超时自动报警&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;为了解决以上问题，自研了一个分布式追踪系统X-APM(APM = Application Performance Management，应用性能管理).其核心就是调用链：通过一个全局的ID将分布在各个服务节点上的同一次请求串联起来，还原原有的调用关系、追踪系统问题、分析调用数据、统计系统指标。&lt;br&gt;在阅读google 《dapper》的思想，&lt;a href=&quot;https://wu-sheng.gitbooks.io/opentracing-io/content/&quot;&gt;open traceing&lt;/a&gt;的理念后,实现参考了&lt;a href=&quot;https://github.com/OpenSkywalking/skywalking&quot;&gt;skywalking&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;设计目标&quot;&gt;&lt;a href=&quot;#设计目标&quot; class=&quot;headerlink&quot; title=&quot;设计目标&quot;&gt;&lt;/a&gt;设计目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;低损耗: 对微服务的影响越低越好，包括cpu、内存、tps、响应时间等指标&lt;/li&gt;
&lt;li&gt;低侵入: 作为非业务组件，应当尽可能少侵入或者无侵入其他业务系统，对于使用方透明，减少开发人员的负担&lt;/li&gt;
&lt;li&gt;低延迟: 从数据的产生和收集，到数据计算和处理，再到最终展现，都要求尽可能快&lt;/li&gt;
&lt;li&gt;可配置: 可以通过配置决定所收集数据的范围和粒度&lt;/li&gt;
&lt;li&gt;可视化: 能够以图表方式展示调用链路等信息&lt;/li&gt;
&lt;li&gt;可预警: 分析跟踪到的调用链数据，当出现调用耗时时间过长、调用异常、重复调用等情况，及时警告&lt;/li&gt;
&lt;li&gt;决策支持: 这些数据最好能在决策支持层面发挥作用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="apm" scheme="https://zacard.net/tags/apm/"/>
    
      <category term="javaagent" scheme="https://zacard.net/tags/javaagent/"/>
    
  </entry>
  
  <entry>
    <title>如何处理InterruptedException</title>
    <link href="https://zacard.net/2017/09/20/howto-handle-InterruptedException/"/>
    <id>https://zacard.net/2017/09/20/howto-handle-InterruptedException/</id>
    <published>2017-09-20T11:15:03.000Z</published>
    <updated>2017-09-21T14:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一直对于如何合理的处理InterruptedException不是很清晰.</p><p>参考以下链接内容理解：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp05236.html" target="_blank" rel="external">传送门</a></p><h2 id="什么是InterruptedException"><a href="#什么是InterruptedException" class="headerlink" title="什么是InterruptedException"></a>什么是InterruptedException</h2><p>先来看看InterruptedException的java doc说明：</p><blockquote><p>Thrown when a thread is waiting, sleeping, or otherwise occupied,<br> and the thread is interrupted, either before or during the activity.<br> Occasionally a method may wish to test whether the current<br> thread has been interrupted, and if so, to immediately throw<br> this exception.  The following code can be used to achieve<br> this effect:<br> <pre><br>  if (Thread.interrupted())  // Clears interrupted status!<br>      throw new InterruptedException();<br> </pre></p></blockquote><p>就是说只有在线程处于<code>Object.wait()</code>、<code>Thread.sleep()</code>或者被occupied(应该是指类似<code>LockSupport.park()</code>),并且线程被中断时会抛出InterruptedException异常。</p><p>如果有某个方法希望测试当前线程是否被中断，如果中断就抛出异常，有个推荐的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Thread.interrupted())  <span class="comment">// Clears interrupted status!</span></div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div></pre></td></tr></table></figure><a id="more"></a><h2 id="阻塞方法"><a href="#阻塞方法" class="headerlink" title="阻塞方法"></a>阻塞方法</h2><p>当一个方法抛出InterruptedException时，它不仅告诉您它可以抛出一个特定的检查异常，而且还告诉您其他一些事情。例如，它告诉您它是一个阻塞（blocking）方法，如果您响应得当的话，它将尝试消除阻塞并尽早返回。</p><p>阻塞方法不同于一般的要运行较长时间的方法。一般方法的完成只取决于它所要做的事情，以及是否有足够多可用的计算资源（CPU周期和内存）。而阻塞方法的完成还取决于一些外部的事件，例如计时器到期，I/O 完成，或者另一个线程的动作（释放一个锁，设置一个标志，或者将一个任务放在一个工作队列中）。一般方法在它们的工作做完后即可结束，而阻塞方法较难于预测，因为它们取决于外部事件。阻塞方法可能影响响应能力，因为难于预测它们何时会结束。</p><p><strong>阻塞方法可能因为等不到所等的事件而无法终止，因此令阻塞方法可取消就非常有用（如果长时间运行的非阻塞方法是可取消的，那么通常也非常有用）</strong>。可取消操作是指能从外部使之在正常完成之前终止的操作。由Thread提供并受Thread.sleep()和Object.wait()支持的中断机制就是一种取消机制；它允许一个线程请求另一个线程停止它正在做的事情。<strong>当一个方法抛出 InterruptedException时，它是在告诉您，如果执行该方法的线程被中断，它将尝试停止它正在做的事情而提前返回，并通过抛出InterruptedException表明它提前返回</strong>。 行为良好的阻塞库方法应该能对中断作出响应并抛出InterruptedException，以便能够用于可取消活动中，而不至于影响响应。</p><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>每个线程都有一个与之相关联的 Boolean 属性，用于表示线程的中断状态（interrupted status）。中断状态初始时为 false；当另一个线程通过调用 Thread.interrupt() 中断一个线程时，会出现以下两种情况之一。如果那个线程在执行一个低级可中断阻塞方法，例如 Thread.sleep()、 Thread.join() 或 Object.wait()，那么它将取消阻塞并抛出 InterruptedException。否则， interrupt() 只是设置线程的中断状态。 在被中断线程中运行的代码以后可以轮询中断状态，看看它是否被请求停止正在做的事情。中断状态可以通过 Thread.isInterrupted() 来读取，并且可以通过一个名为 Thread.interrupted() 的操作读取和清除。</p><p>中断是一种协作机制。当一个线程中断另一个线程时，被中断的线程不一定要立即停止正在做的事情。相反，中断是礼貌地请求另一个线程在它愿意并且方便的时候停止它正在做的事情。有些方法，例如 Thread.sleep()，很认真地对待这样的请求，但每个方法不是一定要对中断作出响应。对于中断请求，不阻塞但是仍然要花较长时间执行的方法可以轮询中断状态，并在被中断的时候提前返回。 您可以随意忽略中断请求，但是这样做的话会影响响应。</p><p>中断的协作特性所带来的一个好处是，它为安全地构造可取消活动提供更大的灵活性。我们很少希望一个活动立即停止；如果活动在正在进行更新的时候被取消，那么程序数据结构可能处于不一致状态。中断允许一个可取消活动来清理正在进行的工作，恢复不变量，通知其他活动它要被取消，然后才终止。</p><h2 id="处理InterruptedException"><a href="#处理InterruptedException" class="headerlink" title="处理InterruptedException"></a>处理InterruptedException</h2><p>如果抛出 InterruptedException 意味着一个方法是阻塞方法，那么调用一个阻塞方法则意味着您的方法也是一个阻塞方法，而且您应该有某种策略来处理 InterruptedException。通常最容易的策略是自己抛出 InterruptedException，如清单 1 中 putTask() 和 getTask() 方法中的代码所示。 这样做可以使方法对中断作出响应，并且只需将 InterruptedException 添加到 throws 子句。</p><p>清单 1. 不捕捉 InterruptedException，将它传播给调用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TASKS = <span class="number">1000</span>;</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue </div><div class="line">        = <span class="keyword">new</span> LinkedBlockingQueue&lt;Task&gt;(MAX_TASKS);</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putTask</span><span class="params">(Task r)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </div><div class="line">        queue.put(r);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </div><div class="line">        <span class="keyword">return</span> queue.take();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有时候需要在传播异常之前进行一些清理工作。在这种情况下，可以捕捉InterruptedException，执行清理，然后抛出异常。清单 2 演示了这种技术，该代码是用于匹配在线游戏服务中的玩家的一种机制。 matchPlayers() 方法等待两个玩家到来，然后开始一个新游戏。如果在一个玩家已到来，但是另一个玩家仍未到来之际该方法被中断，那么它会将那个玩家放回队列中，然后重新抛出 InterruptedException，这样那个玩家对游戏的请求就不至于丢失。<br>清单 2. 在重新抛出 InterruptedException 之前执行特定于任务的清理工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerMatcher</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> PlayerSource players;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlayerMatcher</span><span class="params">(PlayerSource players)</span> </span>&#123; </div><div class="line">        <span class="keyword">this</span>.players = players; </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchPlayers</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">             Player playerOne, playerTwo;</div><div class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                 playerOne = playerTwo = <span class="keyword">null</span>;</div><div class="line">                 <span class="comment">// Wait for two players to arrive and start a new game</span></div><div class="line">                 playerOne = players.waitForPlayer(); <span class="comment">// could throw IE</span></div><div class="line">                 playerTwo = players.waitForPlayer(); <span class="comment">// could throw IE</span></div><div class="line">                 startNewGame(playerOne, playerTwo);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">             <span class="comment">// If we got one player and were interrupted, put that player back</span></div><div class="line">             <span class="keyword">if</span> (playerOne != <span class="keyword">null</span>)</div><div class="line">                 players.addFirst(playerOne);</div><div class="line">             <span class="comment">// Then propagate the exception</span></div><div class="line">             <span class="keyword">throw</span> e;</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="不要生吞中断"><a href="#不要生吞中断" class="headerlink" title="不要生吞中断"></a>不要生吞中断</h3><p>有时候抛出 InterruptedException 并不合适，例如当由 Runnable 定义的任务调用一个可中断的方法时，就是如此。在这种情况下，不能重新抛出 InterruptedException，但是您也不想什么都不做。当一个阻塞方法检测到中断并抛出 InterruptedException 时，它清除中断状态。如果捕捉到 InterruptedException 但是不能重新抛出它，那么应该保留中断发生的证据，以便调用栈中更高层的代码能知道中断，并对中断作出响应。该任务可以通过调用 interrupt() 以 “重新中断” 当前线程来完成，如清单 3 所示。至少，每当捕捉到 InterruptedException 并且不重新抛出它时，就在返回之前重新中断当前线程。</p><p>清单 3. 捕捉 InterruptedException 后恢复中断状态:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123; </div><div class="line">        <span class="keyword">this</span>.queue = queue; </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                 Task task = queue.take(<span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">                 task.execute();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">catch</span> (InterruptedException e) &#123; </div><div class="line">             <span class="comment">// Restore the interrupted status</span></div><div class="line">             Thread.currentThread().interrupt();</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>处理 InterruptedException 时采取的最糟糕的做法是生吞它 —— 捕捉它，然后既不重新抛出它，也不重新断言线程的中断状态。对于不知如何处理的异常，最标准的处理方法是捕捉它，然后记录下它，但是这种方法仍然无异于生吞中断，因为调用栈中更高层的代码还是无法获得关于该异常的信息。（仅仅记录 InterruptedException 也不是明智的做法，因为等到人来读取日志的时候，再来对它作出处理就为时已晚了。） 清单 4 展示了一种使用得很广泛的模式，这也是生吞中断的一种模式：</p><p>清单 4. 生吞中断 —— 不要这么做:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Don't do this </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> BlockingQueue&lt;Task&gt; queue;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123; </div><div class="line">        <span class="keyword">this</span>.queue = queue; </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                 Task task = queue.take(<span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">                 task.execute();</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">catch</span> (InterruptedException swallowed) &#123; </div><div class="line">             <span class="comment">/* DON'T DO THIS - RESTORE THE INTERRUPTED STATUS INSTEAD */</span></div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>如果不能重新抛出 InterruptedException，不管您是否计划处理中断请求，仍然需要重新中断当前线程，因为一个中断请求可能有多个 “接收者”</strong>。标准线程池 （ThreadPoolExecutor）worker 线程实现负责中断，因此中断一个运行在线程池中的任务可以起到双重效果，一是取消任务，二是通知执行线程线程池正要关闭。如果任务生吞中断请求，则 worker 线程将不知道有一个被请求的中断，从而耽误应用程序或服务的关闭。</p><h2 id="实现可取消任务"><a href="#实现可取消任务" class="headerlink" title="实现可取消任务"></a>实现可取消任务</h2><p>语言规范中并没有为中断提供特定的语义，但是在较大的程序中，难于维护除取消外的任何中断语义。取决于是什么活动，用户可以通过一个 GUI 或通过网络机制，例如 JMX 或 Web 服务来请求取消。程序逻辑也可以请求取消。例如，一个 Web 爬行器（crawler）如果检测到磁盘已满，它会自动关闭自己，否则一个并行算法会启动多个线程来搜索解决方案空间的不同区域，一旦其中一个线程找到一个解决方案，就取消那些线程。</p><p>仅仅因为一个任务是可取消的，并不意味着需要立即 对中断请求作出响应。对于执行一个循环中的代码的任务，通常只需为每一个循环迭代检查一次中断。取决于循环执行的时间有多长，任何代码可能要花一些时间才能注意到线程已经被中断（或者是通过调用 Thread.isInterrupted() 方法轮询中断状态，或者是调用一个阻塞方法）。 如果任务需要提高响应能力，那么它可以更频繁地轮询中断状态。阻塞方法通常在入口就立即轮询中断状态，并且，如果它被设置来改善响应能力，那么还会抛出 InterruptedException。</p><p>惟一可以生吞中断的时候是您知道线程正要退出。只有当调用可中断方法的类是 Thread 的一部分，而不是 Runnable 或通用库代码的情况下，才会发生这样的场景，清单 5 演示了这种情况。清单 5 创建一个线程，该线程列举素数，直到被中断，这里还允许该线程在被中断时退出。用于搜索素数的循环在两个地方检查是否有中断：一处是在 while 循环的头部轮询 isInterrupted() 方法，另一处是调用阻塞方法 BlockingQueue.put()。</p><p>清单 5. 如果知道线程正要退出的话，则可以生吞中断:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</div><div class="line"> </div><div class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</div><div class="line">        <span class="keyword">this</span>.queue = queue;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            BigInteger p = BigInteger.ONE;</div><div class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())</div><div class="line">                queue.put(p = p.nextProbablePrime());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</div><div class="line">            <span class="comment">/* Allow thread to exit */</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; interrupt(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="不可中断的阻塞方法"><a href="#不可中断的阻塞方法" class="headerlink" title="不可中断的阻塞方法"></a>不可中断的阻塞方法</h3><p>并非所有的阻塞方法都抛出 InterruptedException。输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会提前返回。然而，对于套接字 I/O，如果一个线程关闭套接字，则那个套接字上的阻塞 I/O 操作将提前结束，并抛出一个 SocketException。java.nio 中的非阻塞 I/O 类也不支持可中断 I/O，但是同样可以通过关闭通道或者请求 Selector 上的唤醒来取消阻塞操作。类似地，尝试获取一个内部锁的操作（进入一个 synchronized 块）是不能被中断的，但是 ReentrantLock 支持可中断的获取模式。</p><h3 id="不可取消的任务"><a href="#不可取消的任务" class="headerlink" title="不可取消的任务"></a>不可取消的任务</h3><p>有些任务拒绝被中断，这使得它们是不可取消的。但是，即使是不可取消的任务也应该尝试保留中断状态，以防在不可取消的任务结束之后，调用栈上更高层的代码需要对中断进行处理。清单 6 展示了一个方法，该方法等待一个阻塞队列，直到队列中出现一个可用项目，而不管它是否被中断。为了方便他人，它在结束后在一个 finally 块中恢复中断状态，以免剥夺中断请求的调用者的权利。（它不能在更早的时候恢复中断状态，因为那将导致无限循环 —— BlockingQueue.take() 将在入口处立即轮询中断状态，并且，如果发现中断状态集，就会抛出 InterruptedException。）</p><p>清单 6. 在返回前恢复中断状态的不可取消任务:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> queue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// fall through and retry</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (interrupted)</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一直对于如何合理的处理InterruptedException不是很清晰.&lt;/p&gt;
&lt;p&gt;参考以下链接内容理解：&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-jtp05236.html&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是InterruptedException&quot;&gt;&lt;a href=&quot;#什么是InterruptedException&quot; class=&quot;headerlink&quot; title=&quot;什么是InterruptedException&quot;&gt;&lt;/a&gt;什么是InterruptedException&lt;/h2&gt;&lt;p&gt;先来看看InterruptedException的java doc说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thrown when a thread is waiting, sleeping, or otherwise occupied,&lt;br&gt; and the thread is interrupted, either before or during the activity.&lt;br&gt; Occasionally a method may wish to test whether the current&lt;br&gt; thread has been interrupted, and if so, to immediately throw&lt;br&gt; this exception.  The following code can be used to achieve&lt;br&gt; this effect:&lt;br&gt; &lt;pre&gt;&lt;br&gt;  if (Thread.interrupted())  // Clears interrupted status!&lt;br&gt;      throw new InterruptedException();&lt;br&gt; &lt;/pre&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是说只有在线程处于&lt;code&gt;Object.wait()&lt;/code&gt;、&lt;code&gt;Thread.sleep()&lt;/code&gt;或者被occupied(应该是指类似&lt;code&gt;LockSupport.park()&lt;/code&gt;),并且线程被中断时会抛出InterruptedException异常。&lt;/p&gt;
&lt;p&gt;如果有某个方法希望测试当前线程是否被中断，如果中断就抛出异常，有个推荐的用法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Thread.interrupted())  &lt;span class=&quot;comment&quot;&gt;// Clears interrupted status!&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InterruptedException();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="InterruptedException" scheme="https://zacard.net/tags/InterruptedException/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper迁移(扩容/缩容)实践</title>
    <link href="https://zacard.net/2017/08/29/howto-zookeeper-move/"/>
    <id>https://zacard.net/2017/08/29/howto-zookeeper-move/</id>
    <published>2017-08-29T10:22:11.000Z</published>
    <updated>2017-09-18T06:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于一些历史原因，目前zookeeper集群（3个节点）和elasticsearch、hadoop部署在一起，导致几个组件相互影响，性能也逐渐下降。甚至出现某个组件异常（例如oom）导致了其他组件不可用。</p><p>由于大量项目使用dubbo且依赖zookeeper作为注册中心，zookeeper的不稳定可能是致命的，所以计划先将zookeeper迁出到3台独立的节点，在此记录下迁移方案。</p><h2 id="zookeeper选举原理"><a href="#zookeeper选举原理" class="headerlink" title="zookeeper选举原理"></a>zookeeper选举原理</h2><p>在迁移前有必要了解zookeeper的选举原理，以便更科学的迁移。</p><h3 id="快速选举FastLeaderElection"><a href="#快速选举FastLeaderElection" class="headerlink" title="快速选举FastLeaderElection"></a>快速选举FastLeaderElection</h3><p>zookeeper默认使用快速选举，在此重点了解快速选举：</p><ol><li>向集群中的其他zookeeper建立连接，<strong>并且只有myid比对方大的连接才会被接受（也就是每2台只会有1个连接，避免连接浪费）</strong></li><li>每台zookeeper默认先投自己，然后向集群广播自己的选票</li><li>收到对方的选票时，依次比较epoch（选举轮数）、zxid（事务id）、myid，较大者胜出，更新选票并广播</li><li>如果收到的选票中有某个节点超过集群半数，则胜出当选为leader，其他节点为follower</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>zookeeper集群的数量应为奇数：</p><p>  <strong>因为根据paxos理论，只有集群中超过半数的节点还存活才能保证集群的一致性</strong>。假如目前集群有5个节点，我们最多允许2个节点不可用，因为3&gt;5\2。当集群扩容到6个节点的时候，我们仍然只能最多允许2个节点不可用，到3个节点不可用时，将不满足paxos理论，因为3&gt;6\2不成立。也就是说当集群节点数n为偶数时，其可用性与n-1是一样的，那我们何必多浪费一台机器呢？</p></li><li><p>由于zookeeper只允许mid大的节点连接到mid小的节点，我们启动zookeeper的顺序应该按照myid小的到myid大的，最后再启动leader节点！ </p></li></ul><a id="more"></a><h2 id="迁移目标"><a href="#迁移目标" class="headerlink" title="迁移目标"></a>迁移目标</h2><p>迁移过程中要保证原zookeeper集群还是能提供服务，新zookeeper集群同步老集群的数据，将zookeeper url指向新集群的3个节点，停掉老zookeeper集群。</p><p>相当于先扩容zookeeper,然后缩容zookeeper…</p><h2 id="迁移步骤"><a href="#迁移步骤" class="headerlink" title="迁移步骤"></a>迁移步骤</h2><p>原有zookeeper集群(server1、server2、server3)zoo.cfg配置如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div></pre></td></tr></table></figure><p>使用命令：<code>echo srvr | nc node{?} 2181</code>检查谁是leader({?}依次替换为1、2、3)</p><p>ps：也可以用<code>echo stat | nc node{?} 2181</code>显示更详细信息</p><p><strong>这里假设leader为node2.</strong>（按照正常情况，leader也理应是node2）</p><h3 id="步骤1：新增节点4"><a href="#步骤1：新增节点4" class="headerlink" title="步骤1：新增节点4"></a>步骤1：新增节点4</h3><ol><li>在<code>/data</code>目录创建mid文件，内容为4</li><li><p>配置zoo.cfg,内容如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div></pre></td></tr></table></figure></li><li><p>启动zookeeper：<code>{zookeeperDir}/bin/zkServer.sh start</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader，例如以下命令:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">Zookeeper version: <span class="number">3.4</span>.5-cdh5.7.0--<span class="number">1</span>, built on <span class="number">03</span>/<span class="number">23</span>/<span class="number">2016</span> <span class="number">18</span>:<span class="number">30</span> GMT</div><div class="line">Latency min/avg/max: <span class="number">0</span>/<span class="number">6</span>/<span class="number">190</span></div><div class="line">Received: <span class="number">16002</span></div><div class="line">Sent: <span class="number">19874</span></div><div class="line">Connections: <span class="number">1</span></div><div class="line">Outstanding: <span class="number">0</span></div><div class="line">Zxid: <span class="number">0x3b00004872</span></div><div class="line">Mode: leader</div><div class="line">Node count: <span class="number">334</span></div></pre></td></tr></table></figure></li></ol><p>可以看到Mode表示该节点的角色为leader。依次检查每一个节点,如果没有响应，或者出现多个leader，需要还原整个集群！</p><h3 id="步骤2：新增节点5"><a href="#步骤2：新增节点5" class="headerlink" title="步骤2：新增节点5"></a>步骤2：新增节点5</h3><ol><li>在<code>/data</code>目录创建mid文件，内容为5</li><li><p>配置zoo.cfg,内容如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div></pre></td></tr></table></figure></li><li><p>启动zookeeper：<code>{zookeeperDir}/bin/zkServer.sh start</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node2 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node3 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node4 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node5 <span class="number">2181</span></div><div class="line">...</div></pre></td></tr></table></figure></li></ol><h3 id="步骤3：新增节点6"><a href="#步骤3：新增节点6" class="headerlink" title="步骤3：新增节点6"></a>步骤3：新增节点6</h3><ol><li>在<code>/data</code>目录创建mid文件，内容为6</li><li><p>配置zoo.cfg,内容如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure></li><li><p>启动zookeeper：<code>{zookeeperDir}/bin/zkServer.sh start</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node2 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node3 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node4 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node5 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node6 <span class="number">2181</span></div><div class="line">...</div></pre></td></tr></table></figure></li></ol><h3 id="步骤4：更新节点4"><a href="#步骤4：更新节点4" class="headerlink" title="步骤4：更新节点4"></a>步骤4：更新节点4</h3><ol><li><p>修改节点4的配置如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure></li><li><p>重启节点4的zookeeper：<code>{zookeeperDir}/bin/zkServer.sh restart</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node2 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node3 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node4 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node5 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node6 <span class="number">2181</span></div><div class="line">...</div></pre></td></tr></table></figure></li></ol><h3 id="步骤5：更新节点5"><a href="#步骤5：更新节点5" class="headerlink" title="步骤5：更新节点5"></a>步骤5：更新节点5</h3><p>同步骤4</p><h3 id="步骤6：更新老集群节点1"><a href="#步骤6：更新老集群节点1" class="headerlink" title="步骤6：更新老集群节点1"></a>步骤6：更新老集群节点1</h3><ol><li><p>修改节点1的配置如下：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.1=node1:3181:4181</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure></li><li><p>重启节点4的zookeeper：<code>{zookeeperDir}/bin/zkServer.sh restart</code></p></li><li><p>检查所有节点是否提供服务，且集群中只有一个leader:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ echo srvr | nc node1 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node2 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node3 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node4 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node5 <span class="number">2181</span></div><div class="line">...</div><div class="line">$ echo srvr | nc node6 <span class="number">2181</span></div><div class="line">...</div></pre></td></tr></table></figure></li></ol><h3 id="步骤7：更新老集群节点3"><a href="#步骤7：更新老集群节点3" class="headerlink" title="步骤7：更新老集群节点3"></a>步骤7：更新老集群节点3</h3><p>同步骤6</p><h3 id="步骤8：更新老集群节点2"><a href="#步骤8：更新老集群节点2" class="headerlink" title="步骤8：更新老集群节点2"></a>步骤8：更新老集群节点2</h3><p><strong>最后更新leader节点：node2</strong>，同步骤6</p><p>ps:这时候如果没有读写zookeeper操作，集群的leader将变为节点6（因为节点6的myid最大）</p><h3 id="步骤9：将原有zookeeper的url指向新的节点"><a href="#步骤9：将原有zookeeper的url指向新的节点" class="headerlink" title="步骤9：将原有zookeeper的url指向新的节点"></a>步骤9：将原有zookeeper的url指向新的节点</h3><p>运维修改nginx配置，zookeeper url（例如pro1.zookeeper.so、pro2.zookeeper.so、pro3.zookeeper.so）指向node4，node5，node6</p><p>相关业务系统重启（避免cdh缓存）</p><h3 id="步骤10：老zookeeper集群下线"><a href="#步骤10：老zookeeper集群下线" class="headerlink" title="步骤10：老zookeeper集群下线"></a>步骤10：老zookeeper集群下线</h3><p><strong>这一步需要等待所有的业务系统都重启之后。</strong></p><p>这时候还是得一台一台关闭（下线），因为假如同时关闭node1和node2，那当重启node3的时候集群将不可用（没有超过集群半数的节点存活）</p><h4 id="步骤10-1：下线zookeeper老集群中的节点1"><a href="#步骤10-1：下线zookeeper老集群中的节点1" class="headerlink" title="步骤10.1：下线zookeeper老集群中的节点1"></a>步骤10.1：下线zookeeper老集群中的节点1</h4><p>关闭node1: <code>{zookeeperDir}/bin/zkServer.sh stop</code></p><p>依次修改node2，3，4，5，6的配置，并且重启，配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.2=node2:3181:4181</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure><p>重启后检查所有节点是否提供服务，且集群中只有一个leader。</p><p>ps:这时候如果没有读写zookeeper操作，leader将变成node5，因为node6节点重启的时候，集群重新选举，node5的myid最大</p><h4 id="步骤10-2：下线zookeeper老集群中的节点2"><a href="#步骤10-2：下线zookeeper老集群中的节点2" class="headerlink" title="步骤10.2：下线zookeeper老集群中的节点2"></a>步骤10.2：下线zookeeper老集群中的节点2</h4><p>关闭node2: <code>{zookeeperDir}/bin/zkServer.sh stop</code></p><p>依次修改node3，4，5，6的配置，并且重启，配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.3=node3:3181:4181</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure><p>重启后检查所有节点是否提供服务，且集群中只有一个leader。</p><p>ps:这时候如果没有读写zookeeper操作，leader将重新变成node6</p><h4 id="步骤10-3：下线zookeeper老集群中的节点3"><a href="#步骤10-3：下线zookeeper老集群中的节点3" class="headerlink" title="步骤10.3：下线zookeeper老集群中的节点3"></a>步骤10.3：下线zookeeper老集群中的节点3</h4><p>关闭node3: <code>{zookeeperDir}/bin/zkServer.sh stop</code></p><p>依次修改node4，5，6的配置，并且重启，配置如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 省略其他配置</div><div class="line">dataDir=/data</div><div class="line">server.4=node4:3181:4181</div><div class="line">server.5=node5:3181:4181</div><div class="line">server.6=node6:3181:4181</div></pre></td></tr></table></figure><p>重启后检查所有节点是否提供服务，且集群中只有一个leader。</p><p>ps:这时候如果没有读写zookeeper操作，node5将成为最终的leader</p><p>结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;由于一些历史原因，目前zookeeper集群（3个节点）和elasticsearch、hadoop部署在一起，导致几个组件相互影响，性能也逐渐下降。甚至出现某个组件异常（例如oom）导致了其他组件不可用。&lt;/p&gt;
&lt;p&gt;由于大量项目使用dubbo且依赖zookeeper作为注册中心，zookeeper的不稳定可能是致命的，所以计划先将zookeeper迁出到3台独立的节点，在此记录下迁移方案。&lt;/p&gt;
&lt;h2 id=&quot;zookeeper选举原理&quot;&gt;&lt;a href=&quot;#zookeeper选举原理&quot; class=&quot;headerlink&quot; title=&quot;zookeeper选举原理&quot;&gt;&lt;/a&gt;zookeeper选举原理&lt;/h2&gt;&lt;p&gt;在迁移前有必要了解zookeeper的选举原理，以便更科学的迁移。&lt;/p&gt;
&lt;h3 id=&quot;快速选举FastLeaderElection&quot;&gt;&lt;a href=&quot;#快速选举FastLeaderElection&quot; class=&quot;headerlink&quot; title=&quot;快速选举FastLeaderElection&quot;&gt;&lt;/a&gt;快速选举FastLeaderElection&lt;/h3&gt;&lt;p&gt;zookeeper默认使用快速选举，在此重点了解快速选举：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向集群中的其他zookeeper建立连接，&lt;strong&gt;并且只有myid比对方大的连接才会被接受（也就是每2台只会有1个连接，避免连接浪费）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每台zookeeper默认先投自己，然后向集群广播自己的选票&lt;/li&gt;
&lt;li&gt;收到对方的选票时，依次比较epoch（选举轮数）、zxid（事务id）、myid，较大者胜出，更新选票并广播&lt;/li&gt;
&lt;li&gt;如果收到的选票中有某个节点超过集群半数，则胜出当选为leader，其他节点为follower&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;zookeeper集群的数量应为奇数：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;因为根据paxos理论，只有集群中超过半数的节点还存活才能保证集群的一致性&lt;/strong&gt;。假如目前集群有5个节点，我们最多允许2个节点不可用，因为3&amp;gt;5\2。当集群扩容到6个节点的时候，我们仍然只能最多允许2个节点不可用，到3个节点不可用时，将不满足paxos理论，因为3&amp;gt;6\2不成立。也就是说当集群节点数n为偶数时，其可用性与n-1是一样的，那我们何必多浪费一台机器呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;由于zookeeper只允许mid大的节点连接到mid小的节点，我们启动zookeeper的顺序应该按照myid小的到myid大的，最后再启动leader节点！ &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="zookeeper" scheme="https://zacard.net/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>线上java项目OOM快速定位与解决方法</title>
    <link href="https://zacard.net/2017/08/21/howto-handle-java-oom/"/>
    <id>https://zacard.net/2017/08/21/howto-handle-java-oom/</id>
    <published>2017-08-21T10:33:22.000Z</published>
    <updated>2017-08-29T07:01:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近比较多的碰到OOM异常，总结下OOM的异常快速定位和解决的办法。</p><h2 id="OOM的常见原因"><a href="#OOM的常见原因" class="headerlink" title="OOM的常见原因"></a>OOM的常见原因</h2><ul><li>内存分配确实过小</li><li>频繁创建对象，没有及时释放</li><li>频繁申请系统资源，导致系统资源耗尽（例如：不断创建线程，不断发起网络连接）</li></ul><h2 id="定位与解决方法"><a href="#定位与解决方法" class="headerlink" title="定位与解决方法"></a>定位与解决方法</h2><p>需要先找到出问题的进程，使用top命令定位：</p><blockquote><p>top</p></blockquote><p>输入<code>top</code>命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。（可以先按c显示具体的command）</p><p>这里先按M根据内存排序查找异常的进程：<strong>这里假设出现异常的进程pid为2879</strong></p><a id="more"></a><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>定位问题前请先尝试输入jps命令，确定是否能够显示出现问题的pid（例如2879）.如果jps没有相应的显示，可能是你当前用户的权限不够，请使用启用相应进程的用户或者拥有更高权限的用户排查问题！不然以下的一些命令（例如jmap）将无法使用.</p><p>原理：java程序启动后，默认会在/tmp/hsperfdata_userName目录下以该进程的id为文件名新建文件，并在该文件中存储jvm运行的相关信息，其中的userName为当前的用户名，/tmp/hsperfdata_userName目录会存放该用户所有已经启动的java进程信息.而jps、jconsole等工具的数据来源就是这个文件（/tmp/hsperfdata_userName/pid)。所以当该文件不存在或是无法读取时就会出现jps无法查看该进程号，jconsole无法监控等问题</p><h3 id="判断是否是由于“内存分配确实过小”"><a href="#判断是否是由于“内存分配确实过小”" class="headerlink" title="判断是否是由于“内存分配确实过小”"></a>判断是否是由于“内存分配确实过小”</h3><p>输入以下命令：</p><blockquote><p>jmap -heap 2879</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@node182 ~]# jmap -heap 2879</div><div class="line">Attaching to process ID 2879, please wait...</div><div class="line">Debugger attached successfully.</div><div class="line">Server compiler detected.</div><div class="line">JVM version is 25.73-b02</div><div class="line"></div><div class="line">using thread-local object allocation.</div><div class="line">Parallel GC with 4 thread(s)</div><div class="line"></div><div class="line">Heap Configuration:</div><div class="line">   MinHeapFreeRatio         = 0</div><div class="line">   MaxHeapFreeRatio         = 100</div><div class="line">   MaxHeapSize              = 2040528896 (1946.0MB)</div><div class="line">   NewSize                  = 42467328 (40.5MB)</div><div class="line">   MaxNewSize               = 680001536 (648.5MB)</div><div class="line">   OldSize                  = 85458944 (81.5MB)</div><div class="line">   NewRatio                 = 2</div><div class="line">   SurvivorRatio            = 8</div><div class="line">   MetaspaceSize            = 21807104 (20.796875MB)</div><div class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</div><div class="line">   MaxMetaspaceSize         = 17592186044415 MB</div><div class="line">   G1HeapRegionSize         = 0 (0.0MB)</div><div class="line"></div><div class="line">Heap Usage:</div><div class="line">PS Young Generation</div><div class="line">Eden Space:</div><div class="line">   capacity = 28311552 (27.0MB)</div><div class="line">   used     = 21982144 (20.96380615234375MB)</div><div class="line">   free     = 6329408 (6.03619384765625MB)</div><div class="line">   77.64372649016204% used</div><div class="line">From Space:</div><div class="line">   capacity = 1048576 (1.0MB)</div><div class="line">   used     = 688128 (0.65625MB)</div><div class="line">   free     = 360448 (0.34375MB)</div><div class="line">   65.625% used</div><div class="line">To Space:</div><div class="line">   capacity = 1048576 (1.0MB)</div><div class="line">   used     = 0 (0.0MB)</div><div class="line">   free     = 1048576 (1.0MB)</div><div class="line">   0.0% used</div><div class="line">PS Old Generation</div><div class="line">   capacity = 100139008 (95.5MB)</div><div class="line">   used     = 90236608 (86.05633544921875MB)</div><div class="line">   free     = 9902400 (9.44366455078125MB)</div><div class="line">   90.11134602012434% used</div><div class="line"></div><div class="line">28237 interned Strings occupying 3386232 bytes.</div></pre></td></tr></table></figure><p>可以看到详细的堆内存使用情况，可以以此判断应用分配的内存是否确实过小。</p><h3 id="判断是否是由于“频繁创建对象，没有及时回收”"><a href="#判断是否是由于“频繁创建对象，没有及时回收”" class="headerlink" title="判断是否是由于“频繁创建对象，没有及时回收”"></a>判断是否是由于“频繁创建对象，没有及时回收”</h3><p>输入以下命令，找出最耗内存的对象：</p><blockquote><p>jmap -histo:live 2879 | more</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@node182 ~]# jmap -histo:live 2879 | more</div><div class="line"></div><div class="line"> num     #instances         #bytes  class name</div><div class="line">----------------------------------------------</div><div class="line">   1:         81515       11259264  [C</div><div class="line">   2:         80010        1920240  java.lang.String</div><div class="line">   3:         44265        1416480  java.util.concurrent.ConcurrentHashMap$Node</div><div class="line">   4:          4057        1369872  [B</div><div class="line">   5:         11200        1241976  java.lang.Class</div><div class="line">   6:          8977         789976  java.lang.reflect.Method</div><div class="line">   7:         18801         752040  java.util.LinkedHashMap$Entry</div><div class="line">   8:          5144         627336  [I</div><div class="line">   9:         11948         601184  [Ljava.lang.Object;</div><div class="line">  10:          8275         595352  [Ljava.util.HashMap$Node;</div><div class="line">  11:         18231         583392  java.lang.ref.WeakReference</div><div class="line">  12:          9847         551432  java.util.LinkedHashMap</div><div class="line">  13:           375         544288  [Ljava.util.concurrent.ConcurrentHashMap$Node;</div><div class="line">  14:         29118         465888  java.lang.Object</div><div class="line">  15:         13034         417088  java.util.HashMap$Node</div><div class="line">  16:          8850         354000  java.lang.ref.SoftReference</div><div class="line">  17:         10490         251760  java.beans.MethodRef</div><div class="line">  18:          3586         200816  java.beans.MethodDescriptor</div><div class="line">  19:          6450         195288  [Ljava.lang.String;</div></pre></td></tr></table></figure><p>输入命令后，会以表格的形式显示存活对象的信息，<strong>并按照所占内存大小排序</strong>。</p><ul><li>instances: 对象实例数量</li><li>bytes: 占用内存大小</li><li>class name: 类名</li></ul><p>可以看到目前最耗内存的对象也才占用内存11m，所以属于正常范畴</p><p>如果发现某个对象的占用大量内存（例如：1G以上），就需要review代码，审查下该对象是否没有及时回收</p><p>PS：其中输出的奇怪的class name请查看最后的附录。</p><h3 id="判断是否是由于“频繁申请系统资源”"><a href="#判断是否是由于“频繁申请系统资源”" class="headerlink" title="判断是否是由于“频繁申请系统资源”"></a>判断是否是由于“频繁申请系统资源”</h3><ul><li>查看进程的线程数量：</li></ul><blockquote><p>ll /proc/{PID}/task | wc -l</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@node182 ~]# ll /proc/2879/task | wc -l</div><div class="line">101</div></pre></td></tr></table></figure><p>可以看到，该进程使用了101个线程。</p><p>如果看到启用了大量线程，就需要审查代码涉及到线程池的使用部分，是否限定了最大线程数量。</p><ul><li>查询进程占用的句柄数量</li></ul><blockquote><p>ll /proc/{PID}/fd | wc -l</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@node182 ~]# ll /proc/2879/fd | wc -l</div><div class="line">38</div></pre></td></tr></table></figure><p>可以看到，该进程使用了38个文件句柄。</p><p>如果占用大量文件句柄，需要审查代码中涉及到文件操作和网络连接操作是否有及时关闭资源链接。</p><h2 id="jmap-附加说明"><a href="#jmap-附加说明" class="headerlink" title="jmap 附加说明"></a>jmap 附加说明</h2><p>jmap -heap输出的非自定义类名说明：</p><table><thead><tr><th style="text-align:left">BaseType Character</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td style="text-align:left">B</td><td>byte</td><td>signed byte</td></tr><tr><td style="text-align:left">C</td><td>char</td><td>Unicode character</td></tr><tr><td style="text-align:left">D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td style="text-align:left">F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td style="text-align:left">I</td><td>int</td><td>integer</td></tr><tr><td style="text-align:left">J</td><td>long</td><td>long integer</td></tr><tr><td style="text-align:left">L;</td><td>reference</td><td>an instance of class</td></tr><tr><td style="text-align:left">S</td><td>short</td><td>signed short</td></tr><tr><td style="text-align:left">Z</td><td>boolean</td><td>true or false</td></tr><tr><td style="text-align:left">[</td><td>reference</td><td>one array dimension</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近比较多的碰到OOM异常，总结下OOM的异常快速定位和解决的办法。&lt;/p&gt;
&lt;h2 id=&quot;OOM的常见原因&quot;&gt;&lt;a href=&quot;#OOM的常见原因&quot; class=&quot;headerlink&quot; title=&quot;OOM的常见原因&quot;&gt;&lt;/a&gt;OOM的常见原因&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内存分配确实过小&lt;/li&gt;
&lt;li&gt;频繁创建对象，没有及时释放&lt;/li&gt;
&lt;li&gt;频繁申请系统资源，导致系统资源耗尽（例如：不断创建线程，不断发起网络连接）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;定位与解决方法&quot;&gt;&lt;a href=&quot;#定位与解决方法&quot; class=&quot;headerlink&quot; title=&quot;定位与解决方法&quot;&gt;&lt;/a&gt;定位与解决方法&lt;/h2&gt;&lt;p&gt;需要先找到出问题的进程，使用top命令定位：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;top&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入&lt;code&gt;top&lt;/code&gt;命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。（可以先按c显示具体的command）&lt;/p&gt;
&lt;p&gt;这里先按M根据内存排序查找异常的进程：&lt;strong&gt;这里假设出现异常的进程pid为2879&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="oom" scheme="https://zacard.net/tags/oom/"/>
    
  </entry>
  
  <entry>
    <title>重构总结之升级log4j为logback</title>
    <link href="https://zacard.net/2017/07/24/restructure-summary-2/"/>
    <id>https://zacard.net/2017/07/24/restructure-summary-2/</id>
    <published>2017-07-24T12:42:39.000Z</published>
    <updated>2017-08-24T06:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着业务的复杂度上升，流量增大，各个系统的日志量也急剧上升。个别基础服务日志量达到了2G/天。使用的log4j(1)出现了大量丢日志的情况，且写日志的性能也出现下降。由于使用了slf4j作为日志门面，所以考虑换到业界使用更为广泛的logback。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前系统都以log4j作为日志实现，且有很多第三方包同样也依赖了log4j作为日志输出。如果要使用logback，总不能一个一个的去排除对log4j的依赖吧，不仅工作量大而且容易漏掉。</p><p>只能先看下slf4j选择具体日志实现的原理了。。。</p><a id="more"></a><h2 id="slf4j选择日志实现的原理"><a href="#slf4j选择日志实现的原理" class="headerlink" title="slf4j选择日志实现的原理"></a>slf4j选择日志实现的原理</h2><p>slf4j官网：<a href="https://www.slf4j.org/codes.html" target="_blank" rel="external">传送门</a></p><blockquote><p>SLF4J API is designed to bind with one and only one underlying logging framework at a time. If more than one binding is present on the class path, SLF4J will emit a warning, listing the location of those bindings.</p><p>When multiple bindings are available on the class path, select one and only one binding you wish to use, and remove the other bindings. For example, if you have both slf4j-simple-1.8.0-alpha2.jar and slf4j-nop-1.8.0-alpha2.jar on the class path and you wish to use the nop (no-operation) binding, then remove slf4j-simple-1.8.0-alpha2.jar from the class path.</p><p>The list of locations that SLF4J provides in this warning usually provides sufficient information to identify the dependency transitively pulling in an unwanted SLF4J binding into your project. In your project’s pom.xml file, exclude this SLF4J binding when declaring the unscrupulous dependency. For example, cassandra-all version 0.8.1 declares both log4j and slf4j-log4j12 as compile-time dependencies. Thus, when you include cassandra-all as a dependency in your project, the cassandra-all declaration will cause both slf4j-log4j12.jar and log4j.jar to be pulled in as dependencies. In case you do not wish to use log4j as the the SLF4J backend, you can instruct Maven to exclude these two artifacts as shown next:</p><p><dependencies><br>  <dependency><br>    <groupid> org.apache.cassandra</groupid><br>    <artifactid>cassandra-all</artifactid><br>    <version>0.8.1</version></dependency></dependencies></p></blockquote><pre><code>&lt;exclusions&gt;  &lt;exclusion&gt;     &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  &lt;/exclusion&gt;  &lt;exclusion&gt;     &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;  &lt;/exclusion&gt;&lt;/exclusions&gt; </code></pre><p>  <br></p><blockquote><p>Note The warning emitted by SLF4J is just that, a warning. Even when multiple bindings are present, SLF4J will pick one logging framework/implementation and bind with it. The way SLF4J picks a binding is determined by the JVM and for all practical purposes should be considered random. As of version 1.6.6, SLF4J will name the framework/implementation class it is actually bound to.</p><p>Embedded components such as libraries or frameworks should not declare a dependency on any SLF4J binding but only depend on slf4j-api. When a library declares a compile-time dependency on a SLF4J binding, it imposes that binding on the end-user, thus negating SLF4J’s purpose. When you come across an embedded component declaring a compile-time dependency on any SLF4J binding, please take the time to contact the authors of said component/library and kindly ask them to mend their ways.</p></blockquote><p><strong>意思就是说如果有多个日志组件并存的时候，slf4j的选择方式是随机的…</strong></p><h2 id="黑魔法方式"><a href="#黑魔法方式" class="headerlink" title="黑魔法方式"></a>黑魔法方式</h2><p>最终google发现一种巧妙的方式。请看以下maven pom.xml配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 强制去除log4j的依赖,全部 delegate 到 log4j-over-slf4j 上--&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;99.0-does-not-exist&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;99.0-does-not-exist&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;apache-log4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;99.0-not-exist&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;!-- 明确指定只用logback --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.7.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.11&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.1.4&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>原理就是maven对于冲突包的选择方式是<strong>就近原则</strong>，当项目主动定义了一个并不存在的log4j版本(当然你得打个空jar到你的maven私服或者本地)，maven优先会选择这个不存在的版本，从而使log4j的依赖全部被排除。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;随着业务的复杂度上升，流量增大，各个系统的日志量也急剧上升。个别基础服务日志量达到了2G/天。使用的log4j(1)出现了大量丢日志的情况，且写日志的性能也出现下降。由于使用了slf4j作为日志门面，所以考虑换到业界使用更为广泛的logback。&lt;/p&gt;
&lt;h2 id=&quot;现状&quot;&gt;&lt;a href=&quot;#现状&quot; class=&quot;headerlink&quot; title=&quot;现状&quot;&gt;&lt;/a&gt;现状&lt;/h2&gt;&lt;p&gt;目前系统都以log4j作为日志实现，且有很多第三方包同样也依赖了log4j作为日志输出。如果要使用logback，总不能一个一个的去排除对log4j的依赖吧，不仅工作量大而且容易漏掉。&lt;/p&gt;
&lt;p&gt;只能先看下slf4j选择具体日志实现的原理了。。。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="日志" scheme="https://zacard.net/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="重构" scheme="https://zacard.net/tags/%E9%87%8D%E6%9E%84/"/>
    
      <category term="log4j" scheme="https://zacard.net/tags/log4j/"/>
    
      <category term="logback" scheme="https://zacard.net/tags/logback/"/>
    
  </entry>
  
  <entry>
    <title>业务重构总结之分解关联查询</title>
    <link href="https://zacard.net/2017/06/20/restructure-summary-1/"/>
    <id>https://zacard.net/2017/06/20/restructure-summary-1/</id>
    <published>2017-06-20T12:42:39.000Z</published>
    <updated>2017-06-21T06:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>经历了一段漫长痛苦的重构期，整体的业务重构基本完成。这里总结下重构中遇到的一些问题和经验。这里主要讲下<strong>分解关联查询</strong>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>例如一个查询标签为‘mysql’的所有文章的关联查询sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag</div><div class="line"><span class="keyword">join</span> tag_post <span class="keyword">on</span> tag_post.tag_id = tag.id</div><div class="line"><span class="keyword">join</span> post <span class="keyword">on</span> tag_post.post_id = post.id</div><div class="line"><span class="keyword">where</span> tag.tag = <span class="string">'mysql'</span>;</div></pre></td></tr></table></figure><p>分解成以下多个sql，在应用层做关联：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tag <span class="keyword">where</span> tag = <span class="string">'mysql'</span>;</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag_post <span class="keyword">where</span> tag_id=<span class="number">1234</span>;</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> post <span class="keyword">where</span> post.id <span class="keyword">in</span> (<span class="number">123</span>,<span class="number">456</span>,...);</div></pre></td></tr></table></figure><h2 id="分解关联查询的优点"><a href="#分解关联查询的优点" class="headerlink" title="分解关联查询的优点"></a>分解关联查询的优点</h2><h3 id="缓存的效率更高"><a href="#缓存的效率更高" class="headerlink" title="缓存的效率更高"></a>缓存的效率更高</h3><p>应用程序可以很方便的缓存单表查询的结果。例如例子中分解后的第1个查询，如果已经在缓存中，这可以跳过第1个查询。</p><p>另外对于mysql的query cacha（查询缓存）来说，如果关联查询中的任意表发生了变化，就无法使用缓存，而拆分后，如果其中一个表很少改变，那么该表的缓存命中将很高。</p><h3 id="减少数据库锁竞争"><a href="#减少数据库锁竞争" class="headerlink" title="减少数据库锁竞争"></a>减少数据库锁竞争</h3><p>查询分解后，执行单个查询可以减少锁的竞争，而关联查询将可能锁多个表。</p><h3 id="微服务化友好"><a href="#微服务化友好" class="headerlink" title="微服务化友好"></a>微服务化友好</h3><p>应用层做关联，可以更容易的做数据库拆分，更容易做到高性能和可扩展。对于原本的单体应用做微服务化拆分与改造将非常便捷。</p><h3 id="查询效率提升"><a href="#查询效率提升" class="headerlink" title="查询效率提升"></a>查询效率提升</h3><p>例如例子中的第3个查询，使用了in()代替了关联查询，可以让mysql按照id顺序进行查询，这比随机的关联要更高效。</p><h3 id="减少冗余记录的查询"><a href="#减少冗余记录的查询" class="headerlink" title="减少冗余记录的查询"></a>减少冗余记录的查询</h3><p>在应用层做关联，意味着对某条记录只需查询一次，而在数据库关联查询，则可能需要重复地访问一部分数据。从这点看，这样还能减少网络和内测消耗。</p><h3 id="关联更高效"><a href="#关联更高效" class="headerlink" title="关联更高效"></a>关联更高效</h3><p>在应用层关联，往往比mysql中的嵌套循环关联更高效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;经历了一段漫长痛苦的重构期，整体的业务重构基本完成。这里总结下重构中遇到的一些问题和经验。这里主要讲下&lt;strong&gt;分解关联查询&lt;/str
      
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="重构" scheme="https://zacard.net/tags/%E9%87%8D%E6%9E%84/"/>
    
      <category term="关联查询" scheme="https://zacard.net/tags/%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/"/>
    
      <category term="mysql" scheme="https://zacard.net/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记</title>
    <link href="https://zacard.net/2017/01/03/rocketmq-read-note/"/>
    <id>https://zacard.net/2017/01/03/rocketmq-read-note/</id>
    <published>2017-01-03T06:59:50.000Z</published>
    <updated>2018-01-12T13:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为何选择rocketmq"><a href="#为何选择rocketmq" class="headerlink" title="为何选择rocketmq"></a>为何选择rocketmq</h2><p>选型时主要对比了kafka和rocketmq。两者还是存在较大差异的，kafka一开始的定位就是日志收集，对于订单、交易等可靠传输场景不能很好满足（消息丢失、消息重复消费等方面）。并且rocketmq是使用java编写的，相对于scala编写的kafka，我们有更大的定制与扩展的空间。</p><h3 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h3><ul><li>rocketmq支持异步/同步刷盘,异步/同步复制</li><li>kafka异步刷盘，异步/同步复制</li></ul><p>刷盘效率上应该是rocketmq更高。因为rocketmq的消息都写到一个文件中，而kafka的每个分区对应一个文件，rocketmq可以充分利用IO组commit机制批量传输数据。</p><a id="more"></a><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><ul><li>kafka单机协议TPS约在100w/s，消息大小为10字节</li><li>rocketmq单机写入TPS单实例约为7W/s,单机3个broker，可以跑到12w/s,消息大小为10字节</li></ul><p>之所以kafka有如此高的TPS,是由于producer端会将多个小消息合并，批量发送至broker。rocketmq没有这做的原因：</p><ol><li>由于使用java语言，如果producer端缓存过多消息，GC是个严重问题</li><li>producer端调用发送消息接口，消息为发送到broker就返回，此时producer宕机会导致消息丢失</li><li>producer通常为分布式部署，且每台机器都是多线程发送，单个producer产生的消息有限</li></ol><h3 id="单机支持的队列-分区数量"><a href="#单机支持的队列-分区数量" class="headerlink" title="单机支持的队列/分区数量"></a>单机支持的队列/分区数量</h3><ul><li>Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长。<a href="https://www.confluent.io/blog/how-to-choose-the-number-of-topicspartitions-in-a-kafka-cluster/" target="_blank" rel="external">Kafka分区数无法过多的问题</a></li><li>rocketmq支持单机最高5w个队列，负载不会发送明显变化</li></ul><p>队列/分区多的好处：</p><ol><li>单机可以创建更多Topic，因为没有Topic都是有一批队列组成</li><li>消费者的集群规模和队列数成正比</li></ol><h3 id="消息投递实时性"><a href="#消息投递实时性" class="headerlink" title="消息投递实时性"></a>消息投递实时性</h3><ul><li>kafka使用短轮询方式，实时性取决于轮询间隔时间，0.8以后支持长轮询</li><li>rockmq使用长轮询，同push方式实时性基本一致</li></ul><h3 id="消费失败重试"><a href="#消费失败重试" class="headerlink" title="消费失败重试"></a>消费失败重试</h3><ul><li>kafka不支持重试</li><li>rocketmq消费失败支持定时重试，每次重试间隔时间顺延</li></ul><p>重试的场景比较适合依赖第三方的consumer，比较充值，consumer需要调用第三方运营商网关，充值失败可能是对方当前压力过大，稍后调用可能就会成功。</p><h3 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h3><ul><li>kafka支持消息顺序，但是在一台broker宕机后，就会产生消息乱序</li><li>rocketmq支持严格的消息顺序，当一台broker宕机后，发送消息会失败，但不会乱序</li></ul><h3 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h3><ul><li>kafka目前不支持定时消息</li><li>rocketmq支持定时消息</li></ul><p>目前业务场景暂时用不到。</p><h3 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h3><ul><li>kafka目前不支持</li><li>rocketmq暂时没有开源事务消息</li></ul><h3 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h3><ul><li>kafka不支持消息查询</li><li>rocketmq支持根据消息表示查询，也可根据消息内容查询（发送消息时指定一个消息密钥，任意字符串，例如指定为订单编号）</li></ul><p>这个对于消息定位非常有帮助。</p><h3 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h3><ul><li>kafka不支持</li><li>rocketmq可以按照时间回溯消息，精度毫秒</li></ul><p>这个对于对账等功能比较有用</p><h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><ul><li>kafka不支持broker端过滤</li><li>rocketmq支持根据tag（相当于子主题）过滤</li></ul><h3 id="开发语言友好"><a href="#开发语言友好" class="headerlink" title="开发语言友好"></a>开发语言友好</h3><p>rocketmq使用java，更友好。</p><h3 id="开源社区活跃度"><a href="#开源社区活跃度" class="headerlink" title="开源社区活跃度"></a>开源社区活跃度</h3><p>都比较活跃。</p><h2 id="rocketmq消息存储"><a href="#rocketmq消息存储" class="headerlink" title="rocketmq消息存储"></a>rocketmq消息存储</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为何选择rocketmq&quot;&gt;&lt;a href=&quot;#为何选择rocketmq&quot; class=&quot;headerlink&quot; title=&quot;为何选择rocketmq&quot;&gt;&lt;/a&gt;为何选择rocketmq&lt;/h2&gt;&lt;p&gt;选型时主要对比了kafka和rocketmq。两者还是存在较大差异的，kafka一开始的定位就是日志收集，对于订单、交易等可靠传输场景不能很好满足（消息丢失、消息重复消费等方面）。并且rocketmq是使用java编写的，相对于scala编写的kafka，我们有更大的定制与扩展的空间。&lt;/p&gt;
&lt;h3 id=&quot;数据可靠性&quot;&gt;&lt;a href=&quot;#数据可靠性&quot; class=&quot;headerlink&quot; title=&quot;数据可靠性&quot;&gt;&lt;/a&gt;数据可靠性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;rocketmq支持异步/同步刷盘,异步/同步复制&lt;/li&gt;
&lt;li&gt;kafka异步刷盘，异步/同步复制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;刷盘效率上应该是rocketmq更高。因为rocketmq的消息都写到一个文件中，而kafka的每个分区对应一个文件，rocketmq可以充分利用IO组commit机制批量传输数据。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="rocketmq" scheme="https://zacard.net/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>dubbo遇到的坑</title>
    <link href="https://zacard.net/2016/12/12/dubbo-parameter-validate/"/>
    <id>https://zacard.net/2016/12/12/dubbo-parameter-validate/</id>
    <published>2016-12-12T12:42:39.000Z</published>
    <updated>2017-06-21T05:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前项目使用dubbo做服务化，同时开启dubbo的consumer端的参数校验。</p><h2 id="遇到的坑一"><a href="#遇到的坑一" class="headerlink" title="遇到的坑一"></a>遇到的坑一</h2><p>第一个遇到的就是参数分组校验的bug了，这个其实网上很多人提过。</p><p>具体原因就是内部类使用<code>_</code>连接符代替实际应该使用的<code>$</code>。具体看如下代码(<a href="https://github.com/alibaba/dubbo/blob/master/dubbo-filter/dubbo-filter-validation/src/main/java/com/alibaba/dubbo/validation/support/jvalidation/JValidator.java" target="_blank" rel="external">传送门</a>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">           String methodClassName = clazz.getName() + <span class="string">"_"</span> + toUpperMethoName(methodName);</div><div class="line">           Class&lt;?&gt; methodClass = <span class="keyword">null</span>;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               methodClass = Class.forName(methodClassName, <span class="keyword">false</span>, Thread.currentThread().getContextClassLoader());</div><div class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 以下代码略</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>这段代码的作用就是加载dubbo service中的分组校验group的内部类，再根据具体的group进行参数校验。但是内部类的连接符却用了<code>_</code>连接。按理说这个问题应该很容易被发现且很容易被测试出来，不应该出现在<code>dubbo</code>身上。</p><a id="more"></a><p>于是抱着怀疑的的心态查看该类的提交记录。果然，作者是故意这么改的(<a href="https://github.com/alibaba/dubbo/commit/e4dea029546efe9e7a6184ad528560e62303ce02" target="_blank" rel="external">传送门</a>)：</p><blockquote><p>JValidator在类名生成的类名有$，有frozen class异常</p></blockquote><p>个人不是很理解这句话。。。且这么改留下了一个明显的bug。可能由于当时dubbo已经不再维护，作者也没有对此修改有进一步的说明。只好将此处的修改还原为使用<code>$</code>连接。实际测试与使用都没有出现异常，就此作罢。</p><h2 id="遇到的坑二"><a href="#遇到的坑二" class="headerlink" title="遇到的坑二"></a>遇到的坑二</h2><p>随着系统的愈加复杂，出现了dubbo调用dubbo的情况。当前端web系统的controller调用dubboService1的时候，会在controller端进行参数校验，这个时候如果校验失败，能正常抛出错误，因为根本都还没有发起RPC调用。但是当dubboService1调用dubboService2的时候，也会在dubboService1端进行参数校验，这个时候如果校验失败，会抛出异常，dubboService1会试图将此异常序列化并传回controller端。如果此异常中包含不可系列化的属性，将会抛出<strong>无法序列化异常</strong>。这个就是dubbo默认的参数校验会存在的问题。例如以下错误:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java.lang.RuntimeException: Serialized class com.example.dubboService2_method1 must implement java.io.Serializable</div><div class="line">Java field: private final java.lang.Object org.hibernate.validator.internal.engine.ConstraintViolationImpl.rootBean</div></pre></td></tr></table></figure><p><strong>解决办法：</strong>dubbo提供了自定义参数校验的扩展点，并且我们只要自定义一个可正常序列化的异常即可。例如以下代码：</p><p>DubboValidation.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboValidation</span> <span class="keyword">extends</span> <span class="title">JValidation</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DubboValidation</span><span class="params">()</span> </span>&#123;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">protected</span> Validator <span class="title">createValidator</span><span class="params">(URL url)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> DubboValidator(url);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>DubboValidator.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboValidator</span> <span class="keyword">extends</span> <span class="title">JValidator</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DubboValidator</span><span class="params">(URL url)</span> </span>&#123;</div><div class="line">           <span class="keyword">super</span>(url);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">           <span class="keyword">try</span>&#123;</div><div class="line">               <span class="keyword">super</span>.validate(methodName, parameterTypes, arguments);</div><div class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> MyBusinessException(<span class="string">"DUBBO参数校验失败"</span>, e.getMessage());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>MyBUsinessException.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBusinessException</span> <span class="keyword">extends</span> <span class="title">RpcException</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_FAULT_CODE = <span class="string">"X0001"</span>;</div><div class="line"></div><div class="line">       <span class="keyword">private</span> String xCode;</div><div class="line">       <span class="keyword">private</span> String message;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyBusinessException</span><span class="params">(String message)</span></span>&#123;</div><div class="line">           <span class="keyword">this</span>(DEFAULT_FAULT_CODE, message);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyBusinessException</span><span class="params">(String xCode, String message)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>(xCode, message, <span class="keyword">new</span> Throwable());</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyBusinessException</span><span class="params">(String xCode, String message, String internalMessage)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>(xCode, message, internalMessage, <span class="keyword">null</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyBusinessException</span><span class="params">(String code, String message, Throwable throwable)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>(code, message, throwable.getMessage(), throwable);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyBusinessException</span><span class="params">(String xCode, String message, String internalMessage, Throwable throwable)</span> </span>&#123;</div><div class="line">           <span class="keyword">super</span>(RpcException.BIZ_EXCEPTION, <span class="string">"["</span> + xCode + <span class="string">"] - "</span> + message + internalMessage, throwable);</div><div class="line">           <span class="keyword">this</span>.message = message;</div><div class="line">           <span class="keyword">this</span>.xCode = xCode;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getXCode</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> xCode;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXCode</span><span class="params">(String xCode)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.xCode = xCode;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getMessageWithoutCode</span><span class="params">()</span></span>&#123;</div><div class="line">           <span class="keyword">return</span> message;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="string">"["</span> + xCode + <span class="string">"]"</span> + <span class="string">" - "</span> + message;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.message = message;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>同时需要在<code>classpath:META-INF/</code>下新建如下目录：<code>dubbo/</code>,并且新建一个文件<code>com.alibaba.dubbo.validation.Validation</code>,然后写入以下内容：</p><blockquote><p>dubboValidation=com.xkeshi.webkits.dubbovalidation.DubboValidation</p></blockquote><p>其实以上就是<code>java spi</code>的类加载方式。</p><h2 id="遇到的坑三"><a href="#遇到的坑三" class="headerlink" title="遇到的坑三"></a>遇到的坑三</h2><p>dubbo provider服务提供者不要有方法重载！不然默认的dubbo协议说使用的Hessian序列化方式将有可能无法正确找到重载的方法！（客户端开启参数校验的时候）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;目前项目使用dubbo做服务化，同时开启dubbo的consumer端的参数校验。&lt;/p&gt;
&lt;h2 id=&quot;遇到的坑一&quot;&gt;&lt;a href=&quot;#遇到的坑一&quot; class=&quot;headerlink&quot; title=&quot;遇到的坑一&quot;&gt;&lt;/a&gt;遇到的坑一&lt;/h2&gt;&lt;p&gt;第一个遇到的就是参数分组校验的bug了，这个其实网上很多人提过。&lt;/p&gt;
&lt;p&gt;具体原因就是内部类使用&lt;code&gt;_&lt;/code&gt;连接符代替实际应该使用的&lt;code&gt;$&lt;/code&gt;。具体看如下代码(&lt;a href=&quot;https://github.com/alibaba/dubbo/blob/master/dubbo-filter/dubbo-filter-validation/src/main/java/com/alibaba/dubbo/validation/support/jvalidation/JValidator.java&quot;&gt;传送门&lt;/a&gt;)：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;validate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String methodName, Class&amp;lt;?&amp;gt;[] parameterTypes, Object[] arguments)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           String methodClassName = clazz.getName() + &lt;span class=&quot;string&quot;&gt;&quot;_&quot;&lt;/span&gt; + toUpperMethoName(methodName);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           Class&amp;lt;?&amp;gt; methodClass = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;               methodClass = Class.forName(methodClassName, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, Thread.currentThread().getContextClassLoader());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;comment&quot;&gt;// 以下代码略&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码的作用就是加载dubbo service中的分组校验group的内部类，再根据具体的group进行参数校验。但是内部类的连接符却用了&lt;code&gt;_&lt;/code&gt;连接。按理说这个问题应该很容易被发现且很容易被测试出来，不应该出现在&lt;code&gt;dubbo&lt;/code&gt;身上。&lt;/p&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="dubbo" scheme="https://zacard.net/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>线上java项目cpu100%排查步骤</title>
    <link href="https://zacard.net/2016/12/09/howto-handle-java-cpu100/"/>
    <id>https://zacard.net/2016/12/09/howto-handle-java-cpu100/</id>
    <published>2016-12-09T05:33:22.000Z</published>
    <updated>2016-12-09T05:41:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-利用top命令查找异常进程"><a href="#1-利用top命令查找异常进程" class="headerlink" title="1.利用top命令查找异常进程"></a>1.利用top命令查找异常进程</h2><blockquote><p>top</p></blockquote><p>输入<code>top</code>命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。</p><p>这里先按P根据cpu排序查找异常的线程：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/java-cup100-1.png" alt=""></p><p>可以看到，有个pid为19132的线程占用cpu400%(这里是因为4核，每个cpu都100%，加起来就是400%)</p><h2 id="2-根据记录的pid查找其线程占用情况"><a href="#2-根据记录的pid查找其线程占用情况" class="headerlink" title="2.根据记录的pid查找其线程占用情况"></a>2.根据记录的pid查找其线程占用情况</h2><blockquote><p>top -Hc -p 19132</p></blockquote><p>说明：这里-Hc是指按照cpu占用降序</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/java-cpu100-2.png" alt=""></p><p>这里可以看到这个pid为31395的线程cpu占用非常高，且运行时间也非常长，肯定是有问题的。</p><h2 id="3-打印出异常进程信息"><a href="#3-打印出异常进程信息" class="headerlink" title="3.打印出异常进程信息"></a>3.打印出异常进程信息</h2><p>先根据第1步查出的pid，打印出线程堆栈信息到文件：</p><blockquote><p>jstack 19321 &gt; stack-19321.log</p></blockquote><p>根据第二步查出的pid，打印出其16进制：</p><blockquote><p>printf %x 31395</p><p>7aa3</p></blockquote><p>然后去stack-19321.log文件里查找7aa3:</p><blockquote><p>vim stack-19321.log</p><p>/7aa3</p></blockquote><p>即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-利用top命令查找异常进程&quot;&gt;&lt;a href=&quot;#1-利用top命令查找异常进程&quot; class=&quot;headerlink&quot; title=&quot;1.利用top命令查找异常进程&quot;&gt;&lt;/a&gt;1.利用top命令查找异常进程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;top&lt;/
      
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://zacard.net/tags/java/"/>
    
      <category term="cpu100%" scheme="https://zacard.net/tags/cpu100/"/>
    
  </entry>
  
  <entry>
    <title>netty源码解读之时间轮算法实现-HashedWheelTimer</title>
    <link href="https://zacard.net/2016/12/02/netty-hashedwheeltimer/"/>
    <id>https://zacard.net/2016/12/02/netty-hashedwheeltimer/</id>
    <published>2016-12-02T01:51:38.000Z</published>
    <updated>2016-12-06T09:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>由于netty动辄管理100w+的连接，每一个连接都会有很多超时任务。比如发送超时、心跳检测间隔等，如果每一个定时任务都启动一个<code>Timer</code>,不仅低效，而且会消耗大量的资源。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>根据George Varghese 和 Tony Lauck 1996 年的论文：<a href="http://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z" target="_blank" rel="external">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a>。提出了一种定时轮的方式来管理和维护大量的<code>Timer</code>调度.</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>时间轮其实就是一种环形的数据结构，可以想象成时钟，分成很多格子，一个格子代码一段时间（这个时间越短，<code>Timer</code>的精度越高）。并用一个链表报错在该格子上的到期任务，同时一个指针随着时间一格一格转动，并执行相应格子中的到期任务。任务通过<code>取摸</code>决定放入那个格子。如下图所示：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/netty-hasedwheeltimer1.png" alt=""></p><p>以上图为例，假设一个格子是1秒，则整个wheel能表示的时间段为8s，假如当前指针指向2，此时需要调度一个3s后执行的任务，显然应该加入到(2+3=5)的方格中，指针再走3次就可以执行了；如果任务要在10s后执行，应该等指针走完一个round零2格再执行，因此应放入4，同时将round（1）保存到任务中。检查到期任务时应当只执行round为0的，格子上其他任务的round应减1。</p><p>是不是很像java中的<code>Hashmap</code>。其实就是<code>HashMap</code>的哈希拉链算法，只不过多了指针转动与一些定时处理的逻辑。所以其相关的操作和<code>HashMap</code>也一致：</p><ul><li>添加任务：O(1)</li><li>删除/取消任务：O(1)</li><li>过期/执行任务：最差情况为O(n)-&gt;也就是当<code>HashMap</code>里面的元素全部hash冲突，退化为一条链表的情况。平均O(1)-&gt;显然，格子越多，每个格子上的链表就越短，这里需要权衡时间与空间。</li></ul><a id="more"></a><h3 id="多层时间轮"><a href="#多层时间轮" class="headerlink" title="多层时间轮"></a>多层时间轮</h3><p>如果任务的时间跨度很大，数量很大，单层的时间轮会造成任务的<code>round</code>很大，单个格子的链表很长。这时候可以将时间轮分层，类似于时钟的时分秒3层。如下图所示：</p><p><img src="http://7xlnw9.com1.z0.glb.clouddn.com/netty-hashedwheeltimer2.png" alt=""></p><p>但是个人认为，多层的时间轮造成的算法复杂度的进一步提升。单层时间轮只需增加每一轮的格子就能解决链表过长的问题。因此，更倾向使用单层的时间轮，netty4中时间轮的实现也是单层的。</p><h2 id="netty时间轮的实现-HashedWheelTimer"><a href="#netty时间轮的实现-HashedWheelTimer" class="headerlink" title="netty时间轮的实现-HashedWheelTimer"></a>netty时间轮的实现-HashedWheelTimer</h2><h3 id="简单使用示例"><a href="#简单使用示例" class="headerlink" title="简单使用示例"></a>简单使用示例</h3><p>1.引入netty依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;/groupId&gt;    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;    &lt;version&gt;4.1.4.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2.示例代码</p><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">    HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">100</span>, TimeUnit.MILLISECONDS);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"start:"</span> + LocalDateTime.now().format(formatter));</div><div class="line"></div><div class="line">    hashedWheelTimer.newTimeout(timeout -&gt; &#123;</div><div class="line">        System.out.println(<span class="string">"task :"</span> + LocalDateTime.now().format(formatter));</div><div class="line">    &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line">    Thread.sleep(<span class="number">5000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出为：</p><blockquote><p>start:2016-11-30 05:56:35</p><p>task :2016-11-30 05:56:38</p></blockquote><p>示例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">    HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">100</span>, TimeUnit.MILLISECONDS);</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"start:"</span> + LocalDateTime.now().format(formatter));</div><div class="line"></div><div class="line">    hashedWheelTimer.newTimeout(timeout -&gt; &#123;</div><div class="line">        Thread.sleep(<span class="number">3000</span>);</div><div class="line">        System.out.println(<span class="string">"task1:"</span> + LocalDateTime.now().format(formatter));</div><div class="line">    &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">    hashedWheelTimer.newTimeout(timeout -&gt; System.out.println(<span class="string">"task2:"</span> + LocalDateTime.now().format(</div><div class="line">            formatter)), <span class="number">4</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">    Thread.sleep(<span class="number">10000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：</p><blockquote><p>start:2016-12-01 08:32:37</p><p>task1:2016-12-01 08:32:43</p><p>task2:2016-12-01 08:32:43</p></blockquote><p>可以看到，当前一个任务执行时间过长的时候，会影响后续任务的到期执行时间的。也就是说其中的任务是串行执行的。所以，要求里面的任务都要短平快。</p><h3 id="HashedWheelTimer源码之构造函数"><a href="#HashedWheelTimer源码之构造函数" class="headerlink" title="HashedWheelTimer源码之构造函数"></a>HashedWheelTimer源码之构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></div><div class="line">          ThreadFactory threadFactory, // 用来创建worker线程</div><div class="line">          <span class="keyword">long</span> tickDuration, // tick的时长，也就是指针多久转一格</div><div class="line">          TimeUnit unit, // tickDuration的时间单位</div><div class="line">          <span class="keyword">int</span> ticksPerWheel, // 一圈有几格</div><div class="line">          <span class="keyword">boolean</span> leakDetection // 是否开启内存泄露检测</div><div class="line">          ) &#123;</div><div class="line"></div><div class="line">      <span class="comment">// 一些参数校验</span></div><div class="line">      <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (tickDuration &lt;= <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"tickDuration must be greater than 0: "</span> + tickDuration);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 创建时间轮基本的数据结构，一个数组。长度为不小于ticksPerWheel的最小2的n次方</span></div><div class="line">      wheel = createWheel(ticksPerWheel);</div><div class="line">      <span class="comment">// 这是一个标示符，用来快速计算任务应该呆的格子。</span></div><div class="line">      <span class="comment">// 我们知道，给定一个deadline的定时任务，其应该呆的格子=deadline%wheel.length.但是%操作是个相对耗时的操作，所以使用一种变通的位运算代替：</span></div><div class="line">      <span class="comment">// 因为一圈的长度为2的n次方，mask = 2^n-1后低位将全部是1，然后deadline&amp;mast == deadline%wheel.length</span></div><div class="line">      <span class="comment">// java中的HashMap也是使用这种处理方法</span></div><div class="line">      mask = wheel.length - <span class="number">1</span>;</div><div class="line"></div><div class="line">      <span class="comment">// 转换成纳秒处理</span></div><div class="line">      <span class="keyword">this</span>.tickDuration = unit.toNanos(tickDuration);</div><div class="line"></div><div class="line">      <span class="comment">// 校验是否存在溢出。即指针转动的时间间隔不能太长而导致tickDuration*wheel.length&gt;Long.MAX_VALUE</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.tickDuration &gt;= Long.MAX_VALUE / wheel.length) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</div><div class="line">                  <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</div><div class="line">                  tickDuration, Long.MAX_VALUE / wheel.length));</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 创建worker线程</span></div><div class="line">      workerThread = threadFactory.newThread(worker);</div><div class="line"></div><div class="line"><span class="comment">// 这里默认是启动内存泄露检测：当HashedWheelTimer实例超过当前cpu可用核数*4的时候，将发出警告</span></div><div class="line">      leak = leakDetection || !workerThread.isDaemon() ? leakDetector.open(<span class="keyword">this</span>) : <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>再来看下<code>createWheel</code>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</div><div class="line">      <span class="comment">// 一些参数校验</span></div><div class="line"><span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                  <span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                  <span class="string">"ticksPerWheel may not be greater than 2^30: "</span> + ticksPerWheel);</div><div class="line">      &#125;</div><div class="line"></div><div class="line"><span class="comment">// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方</span></div><div class="line">      ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</div><div class="line"><span class="comment">// 初始化wheel数组</span></div><div class="line">      HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i ++) &#123;</div><div class="line">          wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> wheel;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p><code>normalizeTicksPerWheel()</code>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化ticksPerWheel的值为不小于ticksPerWheel的最小2的n次方</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</div><div class="line">           normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> normalizedTicksPerWheel;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>这里其实不建议使用这种方式，因为当ticksPerWheel的值很大的时候，这个方法会循环很多次，方法执行时间不稳定，效率也不够。推荐使用java8 HashMap的做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 这里参考java8 hashmap的算法，使推算的过程固定</span></div><div class="line">    <span class="keyword">int</span> n = ticksPerWheel - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="comment">// 这里1073741824 = 2^30,防止溢出</span></div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= <span class="number">1073741824</span>) ? <span class="number">1073741824</span> : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="HashedWheelTimer源码之启动、停止与添加任务"><a href="#HashedWheelTimer源码之启动、停止与添加任务" class="headerlink" title="HashedWheelTimer源码之启动、停止与添加任务"></a>HashedWheelTimer源码之启动、停止与添加任务</h3><p><code>start()</code>启动时间轮的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 启动时间轮。这个方法其实不需要显示的主动调用，因为在添加定时任务（newTimeout()方法）的时候会自动调用此方法。</span></div><div class="line"><span class="comment">// 这个是合理的设计，因为如果时间轮里根本没有定时任务，启动时间轮也是空耗资源</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 判断当前时间轮的状态，如果是初始化，则启动worker线程，启动整个时间轮；如果已经启动则略过；如果是已经停止，则报错</span></div><div class="line">    <span class="comment">// 这里是一个Lock Free的设计。因为可能有多个线程调用启动方法，这里使用AtomicIntegerFieldUpdater原子的更新时间轮的状态</span></div><div class="line">    <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</div><div class="line">        <span class="keyword">case</span> WORKER_STATE_INIT:</div><div class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</div><div class="line">                workerThread.start();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> WORKER_STATE_STARTED:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 等待worker线程初始化时间轮的启动时间</span></div><div class="line">    <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            startTimeInitialized.await();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</div><div class="line">            <span class="comment">// Ignore - it will be ready very soon.</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>AtomicIntegerFieldUpdater是JUC里面的类，原理是利用反射进行原子操作。有比AtomicInteger更好的性能和更低得内存占用。跟踪这个类的github 提交记录，可以看到更详细的<a href="https://github.com/netty/netty/commit/1f68479e3cd94deb3172edd3c01aa74f35032b9b" target="_blank" rel="external">原因</a></p><p><code>stop()</code>停止时间轮的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// worker线程不能停止时间轮，也就是加入的定时任务，不能调用这个方法。</span></div><div class="line">    <span class="comment">// 不然会有恶意的定时任务调用这个方法而造成大量定时任务失效</span></div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                HashedWheelTimer.class.getSimpleName() +</div><div class="line">                        <span class="string">".stop() cannot be called from "</span> +</div><div class="line">                        TimerTask.class.getSimpleName());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 尝试CAS替换当前状态为“停止：2”。如果失败，则当前时间轮的状态只能是“初始化：0”或者“停止：2”。直接将当前状态设置为“停止：2“</span></div><div class="line">    <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</div><div class="line">        <span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></div><div class="line">        WORKER_STATE_UPDATER.set(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</div><div class="line">            leak.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Collections.emptySet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 终端worker线程</span></div><div class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">while</span> (workerThread.isAlive()) &#123;</div><div class="line">        workerThread.interrupt();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            workerThread.join(<span class="number">100</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">            interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从中断中恢复</span></div><div class="line">    <span class="keyword">if</span> (interrupted) &#123;</div><div class="line">        Thread.currentThread().interrupt();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</div><div class="line">        leak.close();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回未处理的任务</span></div><div class="line">    <span class="keyword">return</span> worker.unprocessedTimeouts();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>newTimeout()</code>添加定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</div><div class="line">    <span class="comment">// 参数校验</span></div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果时间轮没有启动，则启动</span></div><div class="line">    start();</div><div class="line"></div><div class="line">    <span class="comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span></div><div class="line">    <span class="comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span></div><div class="line">    <span class="comment">// 计算任务的deadline</span></div><div class="line">    <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</div><div class="line">    <span class="comment">// 这里定时任务不是直接加到对应的格子中，而是先加入到一个队列里，然后等到下一个tick的时候，会从队列里取出最多100000个任务加入到指定的格子中</span></div><div class="line">    HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</div><div class="line">    timeouts.add(timeout);</div><div class="line">    <span class="keyword">return</span> timeout;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里使用的Queue不是普通java自带的Queue的实现，而是使用<a href="https://github.com/JCTools/JCTools" target="_blank" rel="external">JCTool</a>–一个高性能的的并发Queue实现包。</p><h3 id="HashedWheelTimer源码之HashedWheelTimeout"><a href="#HashedWheelTimer源码之HashedWheelTimeout" class="headerlink" title="HashedWheelTimer源码之HashedWheelTimeout"></a>HashedWheelTimer源码之HashedWheelTimeout</h3><p><code>HashedWheelTimeout</code>是一个定时任务的内部包装类，双向链表结构。会保存定时任务到期执行的任务、deadline、round等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimeout</span> <span class="keyword">implements</span> <span class="title">Timeout</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 定义定时任务的3个状态：初始化、取消、过期</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">2</span>;</div><div class="line">    <span class="comment">// 用来CAS方式更新定时任务状态</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; updater =</div><div class="line">                PlatformDependent.newAtomicIntegerFieldUpdater(HashedWheelTimeout.class, <span class="string">"state"</span>);</div><div class="line">        <span class="keyword">if</span> (updater == <span class="keyword">null</span>) &#123;</div><div class="line">            updater = AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, <span class="string">"state"</span>);</div><div class="line">        &#125;</div><div class="line">        STATE_UPDATER = updater;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 时间轮引用</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</div><div class="line">    <span class="comment">// 具体到期需要执行的任务</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimerTask task;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>, <span class="string">"RedundantFieldInitialization"</span> &#125;)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</div><div class="line"></div><div class="line">    <span class="comment">// 离任务执行的轮数，当将次任务加入到格子中是计算该值，每过一轮，该值减一。</span></div><div class="line">    <span class="keyword">long</span> remainingRounds;</div><div class="line"></div><div class="line">    <span class="comment">// 双向链表结构，由于只有worker线程会访问，这里不需要synchronization / volatile</span></div><div class="line">    HashedWheelTimeout next;</div><div class="line">    HashedWheelTimeout prev;</div><div class="line"></div><div class="line">    <span class="comment">// 定时任务所在的格子</span></div><div class="line">    HashedWheelBucket bucket;</div><div class="line"></div><div class="line">    HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, <span class="keyword">long</span> deadline) &#123;</div><div class="line">        <span class="keyword">this</span>.timer = timer;</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">        <span class="keyword">this</span>.deadline = deadline;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Timer <span class="title">timer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> timer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TimerTask <span class="title">task</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> task;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 这里只是修改状态为ST_CANCELLED，会在下次tick时，在格子中移除      </span></div><div class="line">        <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;       </div><div class="line">        <span class="comment">// 加入到时间轮的待取消队列，并在每次tick的时候，从相应格子中移除。</span></div><div class="line">        timer.cancelledTimeouts.add(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 从格子中移除自身</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        HashedWheelBucket bucket = <span class="keyword">this</span>.bucket;</div><div class="line">        <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</div><div class="line">            bucket.remove(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expected, <span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, expected, state);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">state</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state() == ST_CANCELLED;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> state() == ST_EXPIRED;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 过期并执行任务</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            task.run(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">                logger.warn(<span class="string">"An exception was thrown by "</span> + TimerTask.class.getSimpleName() + <span class="string">'.'</span>, t);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 略过toString()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="HashedWheelTimer源码之HashedWheelBucket"><a href="#HashedWheelTimer源码之HashedWheelBucket" class="headerlink" title="HashedWheelTimer源码之HashedWheelBucket"></a>HashedWheelTimer源码之HashedWheelBucket</h3><p><code>HashedWheelBucket</code>用来存放HashedWheelTimeout，结构类似于LinkedList。提供了<code>expireTimeouts(long deadline)</code>方法来过期并执行格子中的定时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelBucket</span> </span>&#123;</div><div class="line">    <span class="comment">// 指向格子中任务的首尾</span></div><div class="line">    <span class="keyword">private</span> HashedWheelTimeout head;</div><div class="line">    <span class="keyword">private</span> HashedWheelTimeout tail;</div><div class="line"></div><div class="line">    <span class="comment">// 基础的链表添加操作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</div><div class="line">        <span class="keyword">assert</span> timeout.bucket == <span class="keyword">null</span>;</div><div class="line">        timeout.bucket = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            head = tail = timeout;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tail.next = timeout;</div><div class="line">            timeout.prev = tail;</div><div class="line">            tail = timeout;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 过期并执行格子中的到期任务，tick到该格子的时候，worker线程会调用这个方法，根据deadline和remainingRounds判断任务是否过期</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</div><div class="line">        HashedWheelTimeout timeout = head;</div><div class="line"></div><div class="line">        <span class="comment">// 遍历格子中的所有定时任务</span></div><div class="line">        <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">boolean</span> remove = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123; <span class="comment">// 定时任务到期</span></div><div class="line">                <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</div><div class="line">                    timeout.expire();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 如果round数已经为0，deadline却&gt;当前格子的deadline，说放错格子了，这种情况应该不会出现</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</div><div class="line">                            <span class="string">"timeout.deadline (%d) &gt; deadline (%d)"</span>, timeout.deadline, deadline));</div><div class="line">                &#125;</div><div class="line">                remove = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</div><div class="line">                remove = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//没有到期，轮数-1</span></div><div class="line">                timeout.remainingRounds --;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 先保存next，因为移除后next将被设置为null</span></div><div class="line">            HashedWheelTimeout next = timeout.next;</div><div class="line">            <span class="keyword">if</span> (remove) &#123;</div><div class="line">                remove(timeout);</div><div class="line">            &#125;</div><div class="line">            timeout = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 基础的链表移除node操作</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</div><div class="line">        HashedWheelTimeout next = timeout.next;</div><div class="line">        <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></div><div class="line">        <span class="keyword">if</span> (timeout.prev != <span class="keyword">null</span>) &#123;</div><div class="line">            timeout.prev.next = next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (timeout.next != <span class="keyword">null</span>) &#123;</div><div class="line">            timeout.next.prev = timeout.prev;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (timeout == head) &#123;</div><div class="line">            <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></div><div class="line">            <span class="keyword">if</span> (timeout == tail) &#123;</div><div class="line">                tail = <span class="keyword">null</span>;</div><div class="line">                head = <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head = next;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</div><div class="line">            <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></div><div class="line">            tail = timeout.prev;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// null out prev, next and bucket to allow for GC.</span></div><div class="line">        timeout.prev = <span class="keyword">null</span>;</div><div class="line">        timeout.next = <span class="keyword">null</span>;</div><div class="line">        timeout.bucket = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Clear this bucket and return all not expired / cancelled &#123;<span class="doctag">@link</span> Timeout&#125;s.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearTimeouts</span><span class="params">(Set&lt;Timeout&gt; set)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            HashedWheelTimeout timeout = pollTimeout();</div><div class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (timeout.isExpired() || timeout.isCancelled()) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            set.add(timeout);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 链表的poll操作</span></div><div class="line">    <span class="function"><span class="keyword">private</span> HashedWheelTimeout <span class="title">pollTimeout</span><span class="params">()</span> </span>&#123;</div><div class="line">        HashedWheelTimeout head = <span class="keyword">this</span>.head;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        HashedWheelTimeout next = head.next;</div><div class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">            tail = <span class="keyword">this</span>.head =  <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.head = next;</div><div class="line">            next.prev = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// null out prev and next to allow for GC.</span></div><div class="line">        head.next = <span class="keyword">null</span>;</div><div class="line">        head.prev = <span class="keyword">null</span>;</div><div class="line">        head.bucket = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="HashedWheelTimer源码之Worker"><a href="#HashedWheelTimer源码之Worker" class="headerlink" title="HashedWheelTimer源码之Worker"></a>HashedWheelTimer源码之Worker</h3><p><code>Worker</code>是时间轮的核心线程类。tick的转动，过期任务的处理都是在这个线程中处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> tick;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化startTime.只有所有任务的的deadline都是想对于这个时间点</span></div><div class="line">        startTime = System.nanoTime();</div><div class="line">        <span class="comment">// 由于System.nanoTime()可能返回0，甚至负数。并且0是一个标示符，用来判断startTime是否被初始化，所以当startTime=0的时候，重新赋值为1</span></div><div class="line">        <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</div><div class="line">            startTime = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 唤醒阻塞在start()的线程</span></div><div class="line">        startTimeInitialized.countDown();</div><div class="line"></div><div class="line">        <span class="comment">// 只要时间轮的状态为WORKER_STATE_STARTED，就循环的“转动”tick，循环判断响应格子中的到期任务</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="comment">// waitForNextTick方法主要是计算下次tick的时间, 然后sleep到下次tick</span></div><div class="line">            <span class="comment">// 返回值就是System.nanoTime() - startTime, 也就是Timer启动后到这次tick, 所过去的时间</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</div><div class="line">            <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123; <span class="comment">// 可能溢出或者被中断的时候会返回负数, 所以小于等于0不管</span></div><div class="line">                <span class="comment">// 获取tick对应的格子索引</span></div><div class="line">                <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</div><div class="line">                <span class="comment">// 移除被取消的任务</span></div><div class="line">                processCancelledTasks();</div><div class="line">                HashedWheelBucket bucket =</div><div class="line">                        wheel[idx];</div><div class="line">                <span class="comment">// 从任务队列中取出任务加入到对应的格子中</span></div><div class="line">                transferTimeoutsToBuckets();</div><div class="line">                <span class="comment">// 过期执行格子中的任务</span></div><div class="line">                bucket.expireTimeouts(deadline);</div><div class="line">                tick++;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</div><div class="line"></div><div class="line">        <span class="comment">// 这里应该是时间轮停止了，清除所有格子中的任务，并加入到未处理任务列表，以供stop()方法返回</span></div><div class="line">        <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</div><div class="line">            bucket.clearTimeouts(unprocessedTimeouts);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将还没有加入到格子中的待处理定时任务队列中的任务取出，如果是未取消的任务，则加入到未处理任务队列中，以供stop()方法返回</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            HashedWheelTimeout timeout = timeouts.poll();</div><div class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</div><div class="line">                unprocessedTimeouts.add(timeout);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 处理取消的任务</span></div><div class="line">        processCancelledTasks();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将newTimeout()方法中加入到待处理定时任务队列中的任务加入到指定的格子中</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 每次tick只处理10w个任务，以免阻塞worker线程</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</div><div class="line">            HashedWheelTimeout timeout = timeouts.poll();</div><div class="line">            <span class="comment">// 如果没有任务了，直接跳出循环</span></div><div class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 还没有放入到格子中就取消了，直接略过</span></div><div class="line">            <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 计算任务需要经过多少个tick</span></div><div class="line">            <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</div><div class="line">            <span class="comment">// 计算任务的轮数</span></div><div class="line">            timeout.remainingRounds = (calculated - tick) / wheel.length;</div><div class="line"></div><div class="line">            <span class="comment">//如果任务在timeouts队列里面放久了, 以至于已经过了执行时间, 这个时候就使用当前tick, 也就是放到当前bucket, 此方法调用完后就会被执行.</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don't schedule for past.</span></div><div class="line">            <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</div><div class="line"></div><div class="line">            <span class="comment">// 将任务加入到响应的格子中</span></div><div class="line">            HashedWheelBucket bucket = wheel[stopIndex];</div><div class="line">            bucket.addTimeout(timeout);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将取消的任务取出，并从格子中移除</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCancelledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            HashedWheelTimeout timeout = cancelledTimeouts.poll();</div><div class="line">            <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// all processed</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                timeout.remove();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">                    logger.warn(<span class="string">"An exception was thrown while process a cancellation task"</span>, t);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * calculate goal nanoTime from startTime and current tick number,</div><div class="line">     * then wait until that goal has been reached.</div><div class="line">     * <span class="doctag">@return</span> Long.MIN_VALUE if received a shutdown request,</div><div class="line">     * current time otherwise (with Long.MIN_VALUE changed by +1)</div><div class="line">     */</div><div class="line">    <span class="comment">//sleep, 直到下次tick到来, 然后返回该次tick和启动时间之间的时长</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//下次tick的时间点, 用于计算需要sleep的时间</span></div><div class="line">        <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="comment">// 计算需要sleep的时间, 之所以加999999后再除10000000, 是为了保证足够的sleep时间</span></div><div class="line">            <span class="comment">// 例如：当deadline - currentTime=2000002的时候，如果不加999999，则只睡了2ms，</span></div><div class="line">            <span class="comment">// 而2ms其实是未到达deadline这个时间点的，所有为了使上述情况能sleep足够的时间，加上999999后，会多睡1ms</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</div><div class="line">            <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">// 以下为个人理解：（如有错误，欢迎大家指正）</span></div><div class="line">                <span class="comment">// 这里的意思应该是从时间轮启动到现在经过太长的时间(跨度大于292年...)，以至于让long装不下，都溢出了...对于netty的严谨，我服！</span></div><div class="line">                <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</div><div class="line">                    <span class="keyword">return</span> -Long.MAX_VALUE;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> currentTime;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Check if we run on windows, as if thats the case we will need</span></div><div class="line">            <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></div><div class="line">            <span class="comment">// the JVM if it runs on windows.</span></div><div class="line">            <span class="comment">//</span></div><div class="line">            <span class="comment">// See https://github.com/netty/netty/issues/356</span></div><div class="line">            <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123; <span class="comment">// 这里是因为windows平台的定时调度最小单位为10ms，如果不是10ms的倍数，可能会引起sleep时间不准确</span></div><div class="line">                sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(sleepTimeMs);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line"><span class="comment">// 调用HashedWheelTimer.stop()时优雅退出</span></div><div class="line">                <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</div><div class="line">                    <span class="keyword">return</span> Long.MIN_VALUE;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">unprocessedTimeouts</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(unprocessedTimeouts);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读源码，学到了很多之前不知道的知识点和注意事项。比如：</p><ol><li>操作数字型要考虑溢出问题</li><li>System.nanoTime(）返回值</li><li>Atomic*FieldUpdater类的运用</li><li>一些代码设计方式</li><li>不断优化性能，Lock Less代替Lock；Lock Free代替Lock Less</li><li>JCTool高性能队列的使用</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前因&quot;&gt;&lt;a href=&quot;#前因&quot; class=&quot;headerlink&quot; title=&quot;前因&quot;&gt;&lt;/a&gt;前因&lt;/h2&gt;&lt;p&gt;由于netty动辄管理100w+的连接，每一个连接都会有很多超时任务。比如发送超时、心跳检测间隔等，如果每一个定时任务都启动一个&lt;code&gt;Timer&lt;/code&gt;,不仅低效，而且会消耗大量的资源。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;根据George Varghese 和 Tony Lauck 1996 年的论文：&lt;a href=&quot;http://cseweb.ucsd.edu/users/varghese/PAPERS/twheel.ps.Z&quot;&gt;Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility&lt;/a&gt;。提出了一种定时轮的方式来管理和维护大量的&lt;code&gt;Timer&lt;/code&gt;调度.&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;时间轮其实就是一种环形的数据结构，可以想象成时钟，分成很多格子，一个格子代码一段时间（这个时间越短，&lt;code&gt;Timer&lt;/code&gt;的精度越高）。并用一个链表报错在该格子上的到期任务，同时一个指针随着时间一格一格转动，并执行相应格子中的到期任务。任务通过&lt;code&gt;取摸&lt;/code&gt;决定放入那个格子。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlnw9.com1.z0.glb.clouddn.com/netty-hasedwheeltimer1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上图为例，假设一个格子是1秒，则整个wheel能表示的时间段为8s，假如当前指针指向2，此时需要调度一个3s后执行的任务，显然应该加入到(2+3=5)的方格中，指针再走3次就可以执行了；如果任务要在10s后执行，应该等指针走完一个round零2格再执行，因此应放入4，同时将round（1）保存到任务中。检查到期任务时应当只执行round为0的，格子上其他任务的round应减1。&lt;/p&gt;
&lt;p&gt;是不是很像java中的&lt;code&gt;Hashmap&lt;/code&gt;。其实就是&lt;code&gt;HashMap&lt;/code&gt;的哈希拉链算法，只不过多了指针转动与一些定时处理的逻辑。所以其相关的操作和&lt;code&gt;HashMap&lt;/code&gt;也一致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加任务：O(1)&lt;/li&gt;
&lt;li&gt;删除/取消任务：O(1)&lt;/li&gt;
&lt;li&gt;过期/执行任务：最差情况为O(n)-&amp;gt;也就是当&lt;code&gt;HashMap&lt;/code&gt;里面的元素全部hash冲突，退化为一条链表的情况。平均O(1)-&amp;gt;显然，格子越多，每个格子上的链表就越短，这里需要权衡时间与空间。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="软件技术" scheme="https://zacard.net/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="netty" scheme="https://zacard.net/tags/netty/"/>
    
      <category term="时间轮" scheme="https://zacard.net/tags/%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
    
      <category term="HashedWheelTimer" scheme="https://zacard.net/tags/HashedWheelTimer/"/>
    
  </entry>
  
</feed>
